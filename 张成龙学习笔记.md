# 说在前面

​	子曰：“工欲善其事，必先利其器”。为了能提前进入学习状态，更好的适应读研的环境，特此利用这段录取后未入校的时间先学习了读研所需的东西。与其在纸面上学知识不如自己实际动手去做，去亲身感受安装、排错、敲代码的艰辛历程。提前做了这些准备工作，一方面可以减轻开学后再做这些工作的压力，另一方面也可以造福同级的小伙伴。同时这也作为我的一个学习记录，供各位参考。

​	写此文之前我已成功安装过 Ubuntu 18.04 + ns3.30.1，其间遇到的问题，出现的错误多之又多。第一次安装以及搭建环境花费了我近一周的时间，各种重装系统、重新编译也是很让人恼火。

​	由于本人水平有限，如有不足之处，希望各位大佬不吝赐教批评指正。此文是我参照了n个网页，百度，google了m多次总结出的结晶，因参考的东西太多了无法列出我的参考文献。希望我这段时间的努力能够帮助到参考本文的各位。

​	本文图片基于QQ相册，在浏览本文时需要联网方可正常显示图片。

***

# 一、安装

## 1.总览

​	我的电脑是15年9月购买的神舟Z7M-i78172D1，配置如下：

​	操作系统：Windows 7 旗舰版 64位 SP1

​	处理器：英特尔 第四代酷睿 i7-4720HQ @ 2.6GHz（四核八线程）

​	内存：16GB （英睿达 DDR3L 1600MHz）

​	硬盘：250GB固态 + 1TB机械

​	显卡：Nvidia GeForce GTX 965M（2GB）

> 建议：内存建议有能力一定要升级到16GB，否则编译NS3时会因为内存不足而卡死。

​		**记得在BIOS里开启虚拟化，否则无法安装虚拟机软件。**

​	

## 2.系统安装

​	因为考虑到网上各种教程的版本不一，且因为Ubuntu不同的版本很多依赖包都改了名或直接删除，我这里所有软件都是安装的最新版。写此教程时，Ubuntu已更新至20.04.1，我的系统安装版本为20.04，后期考虑通过软件升级至最新系统。NS3我也是装的最新的ns3.31，以此来测试最新的系统对我们搭建好的环境的兼容程度。

> 故本文以下的各种安装环节基于Ubuntu20.04 + ns3.31

​	并且利用好VMware自带的“快照”功能。（相当于备份）

​	

### 2.1 VMware的安装

​	我的VMware是16年安装的VMware Pro 12，因嫌麻烦而且怕高版本不兼容Win7所以就还是用着老版本，此处忽略VMware的安装步骤，这里直接安装Ubuntu。以下步骤都是基于VMware Pro 12，如VMware版本不是我这个版本，个人感觉区别不大，如有不同，建议百度解决。

​	

### 2.2 Ubuntu安装

> 此处需要提前准备好Ubuntu安装包。
>
> 下载地址：http://releases.ubuntu.com/20.04/

​	1.打开VMware，点击左上角文件![image-20200817130831826](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPAmsgP6OdxXI6CcV7FkVmm72sIsmZpwRJSzaFd98V0cGj.HDvbqKAdRW1Nrr9j8maJVY9gIA9Io3AKPMPb5vno!/r)，选择新建虚拟机。

​	

​	2.选择自定义，点击下一步。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEO4j6LDQVoXu7FN8*HRdzRVTEaIaYMq8oKC2811QhUoD6lhcdIPyQIHTS20cMgp65TAEt3EU72svEr4qUQpeE2g!/r" style="zoom: 100%;" />

​	

​	3.选择虚拟机硬件兼容性，这里默认，直接点击下一步。

​	

​	4.安装客户机操作系统，这里我们选择稍后安装操作系统，点击下一步。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEKjHDQZkxtoTwQSCiWc6KrazN37MNFsChU8JHNTeEvwnJxRa3cB1F0*HBxr5lleV1D*vzVVJ3FV0hm5FPUMeYEA!/r" style="zoom: 100%;" />

​	

​	5.选择具体要安装的版本，这里我们选择Linux操作系统，在下拉列表里选择Ubuntu 64位，点击下一步。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEFoGHJ6wbhV8Y6DGAKUEZ7WHrC5KZKUsTbq7a1pUH5ivj7VojxHPj36OywR6e5HrqxeAJ29ZW7qvpoOYgpzgHto!/r" style="zoom: 100%;" />

​	

​	6.给虚拟机命名，以及选择虚拟机的存储位置，这里根据自己的需要填写。填写完后点击下一步。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEC8TCoPJQG6Znxqi1*gWUKk7uApU8RmaqsQdwxDrcvM.WbRRlfYtrYGUFokErB0rHwYIWZAgYcOjorcwMU6zWpY!/r" style="zoom:100%;" />

​	

​	7.处理器配置。因为我们后期要使用waf编译NS3，这里我们根据个人实体机的配置尽量给的高一些。点击下一步。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPPUJe26tj5swVZIoLa81gxztbvjf4L58T.d7TQWbOBQulYQ94Ee4AixB9H0kXb*jtMJdlO5qNjqQWybOOokXo4!/r" style="zoom:100%;" />

​	

​	8.虚拟机内存。安装NS3时通过waf编译要占用大量的内存，这里强烈建议分配6GB内存（实测若分配低于4GB，在编译NS3时会很慢或者卡死）。点击下一步。

> 注意！此处大坑！我第一次分配4GB编译仍然卡死，这里忽视图里，直接分配6GB。详见3.5编译章节。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEJ3gSM.siqdkdqop1Qw2A66a2Rn19W2Q*uCAn6OKN9pHKyLAMgldOtAdTh3giIwSUZPe4C9ZC9lUqusNJ0DAueY!/r" style="zoom:100%;" />

> 这也是前文建议把实体机升级到16GB的原因。若实体机内存只有8GB，建议实体机关闭其他占内存的无关程序，仍然分配4GB内存或更多，但要设置swap分区来保证编译完成。

​	

​	9.网络类型。这里默认使用NAT转换，点击下一步。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPiJZC9RSRp*sI9g7fZrT5vA.X07KMnOdZ7R1lHE85AYku33OeElAnMR0pscwVUpDdbWyHuty2uOpcg6yKk97BA!/r" style="zoom:100%;" />

​	

​	10.I/O控制器类型。这里采用默认推荐的设置，点击下一步。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEHw71XnRdPiFnyQ7xIkHhRqzM40EdPEcfc7cBGXyApNO4qPjZM*r*YcZ16R1iyifscpy67nUvQwNUloN4jlVfCc!/r" style="zoom:100%;" />

​	

​	11.选择磁盘类型。这里同样采用默认推荐的设置，点击下一步。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBISlPjM2fBfK3IqMqtir0jMdDBI4I3unWG3oPmRCPaGk4IrzdOS26zkeIWKzMNueaC1S2jJYeATW6UHl7AvqlE!/r" style="zoom:100%;" />

​	

​	12.选择磁盘。因为我们要创建一个新的虚拟机，所以选择创建新的虚拟磁盘，点击下一步。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBklMaV5F6t.tr42lPH.RJdU6*b1Ol0HbB2if62aYQtrdGNGgErUMdV7JN2d6*GTueqg7lDlB50twPFzIHxAd0U!/r" style="zoom:100%;" />

​	

​	13.指定磁盘容量。因为我们要安装NS3及其他编程所需环境，20GB不够。这里我们分配40GB。让系统随着我们的使用来增大在实体机上实际占用的存储空间，从而节省实体机的存储空间，我们取消勾选。让虚拟机存储为单个文件，从而方便以后的管理以及移植。配置完成后点击下一步。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEJUnrU6HeHIL9CL*pP.0.Wri63jYeTjQLEQof9fSiIUH7hSng0oQ7FW3w9PbroIuDKOvm.f5Uqi5LsbvaOz.oV4!/r" style="zoom:100%;" />

​	

​	14.选择在实体机上存储的文件名，一般默认即可，点击下一步。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEAAATErd3mbYHbmKku1ig*N10KW7r91QyABQElgY0g76GvAt8UkMuD2mHH8OTaDrmaS3XjujLd5246*Yd2W5300!/r" style="zoom:100%;" />

​	

​	15.全部配置完成，检查各项参数有无问题，无误后点击下一步。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrECCj3q6.6S7hBUP2tVDLmHckh0B36AAq6CQ*gTDK5mVXeIXtHqlD3ZhnYPIofQwGXsIANB*nrbkgJ*nFdrTVA04!/r" style="zoom:100%;" />

​	

16.虚拟机创建成功，点击页面上的CD/DVD，配置好Ubuntu20.04的光盘镜像。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEIZ*5aXlfCQAN9MpKGOK2hu4hoC8H0HkwfPExNLMneBw3y9G3m0yHYYpOF*zir5yQoRc*3ZC5R035dTweSAkKBQ!/r" style="zoom:100%;" />

​	

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEK7h*pFsLHfpZazXRI6CitPAhf1p5PCga6DqgqV0HNLoABCEbXmrzVbSaiK0okHpgHM9tm8Z*Jzmn1GUykiB1AI!/r" style="zoom:100%;" />

​	

​	17.设置完毕后，点击开启此虚拟机，准备安装系统。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEIWANizgKcj9SjPKnCeZoSP5gXFjbIVsQ3O2DDKzv2lkzhwkNzS1*Dvxc1FSTPTpR1KRK2i54yI7TiZqs2YiID4!/r" style="zoom:100%;" />

​	

​	18.进入安装步骤，在左侧下拉列表里把语言切换为简体中文，再点击右侧的“安装Ubuntu”。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEL*4H1QPLKOU4YUrWDua1ImNXsrBxzz*1v86MAB.MzhP9.g.F16uVNPg2tQGcpjfIzq9P1VkHRi1411NLinWKw4!/r" style="zoom:100%;" />

​	

​	19.键盘布局采用默认的信息就可以，点击继续。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrENXM2i2hLdvRCPgUtvsTks6NoN*IEDJpHjQ00wNMcbLuSliVpWukP0YgZSFEmSwSIeLknCV6HhpB9a8GHOjdY.I!/r" style="zoom:100%;" />

​	

​	20.进行安装设置，这里我们采用正常安装，取消勾选安装Ubuntu时下载更新，以节约我们的安装时间，其他信息默认，点击继续。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBoVFb6k8s73kugurifT278NfBgR47tJjf7Y33NBr2IuxEMgG.6vx3llP5NDK7BYMnZ8Bmjlo3WCBWeFe0j3q58!/r" style="zoom:100%;" />

​	

​	21.由于我们新建的虚拟硬盘是空的，这里我们选择清除整个磁盘并安装Ubuntu，点击现在安装。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEFxm4Bx.Sf9mltNYfvccEi3SSuGpfvTE2U7RoRTjhUU4we6EcHOl6VRwWyce4YE7ZtD2Hl9Cl.bX3DVzq.ooMWc!/r" style="zoom:100%;" />

​	

​	22.提示我们是否要将改动写入磁盘，我们选择是，点击继续。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEOD4EndPyhG8F8vpIzeF.5u6qs99zldL0xSuriZ0H*1sbUfI8TbF0rSw4L8ahMqMDZUe8l6B6wqxk2VBa9Oi2iA!/r" style="zoom:100%;" />

​	

​	23.选择位置，这里默认上海，直接点击继续。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEMycBSjPT8TAoFhyCCIJQsxNd3pAcRvJwTsAv7yCOg.RfUctm4JSiTCNGG3VFrHQhHw7sFWuvgop7Kidl3CyuFE!/r"  />

​	

24.设置用户名，账号信息，这里根据自己需求设置，选择自动登录，这样我们开机就不用输入密码了。点击继续。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBwQ.HRTeIQ4t8pISTBIuaZzk8impIfbFyEG2m8v43KMPpxXSvUyd9YokpUPxBYVjnrSVtdxLLLbCOaAaVHP95o!/r"  />

​	

​	25.系统开始安装，等待......

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEMIDWbB2NDjyXOOfMLpqTkE1DXymdXKzuK67b12vnWz9DeX9gHdkGlPMAw.HzwVNwbVrZX9ALiiZ2ZwdhLfCPz4!/r"  />

​	

​	26.经过漫长的等待，安装成功，点击重新启动按钮重启虚拟机。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEN7ZKmhXTm06apKmY02Q4.RN5t9Pv2NcmiiVPjORa9VgfhWNlJBKdfi0p4jmIqmOjdTax.nA*UWYDrNXBZsR.yA!/r"  />

​	

​	27.重启完毕，进行最后的设置，让我们连接在线账号，这里直接点击右上角跳过。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrED*SGqtid6hDVhiE.fO44CBBPylilp2VCKoboEXslZl8YNPcDBxxTAD7fcz8Qoydn0qrLngUhQZ2NYIwSJF0Ock!/r"  />

​	

​	28.类似于杀毒软件的东西，不设置，直接点击右上角前进。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEOTX6WfRrv14t8h8H6DIobMHMh8zhJs.xWDFaett**QZ.RYrRPPup*s4iJeeoN3OMqbbnp1u0fUIE54J*.krTXE!/r"  />

​	

​	29.用户改进措施，选择否。继续点击右上角前进。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPng8kgZJtblPhzy6dQxmNZlKzK0f4c1YbJOI1dNs7bpA5T4Hwtsu57Zslbp6IYDIkwRowCqbi1J9IJzenyMaFE!/r"  />

​	

​	30.位置服务，选择否，继续点击右上角前进。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEFuJ8jdMNGERYvIWNePKM64BFYshXAoUVNByIBQj8diASbG1RZGlzMhlPSOsvEvdSvtuoWRt5cO1PCT7sTHszd4!/r"  />

​	

​	31.系统设置结束，点击完成，正式进入系统。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEFTrgHjLh2YsWVvULzPvPf5*mqQZScPxs.qVyjx2U35uBl0879tno9JPpLHhy*Yox2LcOVatUfteE3A.ZJvZgj8!/r"  />

​	

### 2.3 Ubuntu设置

> 注意，从此处开始需要Linux基础，如果0基础建议先去看一下Linux的基础。

​	1.更改分辨率，由于默认分辨率太小，看起来太麻烦，所以我们更改分辨率。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEKvdVYSFwR6xZMzvieIQ.AF5QRb2g3Arlg3QxvXyaXzgaTFNZ.fxUh1jGXBMhcm1E05n0GGKGxfWQ.pvk3CazJQ!/r"  />

​	更改至自己舒服的大小，我的大小是1440*900。这里选择多少都无所谓，后文安装好VMTools后桌面将会铺满整个虚拟机页面。

​	

​	2.更改国内软件下载源，从而使得后期我们在安装软件、安装包的时候的速度快一些。

​	打开`软件与更新`（左下角九个点菜单搜索栏内搜索），在`下载自`选择其他，在下拉列表里找到清华大学的软件镜像，选择。确认。之后重新载入软件信息，重启虚拟机。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEOUdQi4sg*Jfrmxt9N9VnRVhhyEyIqtTXL.1YeG*t7QRfsBANNl7OsoWB9con3k2WlAYPQ*bLoPm*4U6sFIYBpc!/r"  />

​	

​	3.设置中选择电源，设置永不休眠。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEItLayY7S8DaeZR7FFU*cpYsaxx68WRlVvBjfzielkx2sfVOxWpkRZ8lvHGJvtXKiGKHaGryyalPRgJQ3sc.cXA!/r"  />

​	

​	4.把终端添加到收藏夹，方便我们以后用命令行环境。

​	按键盘的`Ctrl `+`Alt`+`T`，打开终端，在右侧任务栏中右键终端图标，点击“添加到收藏夹”即可

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBDmL8Ch4uFHxBguhd8T8G2zqxgEbryrsVEb6HvX1E7ynftfwUgZTha0sYnnz.k*FcQ5hNZxYyd47rVCBO5ekSo!/r"  />

​	

​	5.设置root密码，打开终端，输入

```shell
sudo passwd root
```

​	此时提示我们输入当前用户的密码

![image-20200817164223948](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPlCtpol8hNEFjVASuiItVU9e2bCeuDCH6xty29A8BLMuXzXOtWC8Vtgo2edufnP2uWTzhQS4Bq.JwUcGkd2DDc!/r)

​	输入当前用户密码，新的root密码，再次输入新的root密码

![image-20200817164342552](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEHeAF7LIE5fpeRBJG9IvE9u61RBAJ7ycEbQ*ZsybBFjc0fnaK9.Lslf8e*1Xh9Vfv7HvV.7Ja3q1byIJDsG2xug!/r)

​	此时已成功更新root密码，下面在命令行中输入

```shell
su root
```

​	系统提示我们输入root密码，输入成功后，用户从之前我们设置的用户变为root用户，则设置成功。

![image-20200817164541297](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrELprms3i152hY7mZ7enilpaLCv7xqZWD7ahZ0Vx0EZNZvK0lm.U8TwqoCEOhHkgOvUreXyeIyXnGAwIYjQxqhoE!/r)

​	

### 2.4 安装VMware tools

​	VMware tools是一个虚拟机辅助程序，可以让我们在虚拟机以及实体机之间实现复制粘贴，文件拖拽传输。

​	点击VMware左上角的`虚拟机`选项卡，选择`安装VMware tools`，此时系统会挂载相应的光盘镜像。

​	进入终端，使用root用户登录，并依次输入以下代码。

```shell
apt-get install net-tools -y
cd /media/zcl/VMware Tools/ #挂载的光盘镜像位于/media/用户名/Vmware Tools
mkdir /VMwareTools
cp VMwareTools-10.0.0-2977863.tar.gz /VMwareTools
cd /VMwareTools
tar -zxvf VMwareTools-10.0.0-2977863.tar.gz
cd vmware-tools-distrib
./vmware-install.pl
```

​	然后碰到让输入yes no的，一路yes。不让输入yes no的，就一直回车，默认安装。

​	安装成功后，重启虚拟机，Ubuntu界面铺满整个虚拟机页面。并自行测试实体机与虚拟机之间的复制粘贴、拖拽文件传输。

​	

## 3.安装NS3

### 3.1 说明

> ​	**不要随便在网上百度安装！不要随便在网上百度安装！不要随便在网上百度安装！**

​	重要的事情说三遍，如你你的Ubuntu版本为20.04，且想安装ns3.31，一定全程参考本文安装。如你想安装其他版本，一定要参考官方文档安装！因百度上搜到的安装过程的版本号不一，有的很老，有些包的依赖已经更新。故不要随便在网上自己搜安装过程。

​	访问官方安装文档

> https://www.nsnam.org/wiki/Installation#Installation

​	下拉找到Ubuntu/Debian/Mint安装，可以看到，官方文档基于Ubuntu19.04 + ns3.29。

​	此前我安装ns3.30.1后出现bug。bug链接如下：

> https://gitlab.com/nsnam/ns-3-dev/-/issues/72

​	后文也对此bug作出了debug。详见本文3.6.5章节 可视化环境DeBugs。

​	所以这里我们安装最新的ns3.31。

​	

### 3.2 安装依赖包

​	在**终端root用户**下依次输入以下命令安装依赖包：

​	1.首先是C++和python3（其实ubuntu 20.04已经内置了）：

```shell
apt-get install g++ python3 -y
```

​	

​	2.如果要安装的版本是3.30或3.31或ns-3-dev，你还需要安装(推荐安装)：

```shell
apt-get install g++ python3 python3-dev pkg-config sqlite3 -y
```

​	

​	3.对Python（开发）的最低要求，安装git方便后期通过git下载东西。以及其他需要的软件包才能获取并成功安装pybindgen和netanim：

```shell
apt-get install python3-setuptools git -y
```

​	

​	4.Qt5：

```shell
apt-get install qt5-default mercurial -y
```

​	

​	5.ns-3-pyviz可视化工具的依赖：

> 注意！分版本

* 对于ns-3.28和更早的版本，PyViz基于GTK + 2，GooCanvas和GraphViz：

```shell
apt-get install python-pygraphviz python-kiwi python-pygoocanvas libgoocanvas-dev ipython -y
```

* 对于Ubuntu 18.04及以上版本，不再提供python-pygoocanvas。 ns-3.29和更高版本将支持升级到GTK +版本3，并且需要以下软件包：

```shell
apt-get install gir1.2-goocanvas-2.0 python-gi python-gi-cairo python-pygraphviz python3-gi python3-gi-cairo python3-pygraphviz gir1.2-gtk-3.0 ipython ipython3 -y
```

​	（DeBug）若出现错误：无法定位软件包 ipython，python-pygraphviz

​		解决方案：直接删掉这两个找不到的包。

​	

​	6.基于MPI的分布式仿真的依赖：

```shell
apt-get install openmpi-bin openmpi-common openmpi-doc libopenmpi-dev -y
```

​		

​	7.bake构建工具的依赖：

```shell
apt-get install autoconf cvs bzr unrar -y
```

​	

​	8.调试

```shell
apt-get install gdb valgrind -y
```

​	

​	9.utils / check-style.py代码样式检查程序的依赖：

```shell
apt-get install uncrustify -y
```

​	

​	10.Doxygen和相关的在线文档：

```shell
apt-get install doxygen graphviz imagemagick -y
apt-get install texlive texlive-extra-utils texlive-latex-extra texlive-font-utils dvipng latexmk -y
```

​	

​	11.ns-3手册和教程使用Sphinx的reStructuredText（doc / tutorial，doc / manual，doc / models）编写，并且图形通常以dia（还需要上面的texlive软件包）编写：

```shell
apt-get install python3-sphinx dia python3-pygccxml -y
```

​	

​	12.GNU科学库（GSL）支持更精确的802.11b WiFi错误模型（OFDM不需要）：

```shell
apt-get install gsl-bin libgsl-dev libgsl23 libgslcblas0 libgcrypt20-dev -y
```

​	

​	13.读取pcap数据包跟踪：

```shell
apt-get install tcpdump -y
```

​	

​	14.数据库对统计框架的支持：

```shell
apt-get install sqlite sqlite3 libsqlite3-dev -y
```

​	

​	15.配置存储的基于Xml的版本（需要libxml2> =版本2.7）

```shell
apt-get install libxml2 libxml2-dev  -y
```

​	

​	16.支持生成修改后的python绑定（这步官网是安装的pip，但是现在一般都是python3，ubuntu20.04已经不支持pip，这里换成了python3的pip）：

```shell
apt-get install cmake libc6-dev libc6-dev-i386 libclang-6.0-dev llvm-6.0-dev automake python3-pip -y
python3 -m pip install --user cxxfilt
```

​		通过执行以下代码，确认pip是否安装成功：

```shell
pip3 --version
```

​	

​	17.基于GTK的配置系统：

```shell
apt-get install libgtk-3-dev -y
```

​	

​	18.试验虚拟机和NS3：

```shell
apt-get install vtun lxc uml-utilities -y
```

​	

​	19.Openflow模块：

```shell
apt-get install libboost-signals-dev libboost-filesystem-dev -y
```

​		（DeBug）若出现错误：无法定位软件包 libboost-signals-dev

​			解决方案：将上述代码换为如下命令

```shell
apt-get install libboost1.67-dev libboost-signals1.67-dev -y
apt-get install libboost-system1.67-dev libboost-filesystem1.67-dev -y
```

​	

### 3.3 下载及解压

​	NS3的官方下载网站：

> https://www.nsnam.org/releases/

​	但由于众所周知的原因，不通过特殊手段在官网直接下载会很慢很慢。这里我把我下载好的ns3.31安装包上传到了百度云，在Ubuntu里自带的火狐浏览器里打开链接即可。

> 链接：https://pan.baidu.com/s/1lzrocMBbhfwzB11lFoWqDw 
> 提取码：w1ik

​	将NS3复制到用户目录：

```shell
cd /home/zcl/下载
cp ns-allinone-3.31.tar.bz2 /home/zcl/
```

​	解压安装包：

```shell
cd ..
tar -xvf ns-allinone-3.31.tar.bz2
```

​		

### 3.4 配置

​	进入安装文件夹：

```shell
cd ns-allinone-3.31/ns-3.31
```

​	由于一开始安装了Pyviz可视化工具库，在配置的时候需要指定pybindgen的路径，否则Pyviz无法检测到。还需配置编译版本为debug模式，同时使得实例代码和测试代码可用。

```shell
#需提前找到pybindgen文件夹的位置在哪
cd ..
cd pybindgen-0.21.0
pwd
#此时显示pybindgen文件夹位置
cd ..
cd ns-3.31
./waf configure --build-profile=debug --enable-example --enable-tests --with-pybindgen=/home/zcl/ns-allinone-3.31/pybindgen-0.21.0 --enable-sudo
```

​	

​	经过编译，发现编译过程中有很多报错的，无视掉，最重要的Pyviz、Python Bindings 都激活了就可以。

![image-20200817224120097](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEFtZoZjaSzpa0dgqdXLOczO4pX9j*xXcVZQvm4lqy.1MY6VMbyto8Qgx*ZhZN1BPlQnwIR*LHTNAkiyR1p1M2uk!/r)

​	

### 3.5 编译

​	在`ns-3.31`目录下执行

```shell
/.waf
```

​	开始编译。**（此处耗时较长，此处虚拟机内存不够极有可能卡死。6G以下建议添加swap分区以保证不卡机）**

​	分配4GB，未设置swap分区，在编译过程中卡死。卡死位置位于`build/src/network/bindings/ns3module.cc`

​	强行关闭虚拟机，添加内存到6GB，开机，开启实体机的强冷，重新编译。

​	编译持续37分钟，成功结束。这里没有编译的模块，我们在检查配置过程中已看到只是我们在配置步骤里未启用这些模块，不必惊慌。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEGrwji5nGSHqU..tPR8nOIOUCqXtARoiFxs5pd6fh6PCTlqEMHpRd3uLfuay5n9UdEsrgO6WiQJQwUU6MlFWb8g!/r"  />

​	

### 3.6 测试

#### 	3.6.1 模块测试

​	仍然在`ns-3.31`目录下，输入命令

```shell
./test.py -c core
```

​	进行模块测试。

​	测试持续时间较长，看到如下输出则代表成功

![image-20200818004934079](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEOH6tmEDZC9OJ1GIhptokNNrHXzvNihKrfUG.w2FB5pGThKjvNA2TZ6tw62l0oCUxYkCRhzUablnETn8GCGIIh0!/r)

​		

#### 	3.6.2 运行测试

​	仍然在`ns-3.31`目录下，输入命令

```shell
./waf --run hello-simulator
```

​	进行程序测试。如果输出如下图

![image-20200818005259125](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBpScHYxI97fwd3BdVZOosk6aTQFCK*9MkoS9U3geJflsXn.UqiwKH10k8IZApzzvrhHIpgTNFBgnK3LI*Xhus8!/r)

​	则为安装成功

​	

#### 	3.6.3 官方示例程序测试

​	NS3的运行文件夹为`scratch`文件夹，所有要运行的文件都应放在这个文件夹下。

​	仍然在`ns-3.31`目录下，测试官方的示例程序。

```shell
cp examples/tutorial/first.cc scratch
cp examples/tutorial/second.cc scratch
./waf --run first
./waf --run second
```

​	如果输出如下图，则为正常

![image-20200818010558941](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEKg5b368oE7C7b4id.YjNPN2vriTMOIDN6fYFEYKJSe.HmmyvTpD3hlq0Rw4EJ4kTThADjdeMvviz7917Fluk98!/r)

​	

#### 	3.6.4 可视化环境测试

​	仍然在`ns-3.31`目录下，测试官方的示例程序。

```shell
./waf --run first --vis
./waf --run second --vis
```

​	如运行结果分别为下图，则为安装成功。

![image-20200818013640555](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEOmSWgn*WuBII0.RxjbKz9iGkaOO3Hu4fT5pVyDlmIKxpRBWpP9c.HMpoWBmYPYa4MFADuWliHqGgSuRV6Az2T0!/r)

​	

![image-20200818013416006](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEIY35ZjF3U2Vpc1*8LpwlPYkWXL59Kx*EvwdxS54XlT*PWKCKtyVFfL56oJkzQ1jGzEAX4ZLgsI8NdauB9RBo70!/r)

​		



#### 3.6.5 可视化环境DeBugs

* **（DeBugging）vis运行后，报错：**

>Could not load plugin 'show_last_packets.py': No module named 'kiwi'
>Could not load icon applets-screenshooter due to missing gnomedesktop Python module

​	不影响实际使用体验，安装的ns3.30.1也是这个问题，待解决。

​	

* **（DeBug）未永久解决：运行后，鼠标指到节点上时，出现连串的报错信息：**

>XDG_RUNTIME_DIR (/run/user/1000) is not owned by us (uid 0), but by uid 1000! (This could e.g. happen if you try to connect to a non-root PulseAudio as a root user, over the native protocol. Don't do that.)

​	这是由于我们的root环境是从用户zcl进行 su root 得来的，而环境变量 XDG_RUNTIME_DIR 继承自zcl用户环境，可以执行

```shell
export XDG_RUNTIME_DIR=""
```

​	来清除环境变量，或也可以通过执行

```shell
sudo -i
```

​	以获得一个纯净的root权限环境。

​	执行完以上步骤再运行NS3项目：

```shell
./waf --run second --vis
```

​	运行后，错误消失。（或者不用root权限执行NS3程序）

​	

* **（Debug）ns3.30.1版本`--vis`CSMA节点无法正常显示**

​	我安装了ns3.30.1，对官方的second.cc执行可视化模拟

```shell
./waf --run second --vis
```

​	 所有节点、csma网络无法正常显示出来并且命令行在疯狂报错：

![image-20200817193446646](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEOGLR5L.JtILB9pCjXHEojUN5JwOIs*JX57z3BXfeG1N11WohbeFySaUydwW8ocu6NkUFOpuYJriIomduDPaAQk!/r)



​	经过查询，这是ns3.30.1的一个bug，当一个拓扑中有两个以上节点的CSMA链接时，PyViz无法绘制并报告许多绘制失败。

​	官方已有勘误，勘误链接如下：

> https://www.nsnam.org/wiki/Ns-3.30_errata

​	其中：

​	`Pyviz and CSMA links`

​	问题描述：https://gitlab.com/nsnam/ns-3-dev/issues/72

​	修复教程 (仍测试中): https://gitlab.com/nsnam/ns-3-dev/merge_requests/113

​	

​	解决方案：

​	更改ns-3.30.1目录下的`src/visualizer/visualizer/core.py`文件

```python
#529行-537行改为如下
self.channel = channel
self.canvas_item = GooCanvas.CanvasEllipse(radius_x=30,radius_y=30,fill_color="white",       stroke_color="grey",line_width=2.0,line_dash=GooCanvas.CanvasLineDash.newv([10.0,10.0]),
  visibility=GooCanvas.CanvasItemVisibility.VISIBLE)
# self.canvas_item = GooCanvas.CanvasEllipse()
# self.canvas_item.radius_x=30
# self.canvas_item.radius_y=30
# self.canvas_item.fill_color="white"
# self.canvas_item.stroke_color="grey"
# self.canvas_item.line_width="2.0"
# self.canvas_item.line_dash=GooCanvas.CanvasLineDash.([10.0, 10.0])
# self.canvas_item.visibility=GooCanvas.CanvasItemVisibility.VISIBLE
self.canvas_item.pyviz_object = self
self.links = []
```

​	

​	修复后，无须重新编译整个NS3，系统自动编译我们更改过的文件，我们只需重新运行模拟

```shell
./waf --run second --vis
```

​	即可正常显示。

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEKZgGf*NcvbqUZf17DjIH99UK3OJ055WhgYy3YAOFqXUK9FkNLSQDR0nVzmPFI.rJeCARPIRN.0TxrumVk9HG6Y!/r"  />

​	

## 4.编程环境优化

### 4.1 安装Chrome浏览器

​	Chrome大家都懂得，还是装一个吧。

​	实测应用商店的Chromium无法打中文，所以我们自己下载Chrome。

​	使用Ubuntu自带的火狐浏览器打开https://www.google.cn/chrome/，选择默认适用于ubuntu的64位.deb，点击接受下载。下载成功后在火狐浏览器的下载列表里打开下载位置，进入到下载目录。然后右键在终端打开，执行 

```shell
sudo dpkg -i google-chrome-stable_current_amd64.deb
```

​	下载结束后，将Chrome添加到收藏夹。（如果忘记，参照本文2.3Ubuntu设置的第4步）

​	

### 4.2 安装搜狗输入法

​	系统自带的中文输入法不好用，故安装搜狗输入法。

​	搜狗输入法基于fcitx框架，首先安装fcitx框架。在命令行中使用root用户输入以下命令

```shell
apt-get install fcitx -y
apt-get install fcitx-table -y
```

​	使用Chrome浏览器访问搜狗官网

> https://pinyin.sogou.com/linux/?r=pinyin

​	下载安装包，在Chrome中打开，安装完毕后重启虚拟机。

​	重启后，依次点击右上角设置-区域与语言-管理已安装的语言，键盘输入法系统修改为fcitx，之后点击应用到整个系统，再次重启虚拟机。

![image-20200904210615659](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEAoXhfxLLJnA7gS8dRM1zTTr0Js2zCbn8kvj3ZeF1RDvubYfUphR.UQHEK1u3ZQ8HX33Qht0Hn.m2HSc69X9MZg!/r)

​	

![image-20200904210709016](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEOEbJQCCxZqfc8iSjdgN*UMHsxX9iV*bwhtAqD7cr7YmWaJUKHi0z*ndqCleh.F6a7VWRIQX3yQxfyXy1DzSt1Q!/r)

​	

​	重新启动后，点击右上角的小键盘图标，点击“配置当前输入法”。

![image-20200904211000903](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrELDEkEEEek*v26bcZ5lpuzlCg1*TwR.8NWUs9QrWQsOCEzcU96NTNRtht5fTHLE7xbmgQL1oaVdsA44WRe941k0!/r)

​	

​	点击左下角加号，取消勾选“仅显示当前语言”，找到搜狗输入法并添加到输入法列表中，调至第二位并去掉其他无关输入法（参考我图里的）。

![image-20200904211420902](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPq9yzdrztJGYx*eRjujJlxLmh3FlGwFdGuSqe84P3.QDMhNn9.yIBTA2xzhumxFp9IN2.hNuKvAr*Iarnr.xlo!/r)

​	

​	之后按`Ctrl`+`Shift`或单按`Shift`，右上角小键盘变成搜狗的标志，就能愉快的打中文啦。

![image-20200904211939182](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEFKQGq8SGbT0UIbh5G8VJQ5nXSEGcwsLIr12Ht*Bw8huR4xhUOJZy1UBdgNLMg398T0GdUdDUj5clXyhEoIJ5ho!/r)

​	

### 4.3 安装vscode

​	纯文本编译器手敲代码敲到怀疑人生，IDE他不香么？

​	目前已知可以用的IDE有eclipse以及vscode，但eclipse不能代码高亮，代码自动提示，所以我们选择vscode作为我们的开发环境。

​	经过我的实验，Ubuntu自带商店里的vscode是削减版，无法打中文，所以**不要在官方商店里安装vscode**！

​	vscode下载地址：

> https://code.visualstudio.com/Download

​	在Ubuntu的Chrome浏览器里打开上面的链接，因为我们是Ubuntu的系统，选择 .deb文件，进行下载。下载成功后，在Chrome里打开，选择软件安装（这也是我喜欢Chrome的原因，可以在下载安装包后直接进行安装）。

​	下载结束后，将vscode添加到收藏夹。（如果忘记，参照本文2.3Ubuntu设置的第4步）

​	

### 4.4 配置及优化vscode

#### 4.4.1 配置用户目录

​	打开命令行（普通用户），进入NS3的安装目录

```shell
$ cd /home/zcl/ns-allinone-3.31/ns-3.31/
$ code .
```

> 注意code跟点之间有一个空格

​	此时vscode自动打开，此时的vscode里的目录就是ns3.31这个文件夹。

​	在左侧用户目录里打开我们之前运行过的`scratch`文件夹下的`first.cc`，显示如图

![image-20200818175855378](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEOf67jaX8hjIfbS5p5ilGqwx.iQOI11*9ngwp0PfSPcVnekdi8hQw0v4GQRNtsdmMyHJXQ3SVsKfsgIVCwlmzWQ!/r)

​	

#### 4.4.2 安装扩展模块

​	注意到，此时用户界面还是英文。并且我们在NS3里用的点对点助手，网络设备容器之类的对于vscode都属于自定义头文件中的用户类，下一步我们安装必要的C++扩展以及语言包。

​	

​	点击左下角的设置齿轮，找到`Extensions`（扩展），或是按键盘的`Ctrl`+`Shift`+`X`，进入扩展商店。

![image-20200818180143234](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEHQP0xjrBy3z6z86SwJKOt2pHGpkD6EcnNdTL4G39mX8I5tsViinsTvuT3V2zkYPZEw8*dT2SIfIuEYxq8hjoXw!/r)

​	

​	此时左侧用户目录变为扩展商店，在搜索框内输入搜索并安装以下几个模块：

![image-20200818212317252](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEHQGE5NHzIy1dJ4pFqRyew*TbttesOuwP*IpQntpqF*ctT1WvT.keskwOKKG2zfUfDy.CHoh2J7gcE15CLFYfKI!/r)

​	

> Chinese (Simplified) Langeage Pack for Visual Studio Code

​	这是让用户界面变成中文的模块。

​	

> C/C++
>
> C/C++ Compile Run

​	以上两个扩展模块是vscode对C++语言的支持，以及让我们快捷运行程序的扩展模块。

​	

> Prettier - Code formatter

​	这个是可以让我们通过设置在写代码换行时或保存时进行自动调整代码格式的扩展模块。（不喜欢也可以不装）养成良好的代码习惯最重要

​	

> vscode-icons

​	这个模块是让系统使用vscode提供的图标，方便我们对不同文件类型进行区分。

​	

​	此时关闭vscode，重新打开vscode，会发现：

![image-20200818181951328](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEGLMmVUNYyPV.ilHTase5zGCOZFWsXOVDElGjfA200K7.MpWsy0JCNu4KM36bmxUSBnIRnZ5aQOEenAKHPI9QNM!/r)

​	

​	vscode整个界面变成中文，但之前编译器不认识的代码全都报错。不用担心，后面我们处理这个问题。

​	

#### 4.4.3 修改字体样式大小

​	按 Ctrl + ，或是在左下角设置里选择进入设置页面，根据个人喜好修改以下内容（以下为我修改的）：

​	`Editor：Font Size`（编程界面字体大小，根据个人习惯修改） 修改为20。

​	`Editor：Font Family`（编程界面字体样式，根据个人习惯修改）因这几个字体里有几个不是等宽字体，所以这里我只保留了Monospace字体。也可以根据个人喜好安装更改。后文会写出更换苹果字体的教程。

​	

#### 4.4.4 给予权限

​	下面我们回到命令行使用root权限把NS3整个目录的权限都改成可读可写可执行

```shell
$ su root
# cd /home/zcl
# chmod -R 777 ns-allinone-3.31
```

​	

#### 4.4.5 配置代码高亮及提醒

按键盘的`Ctrl`+`Shift`+`P`或在左下角设置里选择命令行面板，在打开的搜索框内输入

> ​	>C/C++ edit config

​	选择进入 ：`C/C++编辑配置（UI）`，进行下一步的修改

​	在配置页面下拉找到`包含路径`的选项，根据自己的home目录修改为以下内容：

> ${workspaceFolder}/build/ns3/**
>
> /home/zcl/ns-allinone-3.31/ns-3.31/build

​	以上代码的作用是让vscode检测到NS3的头文件，从而给我们提供代码提示、代码高亮等功能。此时回到刚才报错的first.cc文件

![image-20200818202200936](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEDDDC75Uup8SQkOlJuZZbSCU0b4vk78lhekWZFnNKk1rGIN0EJZpDN2eb0GFCJtnxCuMqCpVMHI*PF9unGTqC5Q!/r)

​	

​	此时报错消失。同时也有了代码提示功能

![image-20200818202305146](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEG6IO8nNtlW0OllmWXNgR73hOHCBIuChSuJmdRcPCFVfH.bvioY7aprIFZ7L78I9RFKO5mVCN3OR5Qfmq8wEiNE!/r)

​	

![image-20200818202328163](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrECjV*2O8OQplKgn1WRaca75YbROgCJy.UVqCA92ZmplyTozsRgWdgFI2YMMWTc4Q.eQFX20ws6gY5Oylqoz8DAI!/r)

​	

#### 4.4.6 自动格式化代码

​	下面我们按键盘的`Ctrl`+`Shift`+`P`或在左下角设置里选择命令行面板，在打开的搜索框内输入

> ​	>settings

​	选择进入`首选项：打开设置（json）`，进行对编译器的进一步设置。

​	修改为以下内容：

```json
{
    "editor.fontSize": 20,	//字体大小
    "editor.fontFamily": "'monospace'",	//字体样式
    "editor.tabSize": 4,	//一个Tab键的宽度，根据个人喜好更改
    "prettier.tabWidth": 4,	//代码美化工具的Tab键的宽度，根据个人喜好更改
    "editor.formatOnType": true,	//敲代码（换行时）对代码进行格式化，不喜欢可以不加
    "editor.formatOnSave": true		//保存时对代码进行格式化，不喜欢可以不加
}
```

​	

#### 4.4.7 基础编程环境测试

​	下面我们在左侧用户目录里右键，新建一个文件夹，在这个文件夹下新建一个文件进行测试

![image-20200818202530620](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEOjvMpJrR02HOU4NWP4ae*H9NB65PiAiv3OE8YryxoiZaiVcfJHUgfqWUtbxZAnDc78EYoiLo1izheblV*oHCtw!/r)

​	

​	敲入以下测试代码：

```C++
#include <iostream>

using namespace std;

int main()
{
    cout<<"HelloWorld in Ubuntu vscode by zcl"<<endl; //敲下最后的分号时，系统自动整理代码格式
    return 0;
}
```

​	

​	保存后按`F6`键进行编译运行，结果如下图所示：

![image-20200818203303949](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEFKjwRKZX*ruBiOx2t42b.F1r*eJresCkTir*RFyELkWqrXDhnCkdsIMNG4bDo1O0Y*njChb*0ITZfu*pPOka7A!/r)

​	

​	测试案例成功运行！

​	

#### 4.4.8 自动格式化代码测试

​	下面我们测试保存时格式化的功能，把代码换成以下乱的状态：

```C++
#include<iostream>

using   namespace   std;


int main(){
cout<<"HelloWorld in Ubuntu vscode by zcl"<<endl;return 0;}
```

​	

​	按下 `Ctrl`+`S`保存，系统自动整理为上图的代码样式。

​	这对于没有代码习惯的人特别友好，方便大佬们看懂我们这种菜鸡写的代码。

​	

#### 	4.4.9 更换苹果编程字体

​	很多人喜欢苹果的编程字体，但我查阅了很多资料。Ubuntu下装字体比较麻烦，这里写一个经过我实际安装测试成功的过程。

​	首先获取root权限

```shell
$ su root
(password)
```

​	

​	创建字体文件夹

```shell
cd /home/zcl/下载
mkdir /usr/share/fonts/myfonts/
```

​		

​	下载字体并复制到我们创建的字体文件夹中

```shell
git clone https://github.com/ueaner/fonts
cd fonts
cp *.ttf /usr/share/fonts/myfonts/
```

​	

​	安装

```shell
cd /usr/share/fonts/myfonts/
mkfontscale
mkfontdir
fc-cache -f
```

​	

​	之后我们按照前文4.4.3步骤里修改编程字体，把编程界面字体样式修改为Mocano即可。以下为更换后效果

![image-20200819010621676](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrELkxk2bfTvO4tIn*KyDaYPDZgjbO8w5.ulBhK21gilv5MOuJbLNZ1hfqbpM71Dg0nRcwNer*miLRcqFeDdzKjX4!/r)

​	

## 5.总结

​	因写本文之前有Ubuntu18.04 + ns3.30.1的安装经验，这次Ubuntu20.04 + ns3.31的安装过程还算顺利。全过程大概耗时一天，装Ubuntu系统以及配置编译NS过程花费时间较多，以及其他零散的需要我们配置的地方也都要花费时间一点一点去找。我个人觉得能成功配置好系统环境的人就已经很厉害了，因为网上各种教程繁杂众多，各个系统对于NS3所需的依赖包也不太一样。下面总结一下安装过程中遇到的问题以及心得。

​	1.安装全过程需要一定的网络专业基础。由于我是学网络出身，以前学过用VMware安装并搭建过RedHat以及Windows Server 2008 的环境，以及学过Linux shell 编程，这些以前学过的东西在此次安装过程中依然有用。虚拟机的安装以及NS3环境的配置，需要一定的Linux系统基础，懂得最基本的指令，以及会用命令行。

​	2.由于安装NS3需要安装很多依赖包，但不同系统需要的依赖包有些名字不一样，会直接影响到NS3的安装配置成功与否。所以需要我们严格按照版本来进行安装，不能看着一个版本的教程去安装另一个版本。

​	3.编译NS3的过程中将会占用大量的内存，可能要我们分配给虚拟机4G以上的内存。这对于我们实体机的配置尤为看重。实体机内存只有8G的同学可能需要在编译前设置一下swap分区来减轻内存占用的压力保证编译成功。

​	4.尽量不要在Ubuntu自带的应用商店里安装软件。因为大部分的软件都是削减版，有的不支持我们在里面打中文。所以我们在安装软件时，尽量去我们要安装的软件的官网下载安装我们需要的软件。

​	5.虽然用Vim即可敲代码并运行NS3，但推荐还是采用vscode或eclipse来提高我们的代码体验。

​	

***

​	

# 二、初入NS3

​	下面正式开始NS3的学习，在学习之前，我们应了解到NS3是基于C++ 语言的。所以掌握基本的C++ 语言的知识就极为重要。由于我之前没学过C++，只学过普通的C语言以及Java，Python。所以就在网上找了C++ 的教程进行学习。这里导师推荐了美国人写的 C++ Premier Plus，但我在淘宝看了看那本书的厚度是能砸死人的那种厚度，不符合我们快速入门的要求。所以我去搜了一下C++ 的视频课，我看的是黑马的C++ 教程，并跟着敲了大多数案例。

> 黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难
>
> 链接：https://www.bilibili.com/video/BV1et411b73Z

​	B站真是个好地方~

​	经过学习后发现，C++ 比C语言多了面向对象的概念，很多内容都与Java相似，所以我的C++ 入门过程还算比较轻松。根据导师的简介，需要学到C++ 的类与模版的知识。类之前我在Java里接触过，感觉C++ 的东西跟Java的差别不大，所以之前学过Java也对C++ 的学习有很大帮助。

​	

## 1.NS3的一些文档

​	1.NS3官网：

> https://www.nsnam.org/

​	是我们学习NS3最最重要的参考资料。

​	

​	2.NS3的官方文档：

> https://www.nsnam.org/documentation/

​	也是极为重要的内容，其中包括以下几个部分：

* **Tutorial**：NS3的入门教程，我们首先就是根据这个入门教程学习NS3从安装到代码由简到难的知识。

* **Manual**：NS3的手册，其中包含NS3的整体架构说明，核心模块的技术等。

* **Model Library**：基于NS3的文档、独立的协议以及各个功能模块的具体细节。

* **Release Errata**：NS3系统的勘误，前文ns3.30.1出现的bug就是参考这里解决的。

* **API Documentation**：使用Doxygen文档化的NS3的文档，里面包含所有的模块、类、成员的源代码，我们在里面可以查到具体模块、具体类、具体头文件的代码。经常看源代码对于我们理解NS3有很大帮助。

​	

## 2.准备工作

​	NS3是一个离散时间网络模拟器。用通俗的话说，NS3的模拟过程是基于时钟的事件列表仿真。我们规划好一段时间，在这个时间段内设置一个事件，NS3会按照我们的设置从头到尾跑一遍这个时间段，并根据时间段上设置好的事件做出相应的模拟。时间段结束，也就意味着模拟结束。

​	我们需要那种避免想干啥就干啥的想法，从底层模型及从代码出发捋顺NS3的编程思想。把自己想象成编译器，根据各个模块的安装顺序来编写代码，从而在编程时少出bug。

​	

## 3.官方示例的学习

### 3.1 NS3术语解释

​	在实际学习NS3的代码之前，我们首先要了解一些核心概念。这些概念在以后的编程中几乎每次都要用，所以我们很有必要先了解一下以确保我们有牢固的基础。我们要了解的是一些在网络概念里常用但在NS3里具有特殊意义的术语。

​	

#### 3.1.1 节点

​	在NS3中，我们可以把节点看做一个内部硬件几乎为空的计算机，我们需要为这个空机配置例如网卡、应用程序、网络协议栈等软硬件，从而驱动这台计算机做我们想要做的事。

​	

#### 3.1.2 应用程序

​	在NS3中，我们配置的节点（计算机）中没有操作系统的概念，有的只是应用的概念。应用要有一些我们设计的活动并被配置在计算机上运行，从而在整个NS3程序中驱动事件的模拟。开发者基于应用专门开发了一些新的应用程序，例如我们在教程中经常看到的`UdpEchoClientApplication`以及`UdpEchoServerApplication`，这两个应用程序组成了一个小型的B/S架构，用于生成和回显数据包。

​	

#### 3.1.3 信道

​	我们可以把信道想象成我们平时用的网线，计算机之间需要通过网线在进行数据的传输。这里常用的信道根据连接类型分为`CsmaChannel`、`PointToPointChannel`以及`WifiChannel`。`CsmaChannel`就类似于局域网连接，采用csma信道连接的所有节点都是互相连接的状态。`PointToPointChannel`顾名思义就是两个计算机之间点对点的连接。`WifiChannel`类似于我们平时上网的wifi，我们都可以对这些信道上配置这些信道的属性，从而将我们定义的空机安装在信道上。

​	

#### 3.1.4 网络设备

​	我们可以把网络设备想象成计算机的网卡，空计算机只连接了网线但没有网卡还是无法正常通信。在NS3中，网络设备是为网卡以及驱动的抽象。我们在节点上安装网络设备，使得节点可以通过信道与其他节点进行通信。正如现实中我们的笔记本可以有多张网卡，通过有线连接以及无线连接与其他设备或是互联网连接，NS3里的节点可以通过多个网络设备连接多个信道与其他节点通信。如上面的信道一样，网络设备也根据连接类型分为`CsmaNetDevice`、`PointToPointNetDevice`及`WifiNetDevice`。他们被设计为分别与之对应类型的信道一起工作。

​	

#### 3.1.5 拓扑助手

​	在NS3中，我们需要把网络设备安装到节点上，把网络设备连接到信道上，给网络设备分配IP地址等等，在NS3中有很多类似于这些的工作。NS3为我们提供了拓扑助手以使得这些工作变得简单。例如，创建一个网络设备，为它添加MAC地址，把这个网络设备安装在节点上，为这个节点配置网络协议栈，最后把网络设备连接到信道上，这些步骤可能需要很多不同的NS3的核心操作。不仅如此，把多个网络设备连接到多个信道上，并把这些独立的网络连接到互联网上将会需要更多的操作。为了我们的方便，NS3提供了拓扑助手类将这些不同的操作组合到一个易于我们使用的模型中。

​	

### 3.2 first.cc

#### 3.2.1 代码学习

​	打开ns3.31目录下的`examples/tutorial`，把例子拷到`scratch`文件夹下。因为 waf 要进入这个文件夹来进行编译运行，故我们需要把要运行的文件放入这个文件夹，这里为了图省事，一次性把七个例子全部复制过去。

```shell
$ cd /home/zcl/ns-allinone-3.31/ns-3.31/
$ cp examples/tutorial/*.cc scratch
```

​	然后在vscode里打开`first.cc`，代码如下

```C++
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"

// Default Network Topology
//
//       10.1.1.0
// n0 -------------- n1
//    point-to-point
//
 
using namespace ns3;

NS_LOG_COMPONENT_DEFINE ("FirstScriptExample");

int
main (int argc, char *argv[])
{
  CommandLine cmd (__FILE__);
  cmd.Parse (argc, argv);
  
  Time::SetResolution (Time::NS);
  LogComponentEnable ("UdpEchoClientApplication", LOG_LEVEL_INFO);
  LogComponentEnable ("UdpEchoServerApplication", LOG_LEVEL_INFO);

  NodeContainer nodes;
  nodes.Create (2);

  PointToPointHelper pointToPoint;
  pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
  pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));

  NetDeviceContainer devices;
  devices = pointToPoint.Install (nodes);

  InternetStackHelper stack;
  stack.Install (nodes);

  Ipv4AddressHelper address;
  address.SetBase ("10.1.1.0", "255.255.255.0");

  Ipv4InterfaceContainer interfaces = address.Assign (devices);

  UdpEchoServerHelper echoServer (9);

  ApplicationContainer serverApps = echoServer.Install (nodes.Get (1));
  serverApps.Start (Seconds (1.0));
  serverApps.Stop (Seconds (10.0));

  UdpEchoClientHelper echoClient (interfaces.GetAddress (1), 9);
  echoClient.SetAttribute ("MaxPackets", UintegerValue (1));
  echoClient.SetAttribute ("Interval", TimeValue (Seconds (1.0)));
  echoClient.SetAttribute ("PacketSize", UintegerValue (1024));

  ApplicationContainer clientApps = echoClient.Install (nodes.Get (0));
  clientApps.Start (Seconds (2.0));
  clientApps.Stop (Seconds (10.0));

  Simulator::Run ();
  Simulator::Destroy ();
  return 0;
}

```

​	

​	下面进行详细学习。

​	

* 1-15行代码：

```C++
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
```

​	是一些文件说明，包含文件类型，版权信息等。

​	

* 17-21行代码：

```C++
#include "ns3/core-module.h" //Core模块定义了NS3的核心功能（如模拟事件、事件调度）
#include "ns3/network-module.h" //network模块定义了NS3的基本网络组件（如网络结点、分组和地址）
#include "ns3/internet-module.h"//internet模块定义了NS3的TCP/IP协议栈
#include "ns3/point-to-point-module.h"//点对点模块
#include "ns3/applications-module.h"//Application模块定义了应用层分组收发模型（如贪婪模型、ON/OFF模型）
```

​	包含了我们在这个项目中所使用到的头文件。NS3的全部头文件位于`ns-allinone-3.31/ns-3.31/build/ns3`文件夹下，因我们在编译时的文件夹是`ns-allinone-3.31/ns-3.31/build`，所以我们在包含头文件时要加上头文件的目录，也就是`ns3`这个文件夹。

​	

* 23-28行代码：

```C++
// Default Network Topology
//
//       10.1.1.0
// n0 -------------- n1
//    point-to-point
//
```

​	大体描述了整个模拟网络的拓扑，后期我们在自己编写程序的时候也要养成这种画拓扑的习惯，以方便别人看懂我们的程序及代码。

​	

* 30行代码：

```C++
using namespace ns3;
```

​	指定命名空间为ns3，这样我们在敲NS3代码的时候不需要加作用域符号 `ns3::` ，但如果我们在NS3的代码里要使用常见的`cout`命令输出某个变量的值，则需要加作用域`std::cout`。

​	

* 32行代码：

```C++
NS_LOG_COMPONENT_DEFINE("FirstScriptExample");
```

​	此行声明了一个名为`FirstScriptExample`的日志记录组件，该组件允许我们通过引用名称来启用和禁用控制台消息日志记录。可以通过后面的`LogComponentEnable`函数或通过命令行改变环境变量来启动或禁用对应的日志组件。

​	

* 34-36行代码：

```C++
int 
main(int argc, char *argv[])
  {
```

​	是主函数，就跟普通的C++程序一样，每个程序都要有一个主函数。

​	

* 37-38行代码：

```C++
CommandLine cmd(__FILE__);
cmd.Parse(argc, argv);
```

​	声明了一个命令行解析器，并读取了命令行参数。我们可以在命令行解析器里设置参数，在执行程序时通过指定具体参数的值达到灵活编程的特点。

​	但我在这里发现不一样的点，ns3.31这里是一个有参构造，但ns3.30.1是无参构造。为了一探究竟，鼠标指到`CommandLine`上，右键选择`转到定义`，追一下这个类的定义：

```C++
//command-line.h
class CommandLine
{
public:
  /** Constructor */
  CommandLine (void);
  /**
   * Construct and register the source file name.
   * This would typically be called by 
   *     CommandLine cmd (__FILE__);
   *
   * This form is required to generate Doxygen documentation of the
   * arguments and options.
   *
   * \param [in] filename The source file name.
   */
  CommandLine (const std::string filename);
  /**
   * Copy constructor
   *
   * \param [in] cmd The CommandLine to copy from
   */
  CommandLine (const CommandLine &cmd);
  /**
   * Assignment
   *
   * \param [in] cmd The CommandLine to assign from
   * \return The CommandLine
   */
  CommandLine &operator = (const CommandLine &cmd);
  /** Destructor */
  ~CommandLine ();
```

​	

​	在看一下ns3.30.1版本的定义：

```C++
class CommandLine
{
public:
  /** Constructor */
  CommandLine ();
  /**
   * Copy constructor
   *
   * \param [in] cmd The CommandLine to copy from
   */
  CommandLine (const CommandLine &cmd);
  /**
   * Assignment
   *
   * \param [in] cmd The CommandLine to assign from
   * \return The CommandLine
   */
  CommandLine &operator = (const CommandLine &cmd);
  /** Destructor */
  ~CommandLine ();
```

​	ns3.31走的是有参构造，用来创建并注册一个源文件名。这种有参构造的形式被用来生成参数以及选项的Doxygen文档。

​	ns3.30.1走的是无参构造。再追一下ns3.31关于这几个函数的定义：

```C++
//command-line.cc
CommandLine::CommandLine ()
  : m_NNonOptions (0),
    m_nonOptionCount (0),
    m_usage (),
    m_shortName ()
{
  NS_LOG_FUNCTION (this);
}
CommandLine::CommandLine (const std::string filename)
  : m_NNonOptions (0),
    m_nonOptionCount (0),
    m_usage ()
{
  NS_LOG_FUNCTION (this << filename);
  std::string basename = SystemPath::Split (filename).back ();
  m_shortName = basename.substr (0, basename.rfind (".cc"));
}
  
CommandLine::CommandLine (const CommandLine &cmd)
{
  Copy (cmd);
}
CommandLine &
CommandLine::operator = (const CommandLine &cmd)
{
  Clear ();
  Copy (cmd);
  return *this;
}
CommandLine::~CommandLine ()
{
  NS_LOG_FUNCTION (this);
  Clear ();
}
```

​	可以看到，二者的差别是有参构造的`m_shortName`不一样，这个参数的作用就是让我们不加文件名.cc运行文件。无参构造是默认的shortname，有参构造这里还没看懂。

​	尝试修改36行代码为

```C++
CommandLine cmd(abc);
```

​	编译运行，程序正常运行。（估计此处有还未知的地方，目前不知道有什么区别）

​	

​	尝试修改36行代码为ns3.30.1的无参构造

```C++
CommandLine cmd
```

​	编译运行，程序正常运行。（大概也是为了兼容低版本的代码）

​	

* 40行代码：

```c++
Time::SetResolution (Time::NS);
```

​	设置系统的最小模拟时间单位为纳秒。

​	

* 41-42行代码：

```C++
LogComponentEnable ("UdpEchoClientApplication", LOG_LEVEL_INFO);
LogComponentEnable ("UdpEchoServerApplication", LOG_LEVEL_INFO);
```

​	设置了日志组件的信息，可以通过修改这里的等级以获取不同详细程度的输出。

​	

* 44-45行代码：

```C++
NodeContainer nodes;
nodes.Create (2);
```

​	追一下`NodeContainer`类的定义：

```C++
//node-container.h
//为了看着方便，对代码顺序进行了微调
/**
 * \brief keep track of a set of node pointers.
 *
 * Typically ns-3 helpers operate on more than one node at a time.  For example
 * a device helper may want to install devices on a large number of similar
 * nodes.  The helper Install methods usually take a NodeContainer as a
 * parameter.  NodeContainers hold the multiple Ptr<Node> which are used
 * to refer to the nodes.
 */

class NodeContainer
{
private:
  std::vector<Ptr<Node> > m_nodes; //!< Nodes smart pointers

public:
  /// Node container iterator
  typedef std::vector<Ptr<Node> >::const_iterator Iterator;
   /**
   * Create an empty NodeContainer.
   */
  NodeContainer ();
  ……
   /**
  * \brief Create n nodes and append pointers to them to the end of this 
  * NodeContainer.
  *
  * Nodes are at the heart of any ns-3 simulation.  One of the first tasks that
  * any simulation needs to do is to create a number of nodes.  This method
  * automates that task.
  *
  * \param n The number of Nodes to create
  */
  void Create (uint32_t n);
  ……
};
```

​	再追一下`void Create()`这个函数的定义：

```C++
//node-container.cc
void NodeContainer::Create (uint32_t n)
{
  for (uint32_t i = 0; i < n; i++)
    {
      m_nodes.push_back (CreateObject<Node> ());
    }
}
```

​	可以发现，`NodeContainer`类实际上由C++的Vector容器定义，存放着多个`Ptr<Node>`类型的指向具体节点的指针。通常，ns-3助手一次操作多个节点。例如设备助手可能想要在大量类似的节点上安装设备。助手的`Install`方法通常以`NodeContainer`作为参数。

​	案例中的这几行代码声明了一个`NodeContainer`类的节点容器，通过`Create`函数借助Vector容器的尾插法将创建的节点插入到容器中。

​	

* 47-49行代码

```C++
PointToPointHelper pointToPoint;
pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));
```

​	按照惯例，追一下`PointToPointHelper`类的定义：

```C++
//point-to-point-helper.h
/**
 * \brief Build a set of PointToPointNetDevice objects
 *
 * Normally we eschew multiple inheritance, however, the classes 
 * PcapUserHelperForDevice and AsciiTraceUserHelperForDevice are
 * "mixins".
 */
class PointToPointHelper : public PcapHelperForDevice,
	                   public AsciiTraceHelperForDevice
{
public:
  /**
   * Create a PointToPointHelper to make life easier when creating point to
   * point networks.
   */
  PointToPointHelper ();
  virtual ~PointToPointHelper () {}
  ……
  /**
   * Set an attribute value to be propagated to each NetDevice created by the
   * helper.
   *
   * \param name the name of the attribute to set
   * \param value the value of the attribute to set
   *
   * Set these attributes on each ns3::PointToPointNetDevice created
   * by PointToPointHelper::Install
   */
  void SetDeviceAttribute (std::string name, const AttributeValue &value);

  /**
   * Set an attribute value to be propagated to each Channel created by the
   * helper.
   *
   * \param name the name of the attribute to set
   * \param value the value of the attribute to set
   *
   * Set these attribute on each ns3::PointToPointChannel created
   * by PointToPointHelper::Install
   */
  void SetChannelAttribute (std::string name, const AttributeValue &value);
  ……
  ObjectFactory m_queueFactory;         //!< Queue Factory
  ObjectFactory m_channelFactory;       //!< Channel Factory
  ObjectFactory m_deviceFactory;        //!< Device Factory
  ……
};
```

​	再追一下`PointToPointHelper::SetDeviceAttribute()`以及`PointToPointHelper::SetChannelAttribute()`这两个函数的定义：

```C++
//point-to-point-helper.cc
void 
PointToPointHelper::SetDeviceAttribute (std::string n1, const AttributeValue &v1)
{
  m_deviceFactory.Set (n1, v1);
}

void 
PointToPointHelper::SetChannelAttribute (std::string n1, const AttributeValue &v1)
{
  m_channelFactory.Set (n1, v1);
}
```

​	再深入，无果。`PointToPointHelper`类用来生成一组`PointToPointNetDevice`对象，通常在使用该类的时候我们会避免多重继承，但是，`PcapUserHelperForDevice`和`AsciiTraceUserHelperForDevice`是特例。

​	案例中的这几行代码声明了一个`PointToPointHelper`类的点对点连接信道，并通过调用`SetDeviceAttribute`以及`SetChannelAttribute`由“工厂”设置了信道的传输速率为5Mbps，信道延迟为2ms。

​	

* 51-52行代码：

```C++
NetDeviceContainer devices;
devices = pointToPoint.Install (nodes);
```

​	按照惯例，追一下`NetDeviceContainer`类的定义：

```C++
//net-device-container.h
//为了看着方便，对代码顺序进行了微调
/**
 * \brief holds a vector of ns3::NetDevice pointers
 *
 * Typically ns-3 NetDevices are installed on nodes using a net device
 * helper.  The helper Install method takes a NodeContainer which holds 
 * some number of Ptr<Node>.  For each of the Nodes in the NodeContainer
 * the helper will instantiate a net device, add a MAC address and a queue
 * to the device and install it to the node.  For each of the devices, the
 * helper also adds the device into a Container for later use by the caller.
 * This is that container used to hold the Ptr<NetDevice> which are 
 * instantiated by the device helper.
 */
class NetDeviceContainer
{
private:
  std::vector<Ptr<NetDevice> > m_devices;
public:
  ……
  /// NetDevice container iterator
  typedef std::vector<Ptr<NetDevice> >::const_iterator Iterator;
  /**
   * Create an empty NetDeviceContainer.
   */
  NetDeviceContainer ();
  ……
};
```

​	再追一下`PointToPointHelper::Install()`这个函数的定义：

```C++
//point-to-point-helper.cc
NetDeviceContainer 
PointToPointHelper::Install (NodeContainer c)
{
  NS_ASSERT (c.GetN () == 2);
  return Install (c.Get (0), c.Get (1));
}
NetDeviceContainer 
PointToPointHelper::Install (Ptr<Node> a, Ptr<Node> b)
{
  NetDeviceContainer container;

  Ptr<PointToPointNetDevice> devA = m_deviceFactory.Create<PointToPointNetDevice> ();
  devA->SetAddress (Mac48Address::Allocate ());
  a->AddDevice (devA);
  Ptr<Queue<Packet> > queueA = m_queueFactory.Create<Queue<Packet> > ();
  devA->SetQueue (queueA);
  Ptr<PointToPointNetDevice> devB = m_deviceFactory.Create<PointToPointNetDevice> ();
  devB->SetAddress (Mac48Address::Allocate ());
  b->AddDevice (devB);
  Ptr<Queue<Packet> > queueB = m_queueFactory.Create<Queue<Packet> > ();
  devB->SetQueue (queueB);
  // Aggregate NetDeviceQueueInterface objects
  Ptr<NetDeviceQueueInterface> ndqiA = CreateObject<NetDeviceQueueInterface> ();
  ndqiA->GetTxQueue (0)->ConnectQueueTraces (queueA);
  devA->AggregateObject (ndqiA);
  Ptr<NetDeviceQueueInterface> ndqiB = CreateObject<NetDeviceQueueInterface> ();
  ndqiB->GetTxQueue (0)->ConnectQueueTraces (queueB);
  devB->AggregateObject (ndqiB);

  Ptr<PointToPointChannel> channel = 0;

  // If MPI is enabled, we need to see if both nodes have the same system id 
  // (rank), and the rank is the same as this instance.  If both are true, 
  // use a normal p2p channel, otherwise use a remote channel
#ifdef NS3_MPI
  bool useNormalChannel = true;
  if (MpiInterface::IsEnabled ())
    {
      uint32_t n1SystemId = a->GetSystemId ();
      uint32_t n2SystemId = b->GetSystemId ();
      uint32_t currSystemId = MpiInterface::GetSystemId ();
      if (n1SystemId != currSystemId || n2SystemId != currSystemId) 
        {
          useNormalChannel = false;
        }
    }
  if (useNormalChannel)
    {
      channel = m_channelFactory.Create<PointToPointChannel> ();
    }
  else
    {
      channel = m_remoteChannelFactory.Create<PointToPointRemoteChannel> ();
      Ptr<MpiReceiver> mpiRecA = CreateObject<MpiReceiver> ();
      Ptr<MpiReceiver> mpiRecB = CreateObject<MpiReceiver> ();
      mpiRecA->SetReceiveCallback (MakeCallback (&PointToPointNetDevice::Receive, devA));
      mpiRecB->SetReceiveCallback (MakeCallback (&PointToPointNetDevice::Receive, devB));
      devA->AggregateObject (mpiRecA);
      devB->AggregateObject (mpiRecB);
    }
#else
  channel = m_channelFactory.Create<PointToPointChannel> ();
#endif

  devA->Attach (channel);
  devB->Attach (channel);
  container.Add (devA);
  container.Add (devB);

  return container;
}
```

​	可以看到，`NetDeviceContainer`是存放着`ns3::NetDevice`网络设备的`Ptr<NetDevice>`类型的指针的容器，这个容器包含了为`NodeContainer`中所有结点所分配的NetDevice对象，并由设备助手实例化。通常我们使用助手将NS3网络设备安装在节点上。助手的`Install()`函数通常以包含着一定数量的`Ptr<Node>`类型的指向具体节点的指针的`NodeContainer`作为参数。对于`NodeContainer`中的每个节点，助手都会实例化一个网络设备，为设备添加MAC地址以及一个队列，然后将这个设备安装在节点上。对于每个设备，助手还将把设备添加到容器中以供调用者以后使用。

​	这两行代码第一行定义了一个`NetDeviceContainer`类型的devices变量，第二行代码的`Install()`方法将之前我们定义的`NodeContainer`类的nodes作为参数，此时调用形参为NodeContainer的Install函数，函数内部创建了两个节点，再以这两个节点为参数再调用形参为两个节点的Install函数。函数内部临时创建一个NodeContainer及两个PPP网络设备对象（PointToPointNetDevice）和一个PPP信道对象（PointToPointChannel），先将两个网络设备连接到一个信道对象上，又将两个网络设备安装在之前临时创建的包含着形参两个节点的NodeContainer上，最后返回连接好两个节点的`NetDeviceContainer`对象。由我们第一行定义的devices变量进行接收。

​	

* 54-55行代码：

```C++
InternetStackHelper stack;
stack.Install (nodes);
```

​	追一下`InternetStackHelper`类的定义：

```C++
//internet-stack-helper.h
……
/**
 * \ingroup internet
 *
 * \brief aggregate IP/TCP/UDP functionality to existing Nodes.
 *
 * This helper enables pcap and ascii tracing of events in the internet stack
 * associated with a node.  This is substantially similar to the tracing
 * that happens in device helpers, but the important difference is that, well,
 * there is no device.  This means that the creation of output file names will
 * change, and also the user-visible methods will not reference devices and
 * therefore the number of trace enable methods is reduced.
 *
 * Normally we avoid multiple inheritance in ns-3, however, the classes 
 * PcapUserHelperForIpv4 and AsciiTraceUserHelperForIpv4 are
 * treated as "mixins".  A mixin is a self-contained class that
 * encapsulates a general attribute or a set of functionality that
 * may be of interest to many other classes.
 *
 * This class aggregates instances of these objects, by default, to each node:
 *  - ns3::ArpL3Protocol
 *  - ns3::Ipv4L3Protocol
 *  - ns3::Icmpv4L4Protocol
 *  - ns3::Ipv6L3Protocol
 *  - ns3::Icmpv6L4Protocol
 *  - ns3::UdpL4Protocol
 *  - ns3::TrafficControlLayer
 *  - a TCP based on the TCP factory provided
 *  - a PacketSocketFactory
 *  - Ipv4 routing (a list routing object, a global routing object, and a static routing object)
 *  - Ipv6 routing (a static routing object)
 */
class InternetStackHelper : public PcapHelperForIpv4, public PcapHelperForIpv6, 
                            public AsciiTraceHelperForIpv4, public AsciiTraceHelperForIpv6
{
public:
  /**
   * Create a new InternetStackHelper which uses a mix of static routing
   * and global routing by default. The static routing protocol 
   * (ns3::Ipv4StaticRouting) and the global routing protocol are
   * stored in an ns3::Ipv4ListRouting protocol with priorities 0, and -10
   * by default. If you wish to use different priorites and different
   * routing protocols, you need to use an adhoc ns3::Ipv4RoutingHelper, 
   * such as ns3::OlsrHelper
   */
  InternetStackHelper(void);
  ……
    /**
   * For each node in the input container, aggregate implementations of the 
   * ns3::Ipv4, ns3::Ipv6, ns3::Udp, and, ns3::Tcp classes.  The program will assert 
   * if this method is called on a container with a node that already has
   * an Ipv4 object aggregated to it.
   * 
   * \param c NodeContainer that holds the set of nodes on which to install the
   * new stacks.
   */
  void Install (NodeContainer c) const;
  ……
};
```

​	再追一下`InternetStackHelper::Install()`这个函数的定义：

```C++
//internet-stack-helper.cc
……
void 
InternetStackHelper::Install (NodeContainer c) const
{
  for (NodeContainer::Iterator i = c.Begin (); i != c.End (); ++i)
    {
      Install (*i);
    }
}

void 
InternetStackHelper::InstallAll (void) const
{
  Install (NodeContainer::GetGlobal ());
}

void
InternetStackHelper::CreateAndAggregateObjectFromTypeId (Ptr<Node> node, const std::string typeId)
{
  ObjectFactory factory;
  factory.SetTypeId (typeId);
  Ptr<Object> protocol = factory.Create <Object> ();
  node->AggregateObject (protocol);
}

void
InternetStackHelper::Install (Ptr<Node> node) const
{
  if (m_ipv4Enabled)
    {
      if (node->GetObject<Ipv4> () != 0)
        {
          NS_FATAL_ERROR ("InternetStackHelper::Install (): Aggregating " 
                          "an InternetStack to a node with an existing Ipv4 object");
          return;
        }

      CreateAndAggregateObjectFromTypeId (node, "ns3::ArpL3Protocol");
      CreateAndAggregateObjectFromTypeId (node, "ns3::Ipv4L3Protocol");
      CreateAndAggregateObjectFromTypeId (node, "ns3::Icmpv4L4Protocol");
      if (m_ipv4ArpJitterEnabled == false)
        {
          Ptr<ArpL3Protocol> arp = node->GetObject<ArpL3Protocol> ();
          NS_ASSERT (arp);
          arp->SetAttribute ("RequestJitter", StringValue ("ns3::ConstantRandomVariable[Constant=0.0]"));
        }
      // Set routing
      Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
      Ptr<Ipv4RoutingProtocol> ipv4Routing = m_routing->Create (node);
      ipv4->SetRoutingProtocol (ipv4Routing);
    }

  if (m_ipv6Enabled)
    {
      /* IPv6 stack */
      if (node->GetObject<Ipv6> () != 0)
        {
          NS_FATAL_ERROR ("InternetStackHelper::Install (): Aggregating " 
                          "an InternetStack to a node with an existing Ipv6 object");
          return;
        }

      CreateAndAggregateObjectFromTypeId (node, "ns3::Ipv6L3Protocol");
      CreateAndAggregateObjectFromTypeId (node, "ns3::Icmpv6L4Protocol");
      if (m_ipv6NsRsJitterEnabled == false)
        {
          Ptr<Icmpv6L4Protocol> icmpv6l4 = node->GetObject<Icmpv6L4Protocol> ();
          NS_ASSERT (icmpv6l4);
          icmpv6l4->SetAttribute ("SolicitationJitter", StringValue ("ns3::ConstantRandomVariable[Constant=0.0]"));
        }
      // Set routing
      Ptr<Ipv6> ipv6 = node->GetObject<Ipv6> ();
      Ptr<Ipv6RoutingProtocol> ipv6Routing = m_routingv6->Create (node);
      ipv6->SetRoutingProtocol (ipv6Routing);

      /* register IPv6 extensions and options */
      ipv6->RegisterExtensions ();
      ipv6->RegisterOptions ();
    }

  if (m_ipv4Enabled || m_ipv6Enabled)
    {
      CreateAndAggregateObjectFromTypeId (node, "ns3::TrafficControlLayer");
      CreateAndAggregateObjectFromTypeId (node, "ns3::UdpL4Protocol");
      node->AggregateObject (m_tcpFactory.Create<Object> ());
      Ptr<PacketSocketFactory> factory = CreateObject<PacketSocketFactory> ();
      node->AggregateObject (factory);
    }

  if (m_ipv4Enabled)
    {
      Ptr<ArpL3Protocol> arp = node->GetObject<ArpL3Protocol> ();
      Ptr<TrafficControlLayer> tc = node->GetObject<TrafficControlLayer> ();
      NS_ASSERT (arp);
      NS_ASSERT (tc);
      arp->SetTrafficControl (tc);
    }
}

```

​	可以看出，`InternetStackHelper`类继承自多个类，它混合使用静态路由和全局路由。这两个路由存储在`ns3::Ipv4ListRouting`协议中，优先级分别是0跟-10。`InternetStackHelper`是一个对于网络协议栈来说就像点对点助手对点对点网络设备那样的拓扑助手。这个类的作用是将IP/TCP/UDP网络协议栈安装在节点容器的每一个节点上。

​	这两行代码里，第一行定义了一个`InternetStackHelper`类的stack的变量，第二行调用了`Install()`方法，将前面定义的节点容器传入，因为节点容器实际上是一个Vector容器，采用了for循环使用迭代器循环为容器每一个节点安装网络协议栈。

​	

* 57-58行代码：

```C++
Ipv4AddressHelper address;
address.SetBase ("10.1.1.0", "255.255.255.0");
```

​	追`Ipv4AddressHelper`类的定义：

```C++
//ipv4-address-helper.h
//对代码顺序进行了微调
/**
 * \ingroup ipv4Helpers
 *
 * @brief A helper class to make life easier while doing simple IPv4 address
 * assignment in scripts.
 *
 * This class is a very simple IPv4 address generator.  You can think of it
 * as a simple local number incrementer.  It has no notion that IP addresses
 * are part of a global address space.  If you have a complicated address 
 * assignment situation you may want to look at the Ipv4AddressGenerator which
 * does recognize that IP address and network number generation is part of a
 * global problem.  Ipv4AddressHelper is a simple class to make simple problems
 * easy to handle.
 *
 * We do call into the global address generator to make sure that there are
 * no duplicate addresses generated.
 *
 * @see Ipv4AddressGenerator
 */
class Ipv4AddressHelper
{
private:
  /**
   * \brief Returns the number of address bits (hostpart) for a given netmask
   * \param maskbits the netmask
   * \returns the number of bits in the hostpart
   */
  uint32_t NumAddressBits (uint32_t maskbits) const;

  uint32_t m_network; //!< network address
  uint32_t m_mask;    //!< network mask
  uint32_t m_address; //!< address
  uint32_t m_base;    //!< base address
  uint32_t m_shift;   //!< shift, equivalent to the number of bits in the hostpart
  uint32_t m_max;     //!< maximum allowed address

public:
/**
 * @brief Construct a helper class to make life easier while doing simple IPv4
 * address assignment in scripts.
 */
  Ipv4AddressHelper ();
  /**
 * @brief Set the base network number, network mask and base address.
 *
 * The address helper allocates IP addresses based on a given network number
 * and mask combination along with an initial IP address.
 *
 * For example, if you want to use a /24 prefix with an initial network number
 * of 192.168.1 (corresponding to a mask of 255.255.255.0) and you want to 
 * start allocating IP addresses out of that network beginning at 192.168.1.3,
 * you would call 
 *
 *   SetBase ("192.168.1.0", "255.255.255.0", "0.0.0.3");
 *
 * If you don't care about the initial address it defaults to "0.0.0.1" in 
 * which case you can simply use,
 *
 *   SetBase ("192.168.1.0", "255.255.255.0");
 *
 * and the first address generated will be 192.168.1.1.
 *
 * @param network The Ipv4Address containing the initial network number to
 * use during allocation.  The bits outside the network mask are not used.
 * @param mask The Ipv4Mask containing one bits in each bit position of the 
 * network number.
 * @param base An optional Ipv4Address containing the initial address used for 
 * IP address allocation.  Will be combined (ORed) with the network number to
 * generate the first IP address.  Defaults to 0.0.0.1.
 * @returns Nothing.
 */
  void SetBase (Ipv4Address network, Ipv4Mask mask, 
                Ipv4Address base = "0.0.0.1");
};
```

​	再追一下`Ipv4AddressHelper::SetBase()`这个函数：

```C++
//ipv4-address-helper.cc
void
Ipv4AddressHelper::SetBase (
  const Ipv4Address network, 
  const Ipv4Mask mask,
  const Ipv4Address address)
{
  NS_LOG_FUNCTION_NOARGS ();

  m_network = network.Get ();
  m_mask = mask.Get ();
  m_base = m_address = address.Get ();

//
// Some quick reasonableness testing.
//
  NS_ASSERT_MSG ((m_network & ~m_mask) == 0,
                 "Ipv4AddressHelper::SetBase(): Inconsistent network and mask");

//
// Figure out how much to shift network numbers to get them aligned, and what
// the maximum allowed address is with respect to the current mask.
//
  m_shift = NumAddressBits (m_mask);
  m_max = (1 << m_shift) - 2;

  NS_ASSERT_MSG (m_shift <= 32,
                 "Ipv4AddressHelper::SetBase(): Unreasonable address length");

//
// Shift the network down into the normalized position.
//
  m_network >>= m_shift;

  NS_LOG_LOGIC ("m_network == " << m_network);
  NS_LOG_LOGIC ("m_mask == " << m_mask);
  NS_LOG_LOGIC ("m_address == " << m_address);
}
```

​	可以看到，`Ipv4AddressHelper`是一个能执行简单的IPv4地址分配的脚本。如果我们空着第三个参数，它将默认从1开始单调递增的方式分配地址。通过修改第三个参数的值，我们可以指定它从某个地址开始分配。

​	程序里的这两行代码定义了一个ipv4地址助手，并设置其要分配的ip网段、子网掩码。其中的地址默认从1开始分配（第三个参数空着）。

​	

* 60行代码：

```C++
Ipv4InterfaceContainer interfaces = address.Assign (devices);
```

​	追`Ipv4InterfaceContainer`类的定义：

```C++
//ipv4-interface-container.h
//对代码顺序进行了微调
/**
 * \ingroup ipv4
 *
 * \brief holds a vector of std::pair of Ptr<Ipv4> and interface index.
 *
 * Typically ns-3 Ipv4Interfaces are installed on devices using an Ipv4 address
 * helper.  The helper's Assign() method takes a NetDeviceContainer which holds 
 * some number of Ptr<NetDevice>.  For each of the NetDevices in the 
 * NetDeviceContainer the helper will find the associated Ptr<Node> and
 * Ptr<Ipv4>.  It makes sure that an interface exists on the node for the 
 * device and then adds an Ipv4Address according to the address helper settings
 * (incrementing the Ipv4Address somehow as it goes).  The helper then converts
 * the Ptr<Ipv4> and the interface index to a std::pair and adds them to a 
 * container -- a container of this type.
 *
 * The point is then to be able to implicitly associate an index into the 
 * original NetDeviceContainer (that identifies a particular net device) with
 * an identical index into the Ipv4InterfaceContainer that has a std::pair with
 * the Ptr<Ipv4> and interface index you need to play with the interface.
 *
 * @see Ipv4AddressHelper
 * @see Ipv4
 */
class Ipv4InterfaceContainer
{
private:
  /**
   * \brief Container for pairs of Ipv4 smart pointer / Interface Index.
   */
  typedef std::vector<std::pair<Ptr<Ipv4>,uint32_t> > InterfaceVector;

  /**
   * \brief List of IPv4 stack and interfaces index.
   */
  InterfaceVector m_interfaces;
    
public:
  /**
   * \brief Container Const Iterator for pairs of Ipv4 smart pointer / Interface Index.
   */
  typedef std::vector<std::pair<Ptr<Ipv4>, uint32_t> >::const_iterator Iterator;

  /**
   * Create an empty Ipv4InterfaceContainer.
   */
  Ipv4InterfaceContainer ();

```

​	再追一下`Ipv4AddressHelper::Assign()`这个函数的定义：

```C++
//ipv4-address-helper.cc
Ipv4InterfaceContainer
Ipv4AddressHelper::Assign (const NetDeviceContainer &c)
{
  NS_LOG_FUNCTION_NOARGS ();
  Ipv4InterfaceContainer retval;
  for (uint32_t i = 0; i < c.GetN (); ++i) {
      Ptr<NetDevice> device = c.Get (i);

      Ptr<Node> node = device->GetNode ();
      NS_ASSERT_MSG (node, "Ipv4AddressHelper::Assign(): NetDevice is not not associated "
                     "with any node -> fail");

      Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
      NS_ASSERT_MSG (ipv4, "Ipv4AddressHelper::Assign(): NetDevice is associated"
                     " with a node without IPv4 stack installed -> fail "
                     "(maybe need to use InternetStackHelper?)");

      int32_t interface = ipv4->GetInterfaceForDevice (device);
      if (interface == -1)
        {
          interface = ipv4->AddInterface (device);
        }
      NS_ASSERT_MSG (interface >= 0, "Ipv4AddressHelper::Assign(): "
                     "Interface index not found");

      Ipv4InterfaceAddress ipv4Addr = Ipv4InterfaceAddress (NewAddress (), m_mask);
      ipv4->AddAddress (interface, ipv4Addr);
      ipv4->SetMetric (interface, 1);
      ipv4->SetUp (interface);
      retval.Add (ipv4, interface);

      // Install the default traffic control configuration if the traffic
      // control layer has been aggregated, if this is not 
      // a loopback interface, and there is no queue disc installed already
      Ptr<TrafficControlLayer> tc = node->GetObject<TrafficControlLayer> ();
      if (tc && DynamicCast<LoopbackNetDevice> (device) == 0 && tc->GetRootQueueDiscOnDevice (device) == 0)
        {
          Ptr<NetDeviceQueueInterface> ndqi = device->GetObject<NetDeviceQueueInterface> ();
          // It is useless to install a queue disc if the device has no
          // NetDeviceQueueInterface attached: the device queue is never
          // stopped and every packet enqueued in the queue disc is
          // immediately dequeued, hence there will never be backlog
          if (ndqi)
            {
              std::size_t nTxQueues = ndqi->GetNTxQueues ();
              NS_LOG_LOGIC ("Installing default traffic control configuration ("
                            << nTxQueues << " device queue(s))");
              TrafficControlHelper tcHelper = TrafficControlHelper::Default (nTxQueues);
              tcHelper.Install (device);
            }
        }
    }
  return retval;
}
```

​	可以看到，`Ipv4InterfaceContainer`类是基于Vector的pair键值对，存放着ipv4的指针以及接口索引，对于网络设备容器中的每一个网络设备，ipv4地址助手会找到对应的节点与ipv4地址。

​	程序中的这行代码，声明了一个`Ipv4InterfaceContainer`类型的变量interfaces，并调用`Ipv4AddressHelper`的Assign()方法来对地址进行分配，将前面定义的`NetDeviceContainer`类的变量device传入。Assign()方法内部定义了一个新的`Ipv4InterfaceContainer`变量retval，传入的device内有一些设备的指针，ipv4地址助手确保每个节点上的设备都有一个接口存在，然后根据SetBase的规则为设备分配ipv4地址。然后将分配好地址的接口索引与对应的ipv4地址以pair键值对的形式存入创建的retval，然后由前面定义的interfaces变量接收分配好的结果。关键是能够隐式地将原始网络设备容器中的索引与我们需要的具有ipv4地址指针与接口索引的ipv4接口容器的相同的索引结合在一起，然后存放在一个新的接口容器里。

​	由于两个节点上分别有一个网络设备，ipv4助手为他们分配了10.1.1.1以及10.1.1.2两个地址。

​	

​	下面进入应用层：

  

* 62-66行代码：

```C++
UdpEchoServerHelper echoServer (9);

ApplicationContainer serverApps = echoServer.Install (nodes.Get (1));
serverApps.Start (Seconds (1.0));
serverApps.Stop (Seconds (10.0));
```

​	追`ApplicationContainer`类：

```c++
//application-container.h
//对代码顺序进行了调整
/**
 * \brief holds a vector of ns3::Application pointers.
 *
 * Typically ns-3 Applications are installed on nodes using an Application
 * helper.  The helper Install method takes a NodeContainer which holds 
 * some number of Ptr<Node>.  For each of the Nodes in the NodeContainer
 * the helper will instantiate an application, install it in a node and
 * add a Ptr<Application> to that application into a Container for use
 * by the caller.  This is that container used to hold the Ptr<Application>
 * which are instantiated by the Application helper.
 */
class ApplicationContainer
{
private:
  std::vector<Ptr<Application> > m_applications; //!< Applications smart pointers

public:
  /**
   * Create an empty ApplicationContainer.
   */
  ApplicationContainer ();

  /**
   * Create an ApplicationContainer with exactly one application which has
   * been previously instantiated.  The single application is specified
   * by a smart pointer.
   *
   * \param application The Ptr<Application> to add to the container.
   */
  ApplicationContainer (Ptr<Application> application);

  /**
   * Create an ApplicationContainer with exactly one application which has
   * been previously instantiated and assigned a name using the Object Name
   * Service.  This Application is then specified by its assigned name. 
   *
   * \param name The name of the Application Object to add to the container.
   */
   ……
}
```

​	追`UdpEchoServerHelper`类：

```C++
//udp-echo-helper.h
/**
 * \ingroup udpecho
 * \brief Create a server application which waits for input UDP packets
 *        and sends them back to the original sender.
 */
class UdpEchoServerHelper
{
public:
  /**
   * Create UdpEchoServerHelper which will make life easier for people trying
   * to set up simulations with echos.
   *
   * \param port The port the server will wait on for incoming packets
   */
  UdpEchoServerHelper (uint16_t port);
  ……
};
```

​	追`UdpEchoServerHelper`函数：

```c++
//udp-echo-server.cc
UdpEchoServerHelper::UdpEchoServerHelper (uint16_t port)
{
  m_factory.SetTypeId (UdpEchoServer::GetTypeId ());
  SetAttribute ("Port", UintegerValue (port));
}

void 
UdpEchoServerHelper::SetAttribute (
  std::string name, 
  const AttributeValue &value)
{
  m_factory.Set (name, value);
}
```

​	追`UdpEchoServerHelper::Install()`函数：

```C++
//udp-echo-helper.cc
ApplicationContainer
UdpEchoServerHelper::Install (Ptr<Node> node) const
{
  return ApplicationContainer (InstallPriv (node));
}
```

​	再追`UdpEchoServerHelper::InstallPriv()`函数：

```C++
//udp-echo-helper.cc
Ptr<Application>
UdpEchoServerHelper::InstallPriv (Ptr<Node> node) const
{
  Ptr<Application> app = m_factory.Create<UdpEchoServer> ();
  node->AddApplication (app);

  return app;
}
```

​	追`UdpEchoServer`类，发现有`StartApplication()`与`StopApplication()`两个函数，故继续追`StartApplication()`这个函数：

```C++
//udp-echo-server.cc
void 
UdpEchoServer::StartApplication (void)
{
  NS_LOG_FUNCTION (this);

  if (m_socket == 0)
    {
      TypeId tid = TypeId::LookupByName ("ns3::UdpSocketFactory");
      m_socket = Socket::CreateSocket (GetNode (), tid);
      InetSocketAddress local = InetSocketAddress (Ipv4Address::GetAny (), m_port);
      if (m_socket->Bind (local) == -1)
        {
          NS_FATAL_ERROR ("Failed to bind socket");
        }
      if (addressUtils::IsMulticast (m_local))
        {
          Ptr<UdpSocket> udpSocket = DynamicCast<UdpSocket> (m_socket);
          if (udpSocket)
            {
              // equivalent to setsockopt (MCAST_JOIN_GROUP)
              udpSocket->MulticastJoinGroup (0, m_local);
            }
          else
            {
              NS_FATAL_ERROR ("Error: Failed to join multicast group");
            }
        }
    }

  if (m_socket6 == 0)
    {
      TypeId tid = TypeId::LookupByName ("ns3::UdpSocketFactory");
      m_socket6 = Socket::CreateSocket (GetNode (), tid);
      Inet6SocketAddress local6 = Inet6SocketAddress (Ipv6Address::GetAny (), m_port);
      if (m_socket6->Bind (local6) == -1)
        {
          NS_FATAL_ERROR ("Failed to bind socket");
        }
      if (addressUtils::IsMulticast (local6))
        {
          Ptr<UdpSocket> udpSocket = DynamicCast<UdpSocket> (m_socket6);
          if (udpSocket)
            {
              // equivalent to setsockopt (MCAST_JOIN_GROUP)
              udpSocket->MulticastJoinGroup (0, local6);
            }
          else
            {
              NS_FATAL_ERROR ("Error: Failed to join multicast group");
            }
        }
    }

  m_socket->SetRecvCallback (MakeCallback (&UdpEchoServer::HandleRead, this));
  m_socket6->SetRecvCallback (MakeCallback (&UdpEchoServer::HandleRead, this));
  
void 
UdpEchoServer::HandleRead (Ptr<Socket> socket)
{
  NS_LOG_FUNCTION (this << socket);

  Ptr<Packet> packet;
  Address from;
  Address localAddress;
  while ((packet = socket->RecvFrom (from)))
    {
      socket->GetSockName (localAddress);
      m_rxTrace (packet);
      m_rxTraceWithAddresses (packet, from, localAddress);
      if (InetSocketAddress::IsMatchingType (from))
        {
          NS_LOG_INFO ("At time " << Simulator::Now ().GetSeconds () << "s server received " << packet->GetSize () << " bytes from " <<
                       InetSocketAddress::ConvertFrom (from).GetIpv4 () << " port " <<
                       InetSocketAddress::ConvertFrom (from).GetPort ());
        }
      else if (Inet6SocketAddress::IsMatchingType (from))
        {
          NS_LOG_INFO ("At time " << Simulator::Now ().GetSeconds () << "s server received " << packet->GetSize () << " bytes from " <<
                       Inet6SocketAddress::ConvertFrom (from).GetIpv6 () << " port " <<
                       Inet6SocketAddress::ConvertFrom (from).GetPort ());
        }

      packet->RemoveAllPacketTags ();
      packet->RemoveAllByteTags ();

      NS_LOG_LOGIC ("Echoing packet");
      socket->SendTo (packet, 0, from);

      if (InetSocketAddress::IsMatchingType (from))
        {
          NS_LOG_INFO ("At time " << Simulator::Now ().GetSeconds () << "s server sent " << packet->GetSize () << " bytes to " <<
                       InetSocketAddress::ConvertFrom (from).GetIpv4 () << " port " <<
                       InetSocketAddress::ConvertFrom (from).GetPort ());
        }
      else if (Inet6SocketAddress::IsMatchingType (from))
        {
          NS_LOG_INFO ("At time " << Simulator::Now ().GetSeconds () << "s server sent " << packet->GetSize () << " bytes to " <<
                       Inet6SocketAddress::ConvertFrom (from).GetIpv6 () << " port " <<
                       Inet6SocketAddress::ConvertFrom (from).GetPort ());
        }
    }
}

```



​	发现调用了`bind()`、`UdpEchoServer::HandleRead()`中的`RecvFrom()`和`sendTo()`方法来监听、接收和发送UDP数据包。这些也是我们后期模拟在命令行看到的服务器提示消息的来源。

​	

​	继续追参数是`Ptr<Application>`的`ApplicationContainer()`函数：

```c++
//application-container.cc
ApplicationContainer::ApplicationContainer (Ptr<Application> app)
{
  m_applications.push_back (app);
}
```

​	发现`ApplicationContainer`类也是基于Vector容器，存放着应用程序的指针。

​	代码第一行首先定义了一个`UdpEchoServerHelper`助手，使用`SetAttribute()`方法指定了Udp回声服务器工作在9号端口上。第二行调用`UdpEchoServerHelper`类的`install()`方法并传入1号节点的地址，方法内为1号节点安装了Udp回声服务器，并定义了一个应用程序容器用于接收安装成功的回声服务器。

​	

​	追`ApplicationContainer::Start()`及`ApplicationContainer::Stop()`函数：

```C++
//application-container.cc
void 
ApplicationContainer::Start (Time start)
{
  for (Iterator i = Begin (); i != End (); ++i)
    {
      Ptr<Application> app = *i;
      app->SetStartTime (start);
    }
}

void 
ApplicationContainer::Stop (Time stop)
{
  for (Iterator i = Begin (); i != End (); ++i)
    {
      Ptr<Application> app = *i;
      app->SetStopTime (stop);
    }
}
```

​	这两个函数使用迭代器循环为应用程序容器内的每一个应用程序设置echoServer自模拟启动后1.0s开始监听并接收来自9号端口的数据，并于模拟启动后10.0s停止。

> 注意！必须设置停止时间，否则模拟启动后，销毁程序会因为事件未结束而不能结束整个程序。

​	

* 68-75行代码：

```C++
UdpEchoClientHelper echoClient (interfaces.GetAddress (1), 9);
echoClient.SetAttribute ("MaxPackets", UintegerValue (1));
echoClient.SetAttribute ("Interval", TimeValue (Seconds (1.0)));
echoClient.SetAttribute ("PacketSize", UintegerValue (1024));

ApplicationContainer clientApps = echoClient.Install (nodes.Get (0));
clientApps.Start (Seconds (2.0));
clientApps.Stop (Seconds (10.0));
```

​	追`UdpEchoClientHelper`类：

```C++
//udp-echo-helper.cc
class UdpEchoClientHelper
{
public:
  /**
   * Create UdpEchoClientHelper which will make life easier for people trying
   * to set up simulations with echos. Use this variant with addresses that do
   * not include a port value (e.g., Ipv4Address and Ipv6Address).
   *
   * \param ip The IP address of the remote udp echo server
   * \param port The port number of the remote udp echo server
   */
  UdpEchoClientHelper (Address ip, uint16_t port);
  ……
};
```

​	追`UdpEchoClientHelper()`函数：

```C++
//udp-rcho-helper.cc
UdpEchoClientHelper::UdpEchoClientHelper (Address address, uint16_t port)
{
  m_factory.SetTypeId (UdpEchoClient::GetTypeId ());
  SetAttribute ("RemoteAddress", AddressValue (address));
  SetAttribute ("RemotePort", UintegerValue (port));
}

void 
UdpEchoClientHelper::SetAttribute (
  std::string name, 
  const AttributeValue &value)
{
  m_factory.Set (name, value);
}
```

​	追`UdpEchoClientHelper::Install()`函数：

```C++
//udp-echo-helper.cc
ApplicationContainer
UdpEchoClientHelper::Install (Ptr<Node> node) const
{
  return ApplicationContainer (InstallPriv (node));
}
```

​	再追`UdpEchoClientHelper::InstallPriv()`函数：

```C++
//udp-echo-helper.cc
Ptr<Application>
UdpEchoClientHelper::InstallPriv (Ptr<Node> node) const
{
  Ptr<Application> app = m_factory.Create<UdpEchoClient> ();
  node->AddApplication (app);

  return app;
}
```

​	追`UdpEchoClient`类，发现跟Server类似，同样有`StartApplication()`跟`StopApplication()`两个函数，继续追`StartApplication()`：

```C++
//udp-echo-client.cc
void 
UdpEchoClient::StartApplication (void)
{
  NS_LOG_FUNCTION (this);

  if (m_socket == 0)
    {
      TypeId tid = TypeId::LookupByName ("ns3::UdpSocketFactory");
      m_socket = Socket::CreateSocket (GetNode (), tid);
      if (Ipv4Address::IsMatchingType(m_peerAddress) == true)
        {
          if (m_socket->Bind () == -1)
            {
              NS_FATAL_ERROR ("Failed to bind socket");
            }
          m_socket->Connect (InetSocketAddress (Ipv4Address::ConvertFrom(m_peerAddress), m_peerPort));
        }
      else if (Ipv6Address::IsMatchingType(m_peerAddress) == true)
        {
          if (m_socket->Bind6 () == -1)
            {
              NS_FATAL_ERROR ("Failed to bind socket");
            }
          m_socket->Connect (Inet6SocketAddress (Ipv6Address::ConvertFrom(m_peerAddress), m_peerPort));
        }
      else if (InetSocketAddress::IsMatchingType (m_peerAddress) == true)
        {
          if (m_socket->Bind () == -1)
            {
              NS_FATAL_ERROR ("Failed to bind socket");
            }
          m_socket->Connect (m_peerAddress);
        }
      else if (Inet6SocketAddress::IsMatchingType (m_peerAddress) == true)
        {
          if (m_socket->Bind6 () == -1)
            {
              NS_FATAL_ERROR ("Failed to bind socket");
            }
          m_socket->Connect (m_peerAddress);
        }
      else
        {
          NS_ASSERT_MSG (false, "Incompatible address type: " << m_peerAddress);
        }
    }

  m_socket->SetRecvCallback (MakeCallback (&UdpEchoClient::HandleRead, this));
  m_socket->SetAllowBroadcast (true);
  ScheduleTransmit (Seconds (0.));
}

void 
UdpEchoClient::ScheduleTransmit (Time dt)
{
  NS_LOG_FUNCTION (this << dt);
  m_sendEvent = Simulator::Schedule (dt, &UdpEchoClient::Send, this);
}

void 
UdpEchoClient::Send (void)
{
  NS_LOG_FUNCTION (this);

  NS_ASSERT (m_sendEvent.IsExpired ());

  Ptr<Packet> p;
  if (m_dataSize)
    {
      //
      // If m_dataSize is non-zero, we have a data buffer of the same size that we
      // are expected to copy and send.  This state of affairs is created if one of
      // the Fill functions is called.  In this case, m_size must have been set
      // to agree with m_dataSize
      //
      NS_ASSERT_MSG (m_dataSize == m_size, "UdpEchoClient::Send(): m_size and m_dataSize inconsistent");
      NS_ASSERT_MSG (m_data, "UdpEchoClient::Send(): m_dataSize but no m_data");
      p = Create<Packet> (m_data, m_dataSize);
    }
  else
    {
      //
      // If m_dataSize is zero, the client has indicated that it doesn't care
      // about the data itself either by specifying the data size by setting
      // the corresponding attribute or by not calling a SetFill function.  In
      // this case, we don't worry about it either.  But we do allow m_size
      // to have a value different from the (zero) m_dataSize.
      //
      p = Create<Packet> (m_size);
    }
  Address localAddress;
  m_socket->GetSockName (localAddress);
  // call to the trace sinks before the packet is actually sent,
  // so that tags added to the packet can be sent as well
  m_txTrace (p);
  if (Ipv4Address::IsMatchingType (m_peerAddress))
    {
      m_txTraceWithAddresses (p, localAddress, InetSocketAddress (Ipv4Address::ConvertFrom (m_peerAddress), m_peerPort));
    }
  else if (Ipv6Address::IsMatchingType (m_peerAddress))
    {
      m_txTraceWithAddresses (p, localAddress, Inet6SocketAddress (Ipv6Address::ConvertFrom (m_peerAddress), m_peerPort));
    }
  m_socket->Send (p);
  ++m_sent;

  if (Ipv4Address::IsMatchingType (m_peerAddress))
    {
      NS_LOG_INFO ("At time " << Simulator::Now ().GetSeconds () << "s client sent " << m_size << " bytes to " <<
                   Ipv4Address::ConvertFrom (m_peerAddress) << " port " << m_peerPort);
    }
  else if (Ipv6Address::IsMatchingType (m_peerAddress))
    {
      NS_LOG_INFO ("At time " << Simulator::Now ().GetSeconds () << "s client sent " << m_size << " bytes to " <<
                   Ipv6Address::ConvertFrom (m_peerAddress) << " port " << m_peerPort);
    }
  else if (InetSocketAddress::IsMatchingType (m_peerAddress))
    {
      NS_LOG_INFO ("At time " << Simulator::Now ().GetSeconds () << "s client sent " << m_size << " bytes to " <<
                   InetSocketAddress::ConvertFrom (m_peerAddress).GetIpv4 () << " port " << InetSocketAddress::ConvertFrom (m_peerAddress).GetPort ());
    }
  else if (Inet6SocketAddress::IsMatchingType (m_peerAddress))
    {
      NS_LOG_INFO ("At time " << Simulator::Now ().GetSeconds () << "s client sent " << m_size << " bytes to " <<
                   Inet6SocketAddress::ConvertFrom (m_peerAddress).GetIpv6 () << " port " << Inet6SocketAddress::ConvertFrom (m_peerAddress).GetPort ());
    }

  if (m_sent < m_count) 
    {
      ScheduleTransmit (m_interval);
    }
}

void
UdpEchoClient::HandleRead (Ptr<Socket> socket)
{
  NS_LOG_FUNCTION (this << socket);
  Ptr<Packet> packet;
  Address from;
  Address localAddress;
  while ((packet = socket->RecvFrom (from)))
    {
      if (InetSocketAddress::IsMatchingType (from))
        {
          NS_LOG_INFO ("At time " << Simulator::Now ().GetSeconds () << "s client received " << packet->GetSize () << " bytes from " <<
                       InetSocketAddress::ConvertFrom (from).GetIpv4 () << " port " <<
                       InetSocketAddress::ConvertFrom (from).GetPort ());
        }
      else if (Inet6SocketAddress::IsMatchingType (from))
        {
          NS_LOG_INFO ("At time " << Simulator::Now ().GetSeconds () << "s client received " << packet->GetSize () << " bytes from " <<
                       Inet6SocketAddress::ConvertFrom (from).GetIpv6 () << " port " <<
                       Inet6SocketAddress::ConvertFrom (from).GetPort ());
        }
      socket->GetSockName (localAddress);
      m_rxTrace (packet);
      m_rxTraceWithAddresses (packet, from, localAddress);
    }
}

```

​	发现这里像Server那样，使用`UdpEchoClient::ScheduleTransmit()`进行计划发包。同样调用了`bind()`、`HandleRead()`下的`RecvFrom()`、`send()`方法来监听、接收和发送UDP数据包。这些也是我们后期模拟在命令行看到的客户端提示消息的来源。



​	程序代码里为udp回声客户端指定向接口序号为1的地址的9号端口发送消息。这里必须指定为Udp回声服务器所在接口的地址以及端口号才行。

​	其中SetAttribute()方法可选属性：

```C++
//udp-echo-client.cc
TypeId
UdpEchoClient::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::UdpEchoClient")
    .SetParent<Application> ()
    .SetGroupName("Applications")
    .AddConstructor<UdpEchoClient> ()
    .AddAttribute ("MaxPackets", 
                   "The maximum number of packets the application will send",
                   UintegerValue (100),
                   MakeUintegerAccessor (&UdpEchoClient::m_count),
                   MakeUintegerChecker<uint32_t> ())
    .AddAttribute ("Interval", 
                   "The time to wait between packets",
                   TimeValue (Seconds (1.0)),
                   MakeTimeAccessor (&UdpEchoClient::m_interval),
                   MakeTimeChecker ())
    .AddAttribute ("RemoteAddress", 
                   "The destination Address of the outbound packets",
                   AddressValue (),
                   MakeAddressAccessor (&UdpEchoClient::m_peerAddress),
                   MakeAddressChecker ())
    .AddAttribute ("RemotePort", 
                   "The destination port of the outbound packets",
                   UintegerValue (0),
                   MakeUintegerAccessor (&UdpEchoClient::m_peerPort),
                   MakeUintegerChecker<uint16_t> ())
    .AddAttribute ("PacketSize", "Size of echo data in outbound packets",
                   UintegerValue (100),
                   MakeUintegerAccessor (&UdpEchoClient::SetDataSize,
                                         &UdpEchoClient::GetDataSize),
                   MakeUintegerChecker<uint32_t> ())
    .AddTraceSource ("Tx", "A new packet is created and is sent",
                     MakeTraceSourceAccessor (&UdpEchoClient::m_txTrace),
                     "ns3::Packet::TracedCallback")
    .AddTraceSource ("Rx", "A packet has been received",
                     MakeTraceSourceAccessor (&UdpEchoClient::m_rxTrace),
                     "ns3::Packet::TracedCallback")
    .AddTraceSource ("TxWithAddresses", "A new packet is created and is sent",
                     MakeTraceSourceAccessor (&UdpEchoClient::m_txTraceWithAddresses),
                     "ns3::Packet::TwoAddressTracedCallback")
    .AddTraceSource ("RxWithAddresses", "A packet has been received",
                     MakeTraceSourceAccessor (&UdpEchoClient::m_rxTraceWithAddresses),
                     "ns3::Packet::TwoAddressTracedCallback")
  ;
  return tid;
}
```

​	Udp回声客户端通过`SetAttribute()`方法为相应属性赋值，设置了发送数据包个数、大小，以及数据包之间的发送间隔。同样如回声服务器那样，用`install()`方法传入0号节点的地址，为0号节点安装Udp客户端服务器，并定义了一个应用程序容器用于接收安装成功的返回的回声客户端。服务器跟客户端追的代码几乎完全一样，只是Server跟Client的差别。并通过应用程序容器为echoClient设置了模拟启动后2.0s向结点1的9号端口发送一个1024B的UDP数据包，同样在10.0s后停止。

> 注意！必须设置停止时间，否则模拟启动后，销毁程序会因为事件未结束而不能结束整个程序。

​	

* 77-79行代码：

```C++
Simulator::Run ();
Simulator::Destroy ();
return 0;
```

​	启动模拟，并销毁模拟。程序结束。

​	

#### 3.2.2 编译运行

​	下面来运行程序：

​	打开命令行，进入ns3.31目录，进行编译运行：

```shell
$ cd ns-allinone-3.31/ns-3.31/
$ ./waf --run scratch/first
```

​	会看到以下输出：

![image-20200822001323007](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrECDfviMHGpLiDYlMaCAEDIqdErlIeW*7rpMI79cVd9FHY2ehyEkhhlHXcUWaUTCVln2KXZ*a0gkmN56w836vONI!/r)

​	2秒时客户端向10.1.1.2的9号端口发送了1024字节的数据包，2.00369秒时，服务器收到了来自10.1.1.1的49153端口发送的1024字节的数据包，但因为发送成功后要应答，所以服务器要原路发送应答，所以同样服务器在同一时间也向10.1.1.1的49153端口发送了1024字节的数据包，2.00737秒，客户端接收到来自10.1.1.2的9号端口发送的1024字节的数据包。

​	

​	下面进行可视化模拟：

```shell
$ ./waf --run scratch/first --vis
```

​	点击可视化界面上的`Simulate`按钮或按F3键，启动模拟，在2s停下，将会看到以下内容：

![image-20200822010405618](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEEN0gSn1B2.UghqlmS7Bw4Dv8Og0OsdpzGSz3V5fQ1sgxwjP1TsWzw0pPyEU7sfHuopJz6bU7aHbaQgHtFIqPrU!/r)

​	能看到双向的数据流。同样，随着时间的前进命令行也会蹦出发包收包的消息。

​	

### 3.3 NS3模型及编程思想

​	总结一下first.cc，我们可以得到NS3的模型图：

<svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
 <!-- Created with Method Draw - http://github.com/duopixel/Method-Draw/ -->
 <g>
  <title>background</title>
  <rect fill="#fff" id="canvas_background" height="602" width="802" y="-1" x="-1"/>
  <g display="none" overflow="visible" y="0" x="0" height="100%" width="100%" id="canvasGrid">
   <rect fill="url(#gridpattern)" stroke-width="0" y="0" x="0" height="100%" width="100%"/>
  </g>
 </g>
 <g>
  <title>Layer 1</title>
  <polyline stroke-linecap="round" id="svg_65" points="-397.5,634.4375 -397.5,634.4375 " fill-opacity="null" stroke-opacity="null" stroke-width="3" stroke="#000" fill="none"/>
  <rect id="svg_66" height="548" width="234" y="20.4375" x="34.5" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#DDDDDD"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_68" y="55.4375" x="122.5" fill-opacity="null" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#000000">Node</text>
  <rect id="svg_69" height="66" width="149" y="79.4375" x="91.5" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#ffffff"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_73" y="119.4375" x="109.5" fill-opacity="null" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#000000">Application</text>
  <rect id="svg_76" height="67" width="153" y="108.4375" x="60.5" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#ffffff"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_77" y="149.4375" x="82.5" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#000000">Application</text>
  <ellipse ry="48" rx="105" id="svg_78" cy="288.4375" cx="144.5" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#ffffff"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_79" y="295.4375" x="65.5" fill-opacity="null" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#000000">Protocol Stack</text>
  <rect stroke="#000" id="svg_80" height="66" width="149.999996" y="425.4375" x="80.500004" fill-opacity="null" stroke-opacity="null" stroke-width="1.5" fill="#ffffff"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_83" y="468.4375" x="100.5" stroke-width="0" stroke="#ffffff" fill="#000000">NetDevice</text>
  <rect stroke="#000" id="svg_85" height="66" width="149.999996" y="460.4375" x="56.500004" fill-opacity="null" stroke-opacity="null" stroke-width="1.5" fill="#ffffff"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_86" y="502.4375" x="77.5" stroke-width="0" stroke="#ffffff" fill="#000000">NetDevice</text>
  <rect id="svg_87" height="548" width="234" y="21.4375" x="528.5" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#DDDDDD"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_88" y="56.4375" x="617.5" fill-opacity="null" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#000000">Node</text>
  <rect id="svg_89" height="66" width="149" y="80.4375" x="586.5" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#ffffff"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_90" y="120.4375" x="604.5" fill-opacity="null" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#000000">Application</text>
  <rect id="svg_91" height="67" width="153" y="109.4375" x="555.5" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#ffffff"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_92" y="150.4375" x="577.5" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#000000">Application</text>
  <ellipse ry="48" rx="105" id="svg_93" cy="289.4375" cx="639.5" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#ffffff"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_94" y="296.4375" x="560.5" fill-opacity="null" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#000000">Protocol Stack</text>
  <rect stroke="#000" id="svg_95" height="66" width="149.999996" y="426.4375" x="575.500004" fill-opacity="null" stroke-opacity="null" stroke-width="1.5" fill="#ffffff"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_96" y="469.4375" x="595.5" stroke-width="0" stroke="#ffffff" fill="#000000">NetDevice</text>
  <rect stroke="#000" id="svg_97" height="66" width="149.999996" y="461.4375" x="551.500004" fill-opacity="null" stroke-opacity="null" stroke-width="1.5" fill="#ffffff"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_98" y="503.4375" x="572.5" stroke-width="0" stroke="#ffffff" fill="#000000">NetDevice</text>
  <rect stroke="#000" id="svg_99" height="71.999999" width="149" y="394.437501" x="331.5" fill-opacity="null" stroke-opacity="null" stroke-width="1.5" fill="#ffffff"/>
  <rect stroke="#000" id="svg_101" height="72.000001" width="153" y="462.4375" x="309.5" fill-opacity="null" stroke-opacity="null" stroke-width="1.5" fill="#ffffff"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_102" y="443.4375" x="360.5" fill-opacity="null" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#000000">Channel</text>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_103" y="510.4375" x="339.5" fill-opacity="null" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#000000">Channel</text>
  <path id="svg_104" d="m94.5,199.4375" opacity="0.5" fill-opacity="null" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#ffffff"/>
  <line stroke="#000" stroke-linecap="null" stroke-linejoin="null" id="svg_105" y2="240.437497" x2="146.5" y1="176.4375" x1="145.5" fill-opacity="null" stroke-opacity="null" stroke-width="1.5" fill="none"/>
  <line stroke="#000" stroke-linecap="null" stroke-linejoin="null" id="svg_106" y2="425.437501" x2="147.5" y1="338.4375" x1="147.5" fill-opacity="null" stroke-opacity="null" stroke-width="1.5" fill="none"/>
  <line stroke-linecap="null" stroke-linejoin="null" id="svg_107" y2="242.4375" x2="640.5" y1="177.4375" x1="640.5" fill-opacity="null" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="none"/>
  <line stroke-linecap="null" stroke-linejoin="null" id="svg_108" y2="425.4375" x2="641.5" y1="337.4375" x1="641.5" fill-opacity="null" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="none"/>
  <line stroke-dasharray="2,2" stroke-linecap="null" stroke-linejoin="null" id="svg_109" y2="421.4375" x2="331.5" y1="453.4375" x1="230.5" fill-opacity="null" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="none"/>
  <line stroke-linecap="null" stroke-linejoin="null" id="svg_110" y2="448.4375" x2="575.5" y1="417.4375" x1="480.5" fill-opacity="null" stroke-opacity="null" stroke-dasharray="2,2" stroke-width="1.5" stroke="#000" fill="none"/>
  <line stroke-linecap="null" stroke-linejoin="null" id="svg_111" y2="504.4375" x2="309.5" y1="497.4375" x1="206.5" fill-opacity="null" stroke-opacity="null" stroke-dasharray="2,2" stroke-width="1.5" stroke="#000" fill="none"/>
  <line stroke-linecap="null" stroke-linejoin="null" id="svg_112" y2="499.4375" x2="551.5" y1="505.4375" x1="462.5" fill-opacity="null" stroke-opacity="null" stroke-dasharray="2,2" stroke-width="1.5" stroke="#000" fill="none"/>
  <rect id="svg_113" height="84" width="66" y="160.4375" x="238.5" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#ffffff"/>
  <text xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_114" y="208.4375" x="322.5" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#000000">Packet(s)</text>
  <line stroke-linecap="null" stroke-linejoin="null" id="svg_115" y2="308.4375" x2="283.5" y1="245.4375" x1="282.5" stroke-opacity="null" stroke-width="3" stroke="#000" fill="none"/>
  <line stroke="#000" stroke-linecap="null" stroke-linejoin="null" id="svg_116" y2="310.4375" x2="284.5" y1="281.437501" x1="305.5" stroke-opacity="null" stroke-width="3" fill="none"/>
  <line stroke-linecap="null" stroke-linejoin="null" id="svg_117" y2="310.4375" x2="282.5" y1="281.4375" x1="260.5" stroke-opacity="null" stroke-width="3" stroke="#000" fill="none"/>
  <path d="m682.5,180.4375c0,0 -0.38269,0.076126 0,1c0.541199,1.306564 1,3 1,5c0,2 -0.68927,5.080246 0,8c0.513733,2.176254 1,5 1,7c0,3 0,8 0,12c0,4 1,8 1,12c0,5 0,11 0,16c0,5 1,10 1,15c0,6 -0.494873,12.020447 0,18c0.501709,6.062042 1,12 1,19c0,6 0,12 0,19c0,6 -1,12 -1,19c0,7 -0.498291,13.937958 -1,20c-0.494873,5.979553 0.577393,12.023865 0,19c-0.501709,6.062042 -0.903381,13.016907 -2,19c-0.91925,5.015472 -1,12 -2,18c-1,6 -1.496216,10.907776 -2,15c-0.488708,3.970032 -1.188354,7.943665 -2,11c-1.308777,4.928192 -1.633423,10.022491 -2,13c-0.503784,4.092224 -1.048706,8.289124 -3,13c-1.379761,3.331085 -2.847229,5.041321 -4,9c-0.884155,3.036163 -2,6 -3,9c-1,3 -2,6 -3,8c-1,2 -3.190308,3.881531 -5,7c-1.122314,1.93399 -3.418884,3.418854 -5,5c-1.581116,1.581146 -2.881531,4.190277 -6,6c-1.934021,1.122345 -3.881531,2.190277 -7,4c-1.934021,1.122345 -5.132996,1.569519 -9,3c-4.194336,1.551605 -7.977356,3.095459 -12,4c-4.974792,1.118652 -9,1 -13,2c-4,1 -7.907776,1.496216 -12,2c-4.962524,0.610901 -9.01947,0.605835 -13,1c-5.074219,0.502441 -9.024353,0.507324 -14,1c-5.074219,0.502441 -10.024353,0.507324 -15,1c-5.074219,0.502441 -8.925781,1.497559 -14,2c-4.975647,0.492676 -9.925781,1.497559 -15,2c-4.975647,0.492676 -9.907776,0.496216 -14,1c-4.962524,0.610901 -9.907776,0.496216 -14,1c-1.985016,0.244385 -6,0 -8,0c-3,0 -7.051636,-0.640747 -11,0c-3.121429,0.506531 -7,1 -11,1c-4,0 -9,0 -13,0c-4,0 -8.925781,0.502441 -14,0c-4.975677,-0.492676 -10,0 -15,0c-5,0 -11,-1 -17,-1c-5,0 -8.925781,-0.497559 -14,-1c-3.98053,-0.394165 -8,-1 -13,-1c-4,0 -9,0 -15,0c-4,0 -7.925781,-0.497559 -13,-1c-3.98053,-0.394165 -10.037476,-0.389099 -15,-1c-4.092224,-0.503784 -9.013641,-0.670105 -13,-1c-6.062042,-0.501709 -11,-1 -16,-1c-5,0 -9,0 -14,0c-6,0 -12,0 -16,0c-4,0 -9,-1 -13,-1c-5,0 -8.907791,-0.496216 -13,-1c-3.970032,-0.488708 -7,-1 -11,-1c-4,0 -8.080246,-0.31073 -11,-1c-2.176254,-0.513733 -3.152237,-0.234619 -5,-1c-1.306564,-0.541199 -2.152237,-1.234619 -4,-2c-2.613129,-1.082397 -4.06601,-2.877655 -6,-4c-3.118484,-1.809723 -5,-3 -6,-4c-1,-1 -2,-2 -3,-3c-1,-1 -1.692551,-2.186005 -3,-4c-1.653809,-2.294525 -3,-3 -4,-5c-1,-2 -1,-4 -2,-6c-1,-2 -1.679642,-4.025818 -2,-6c-0.506546,-3.121429 -1.519455,-5.038727 -2,-8c-0.506546,-3.121429 -1.511261,-7.029968 -2,-11c-0.503769,-4.092224 -1.389084,-8.037476 -2,-13c-0.503769,-4.092224 -2,-9 -2,-13c0,-4 -0.408768,-9.029205 -1,-15c-0.502441,-5.074219 -1,-9 -1,-14c0,-4 0,-8 0,-12c0,-4 -1,-7 -1,-11c0,-4 0.488739,-7.029968 0,-11c-0.503769,-4.092224 -1,-8 -1,-13c0,-6 0,-10 0,-15c0,-7 0,-13 0,-20c0,-6 0,-12 0,-17c0,-6 1,-11 1,-16c0,-4 1,-9 1,-14c0,-4 0.496231,-8.907776 1,-13c0.488739,-3.970032 -0.494888,-10.020447 0,-16c0.501709,-6.062042 0.505112,-13.020447 1,-19c0.501709,-6.062042 1,-12 1,-17c0,-5 0,-10 0,-13c0,-2 0,-5 0,-7c0,-2 0,-4 0,-7c0,-2 0,-4 0,-6c0,-1 0,-2 0,-3l1,0l0,-1" id="svg_118" stroke-opacity="null" stroke-width="3" stroke="#000" fill="none"/>
  <path d="m163.5,197.4375c0,0 0,-1 1,-2c1,-1 2.61731,-3.076126 3,-4c0.541199,-1.306564 1.61731,-2.076126 2,-3c0.541199,-1.306564 2,-1 2,-2c0,-1 0.693436,-1.458801 2,-2c0.923874,-0.38269 0.693436,-1.458801 2,-2c0.923874,-0.38269 1.693436,-0.458801 3,-1c0.923874,-0.38269 2,0 3,-1l1,0l0,-1l1,0" id="svg_119" stroke-opacity="null" stroke-width="3" stroke="#000" fill="none"/>
  <path d="m204.5,189.4375c0,0 -1.292892,0.707108 -2,0c-0.707108,-0.707108 -1.292892,-0.292892 -2,-1c-0.707108,-0.707108 -1.292892,-1.292892 -2,-2c-0.707108,-0.707108 -1.292892,-0.292892 -2,-1c-0.707108,-0.707108 -0.292892,-1.292892 -1,-2c-0.707108,-0.707108 -1.292892,-0.292892 -2,-1c-0.707108,-0.707108 -1.292892,-0.292892 -2,-1c-0.707108,-0.707108 -1,-1 -1,-2l-1,0" id="svg_120" stroke-opacity="null" stroke-width="3" stroke="#000" fill="none"/>
  <path d="m664.5,196.4375c0,0 0.292908,-0.292892 1,-1c0.707092,-0.707108 2,-2 4,-5c2,-3 3,-4 4,-5c1,-1 2.292908,-1.292892 3,-2c0.707092,-0.707108 1,-1 2,-1c1,0 1,-1 2,-1l1,0l0,-1l1,0" id="svg_122" stroke-opacity="null" stroke-width="3" stroke="#000" fill="none"/>
  <path d="m709.5,196.4375c0,0 0.707092,-1.292892 0,-2c-0.707092,-0.707108 -2,-1 -3,-2c-1,-1 -1.852722,-2.173096 -3,-3c-1.813965,-1.307449 -3.292908,-1.292892 -4,-2c-0.707092,-0.707108 -0.292908,-0.292892 -1,-1c-0.707092,-0.707108 -0.69342,-1.458801 -2,-2c-0.923889,-0.38269 -2.69342,-1.458801 -4,-2c-0.923889,-0.38269 -1,-1 -2,-1l-1,0l0,-1" id="svg_123" stroke-opacity="null" stroke-width="3" stroke="#000" fill="none"/>
  <line stroke-linecap="null" stroke-linejoin="null" id="svg_125" y2="224.4375" x2="197.5" y1="91.4375" x1="306.5" stroke-opacity="null" stroke-width="3" stroke="#000" fill="none"/>
  <line stroke-linecap="null" stroke-linejoin="null" id="svg_126" y2="226.4375" x2="195.5" y1="203.4375" x1="195.5" stroke-opacity="null" stroke-width="3" stroke="#000" fill="none"/>
  <line stroke="#000" stroke-linecap="null" stroke-linejoin="null" id="svg_127" y2="228.4375" x2="195.5" y1="224.4375" x1="218.5" stroke-opacity="null" stroke-width="3" fill="none"/>
  <text stroke="#000" transform="matrix(0.9704693823032073,0,0,1.0177262503874684,5.861073228575534,2.214260566373782) " xml:space="preserve" text-anchor="start" font-family="Helvetica, Arial, sans-serif" font-size="24" id="svg_129" y="83.4375" x="318.5" stroke-opacity="null" stroke-width="0" fill="#000000">Socket-like API</text>
 </g>
</svg>



​	主要的编程思想（OSI模型自底向上）：

​	1.创建节点。

​	2.选择连接类型，设置连接属性，用连接的install方法为节点安装网络设备，并用网络设备容器保存。注意：如有多个连接，一定依次按以上步骤一个一个来。（物理层、网络层，连接这两个层）

​	3.为节点安装协议栈。（网络层、传输层）

​	4.地址助手设置基准地址。

​	5.用地址助手的Assign方法为设网络设备容器内的设备分配地址，并用接口助手保存。（连接传输层与网络层）

​	6.设置应用层服务器，客户端。设置各种属性、起止时间。（应用层）

​	7.开始模拟，销毁模拟。

​	**以上顺序不能颠倒！**

> helper类的install方法都是用来连接两个层的。

​	

### 3.4 first.cc扩展

#### 3.4.1 日志模块

​	许多大型系统都支持消息记录功能，并且NS3也不例外。NS3认为所有这些详细不同的级别都是有用的，并且提供了一种可选的、多级别的消息记录方法。可以完全禁用日志记录，可以逐个组件启用日志记录，也可以全局启用日志记录；它提供了可选的详细程度。 NS3日志模块提供了一种简单易用的简单方法，可以从仿真中获取有用的信息。

​	当前，系统中定义了七个级别的详细程度不断提高的日志消息：

* LOG_ERROR ——记录错误消息。

* LOG_WARN ——记录警告消息。

* LOG_DEBUG ——记录相对少见的ad-hoc调试消息。

* LOG_INFO ——记录有关程序进度的信息性消息。

* LOG_FUNCTION ——记录每个被调用函数的信息。

* LOG_LOGIC ——记录一个函数内描述逻辑流程的信息。

* LOG_ALL ——记录上述所有内容。

    

​	  对于每个LOG_TYPE，还有一个LOG_LEVEL_TYPE（如果使用的话），因此，LOG_ERROR和LOG_LEVEL_ERROR以及LOG_ALL和LOG_LEVEL_ALL在功能上是等效的。除了记录本级别外，还记录其下所有级别。例如，启用LOG_INFO将仅启用NS_LOG_INFO提供的消息，而启用LOG_LEVEL_INFO还将启用在其之下的NS_LOG_DEBUG，NS_LOG_WARN和NS_LOG_ERROR提供的消息。

​	还提供了无论选择任何日志记录级别或组件都始终显示的无条件日志记录。

* NS_LOG_UNCOND ——无条件记录关联的消息。

​	

​	我们在命令行里看到的消息输出，来源于以下两行代码：

```C++
LogComponentEnable("UdpEchoClientApplication", LOG_LEVEL_INFO);
LogComponentEnable("UdpEchoServerApplication", LOG_LEVEL_INFO);
```

​	前面说了，共有几种不同日志信息记录等级，可以通过配置环境变量来改变日志信息的详细程度。

​	命令行修改环境变量：

```shell
$ export NS_LOG=UdpEchoClientApplication=level_all
```

​	这条命令的作用是修改shell环境的环境变量NS_LOG为字符串`UdpEchoClientApplication=level_all`。修改后，可以通过命令

```shell
$ export -p
```

​	来查看当前环境变量是否修改成功：

![image-20200823170205029](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEJcTw3yqAQVJvL*NvDL06csltq4lKBeU9rr*TK*m8QLwnmnXV8Zy7iEzmAyROM8Tch4AOCtKd8jZBSuHJRBEMsA!/r)

​	此时再编译运行，输出如下：

![image-20200823000351358](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrENri19Q6G0zBeyTfAkUAXrODhQDQNgIkrHnNi*EpcRG.GwEg7f..JCqFv1.T601.Mo8IJ4nxmFVbdbwbWKA9K04!/r)

​	 这些额外的调试信息来自NS_LOG_FUNTION级别的日志，显示了在脚本运行期间程序中每个函数调用过程。 注意，NS3中模型对日志的支持并不是必须的。如果仔细看，会注意到字符串`UdpEchoClientApplication`和方法名之间是单冒号，而不是C++作用域符号(::)（双冒号）。这里是有意为之的，因为`UdpEchoClientApplication`不是类名，而是日志组件名。当一个类仅由一个源文件代表时，这个位置的显示通常是这个类的名字。因此，用单冒号代替双冒号来提醒用户：这里是组件名，不是类名！

​	

​	在某些情况下，可能很难确定哪种方法实际生成了日志消息。比如上图中，假如我们不知道`At time 2.00737s client received 1024 bytes from 10.1.1.2 port 9`是通过哪种方法生成的，可以通过在环境变量加入`prefix_func`来解决此问题。

​	继续修改环境变量：

```shell
$ export 'NS_LOG=UdpEchoClientApplication=level_all|prefix_func'
```

​	注意：这里的命令是在单引号里面的，因为`|`在linux里表示管道，我们要避免shell把命令里的`|`识别为管道符号。

​	然后编译运行，输出如下：

![image-20200823001930356](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrENMzLNaUnfF1YcL2Sp.voQLIxd9A5ev4tgV33zlY3P5wB5ovP1c0ImiopW82RRLwFKVMR76O2xm4aJ8vVgUqYxw!/r)

​	可以看到，上述那条信息的来源是`UdpEchoClientApplication`的`HandleRead()`方法。此时运行结果中剩余的两条信息肯定是来自于`UdpEchoServertApplication`，下面我们来验证：

​	命令行输入：

```shell
$ export 'NS_LOG=UdpEchoClientApplication=level_all|prefix_func:UdpEchoServerApplication=level_all|prefix_func'
```

​	编译运行，输出如下：

![image-20200823003136797](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPeD9JhsjBv*FcwTomWcMBGNGnm8tHgZCSbenNRbDwpJT6JNUKe7nOUKsQzdj.X93rdbOBHShnkLhYnTf49Hn1s!/r)

​	可以看到，UdpEchoServerApplication的也正常显示了。方便于我们对程序进行调试。

​	

​	我们暂时也不知道这些消息都是模拟开始多长时间出现的，可以通过在环境变量中添加`prefix_time`来解决问题。

​	命令行输入：

```shell
$ export 'NS_LOG=UdpEchoClientApplication=level_all|prefix_func|prefix_time:UdpEchoServerApplication=level_all|prefix_func|prefix_time'
```

​	编译运行，输出如下：

![image-20200823004239721](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEOGhkbk4f50l.S0SHGwjeWNgXpoUUNTNu2VlifwDRdocxLJuUhgsAd4hVq36RSWdLyla6sN2LiAkTjlDkxGaOsI!/r)

​	可以看到，这些时间前面都出现了对应发生的时间。

​	

​	在此模拟的背后有很多事情我们是看不到的。通过打开系统中的所有组件的所有日志记录组件，可以非常轻松的让我们看到全部内容。将NS_LOG变量设置为以下内容：

```shell
$ export 'NS_LOG=*=level_all|prefix_func|prefix_time'
```

​	注意，直接编译运行时输出太多了，我们在命令行里根本看不过来，我们可以在运行时把输出重定向到一个文件中。

```shell
$ ./waf --run first > log.out 2>&1
```

​	输出的文件位于ns3.31目录下，尝试打开：

![image-20200823005912259](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBDuwGDFy735csA3TjwVvAabijsUFUHddNswBjpDRzo.WCOc77Ug.eQmcvSpIe92Gnkwdfd4sGfDzjq*BVPKMY8!/r)

​	共计将近四十多万行代码（399829行）。这种冗长的代码并非一无是处，当我们遇到bug时，可以通过这样的方式找到程序哪里出了问题，方便我们debug。

​	

​	可以对我们的程序添加日志，在创建节点之前添加以下代码：

```C++
NS_LOG_INFO ("Creating Topology");
```

​	之后清空我们之前配置的环境变量：

```shell
$ ./waf
$ export NS_LOG=
```

​	编译运行，但没有看到我们设置的消息， 因为与它相关的日志组件(FirstScriptExample)没有被启用。为了看到该日志的消息，必须使用大于或等于NS_LOG_INFO的日志级别来启用FirstScriptExample日志组件。如果只是想要看某个级别的日志，可以通过下面的语句来启用：

```shell
$ export NS_LOG=FirstScriptExample=info
```

​	重新编译运行。就能看到我们设置的消息：

![image-20200823173410706](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEJYlYiSsZEm1fIBR934iwEzpvuK8YBOHWa42GrNf.7TeZmRt1Pg3iOqohYKEquulvlP.pmBIW19EsOG1RLLq.pg!/r)

​	

#### 3.4.2 使用命令行参数改变变量

​	除了环境变量之外，无需编辑和构建即可更改NS3程序行为的另一种方法是通过命令行参数。 NS3为我们提供了一种解析命令行参数的机制，并根据这些参数自动设置局部和全局变量。

​	由于first.cc程序中已经有命令行分析器：

```C++
CommandLine cmd;
cmd.Parse (argc, argv);
```

​	所以我们在编译运行时，可以直接向命令行分析器传递命令行参数。先在命令行看一下帮助：

```shell
$ ./waf --run "scratch/first --PrintHelp"
```

​	输出如下：

![image-20200823205802530](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEA8Tdx31KQ.mEiyQW8dA*YaeZG04YoAw6o2xPCISYq7EhrJHBwPi5hJUTVEYkmwkq3tvvSu*edOXyNuGO4xAA2A!/r)

​	下面来关注一下`--PrintAttributes`选项。在我们查看first.cc脚本的时候，已经提到过NS3的系统属性：

```C++
PointToPointHelper pointToPoint;
pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));
```

​	我们已知`DataRate`是`PointToPointNetDevice`的一个属性。现在用命令行参数分析器来看一下`PointToPointNetDevice`的参数：

```shell
$ ./waf --run "scratch/first --PrintAttributes=ns3::PointToPointNetDevice"
```

​	会看到以下输出：

![image-20200823210848967](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEHyN9I0pqMDryoSu*E9X28LBSGmcT5kzn*LOvENkSM3s96g7wjTZT4G*ragiRzjTQNzDrw2YrBrTAGgnn99WYAY!/r)

​	当系统中的`PointToPointNetDevice`被创建时，`DataRate`将作为一个默认值被运用。脚本用PointToPointHelper重载了这个默认值。现在我们删除first.cc中的`SetDeviceAttribute`和`SetChannelAttribute`调用，仅使用默认值来设置点到点设备和信道。

```C++
...

NodeContainer nodes;
nodes.Create (2);

PointToPointHelper pointToPoint;

NetDeviceContainer devices;
devices = pointToPoint.Install (nodes);

...
```

​	启用Udpecho服务器应用的一些日志并通过环境变量打开全部消息以及时间前缀：

```shell
$ export 'NS_LOG=UdpEchoServerApplication=level_all|prefix_time'
```

​	编译运行，输出如下：

![image-20200823212713627](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEJsjZaXKijFSmfKeUhhUB.cTtchYPVaNQGLZbgRJRllzliY91.HziRhSdgi2Y1JuEit6wh2t7rFppiF1Yf01Y.c!/r)

​	 注意到，之前`PointToPointHelper`设置参数时，Echo服务器收到数据包的仿真时间是2.0036864s，现在是2.257324218s。 这是因为我们没有对`PointToPointNetDevice`进行设置，所以它便采用了默认值。数据传输速率从5Mbps降到了32768bps。 如果我们采用命令行来指定一个新的`DataRate`，能够重新加快数据包传输的速度。我们可以根据帮助文档中指明的规则，通过命令行指定`DataRate`：

```shell
$ ./waf --run "scratch/first --ns3::PointToPointNetDevice::DataRate=5Mbps"
```

​	再次编译运行，输出如下：

![image-20200823213504325](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEEGPyYOP98KcpJgSIx9LXi4*eY4kA04avvFT35NSoH93rr1t*GOXeMO06fCxQBdnbWxzdeEfk76Lw6NTAD9f8eU!/r)

​	现在服务器收到消息的时间的是2.0016864s，跟原来的不同。这是因为之前程序中我们设置了信道延迟为2ns，而默认的延迟为0ns。可以通过下面的命令看一下信道延迟的属性：

```shell
$ ./waf --run "scratch/first --PrintAttributes=ns3::PointToPointChannel"
```

​	输出如下：

![image-20200823214053480](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrELMkrL*jdWlvqyP3DNLVWuF3tX1aA*pqCeAqAGlUtIqXit1Uk316kULKheS18WOaCRacMMvMK6607iTFr085HFw!/r)

​	同理，可以通过同样的方式同时设置这两个属性的值：

```shell
$ ./waf --run "scratch/first --ns3::PointToPointNetDevice::DataRate=5Mbps --ns3::PointToPointChannel::Delay=2ms"
```

​	输出如下：

![image-20200823214459712](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEC69LYMHhNKrO6zyw.3xHleyuPA3ka3Tt2OxbwzstFXv*htiRMiXMyrSotyMfJpbR*T6cpNkzRZ2J.A9Jl.zWHU!/r)

​	现在仿真时间就跟最开始一样了。我们可以通过这种方式指定所有我们想要指定的变量。

​	

​	那么问题来了，如何知道全部已有的属性？

​	再看一下刚才的帮助信息：

![image-20200823205802530](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEA8Tdx31KQ.mEiyQW8dA*YaeZG04YoAw6o2xPCISYq7EhrJHBwPi5hJUTVEYkmwkq3tvvSu*edOXyNuGO4xAA2A!/r)

​	 如果选择`--PrintGroups`选项，将看到一张列有所有已注册的TypeId groups。group的名字与src目录下的模型名一致。但这会一次性输出所有消息，导致信息量太大的问题。所以我们可以进一步过滤一些信息，例如输出单组信息：

```shell
$ ./waf --run "scratch/first --PrintGroup=PointToPoint"
```

​	将会看到以下输出：

![image-20200823215150781](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEMyZ.1z1pw21Y72Ovr.p3BCAQCHjxpFoviK2WDeNe8*V.VxYefKRYLkP26u1cmAJ7gqmoNiQDn9XG0sYvB135Z8!/r)

​	查找属性的另一种方法是通过NS3 Doxygen。 有一个页面列出了NS3中所有已注册的属性。

​	

#### 3.4.3 向命令行系统添加自设属性

​	可以利用AddValue方法向命令行系统添加自己的属性。 让我们用这个方法来改变发送数据包数量。首先，在main函数中添加一个变量nPackets，并将其初始化为1，使之与之前的默认参数一致。为了允许命令行参数分析器可以改变nPackets值，我们需要在分析器中添加这个值。在first.cc中做一些变动：

```C++
int main (int argc, char *argv[])
{
  uint32_t nPackets = 1;

  CommandLine cmd;
  cmd.AddValue("nPackets", "Number of packets to echo", nPackets);
  cmd.Parse (argc, argv);

  ...
```

​	向下滚动到脚本中设置MaxPackets属性的位置并进行更改，将其设置为变量nPackets而不是常量1，如下所示：

```C++
echoClient.SetAttribute ("MaxPackets", UintegerValue (nPackets));
```

​	编译运行，并向脚本寻求帮助：

```shell
$ ./waf --run "scratch/first --PrintHelp"
```

​	输出如下：

![image-20200823220349156](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEM94MLkDRplWQbezNRjqAwD18Y5Q3lMGz6Kj41tDsOw1Ai0SZoz.0FsZR8bJogozRtfvr9.iMPC18jLbcOn29Pg!/r)

​	可以看到，已经能在命令行解析器中看到我们设置的消息。

​	也可以通过命令行的方式修改`nPackets`的值。

```shell
$ ./waf --run "scratch/first --nPackets=2"
```

​	输出如下：

![image-20200823220848438](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEEqLVT3j8QwYNmyuyqQKJJ*onrzUQudbyR9F9TmNWGOgN*DCKpOQLre9MpBVFSFFlawoyLFhFpo1g9AsuSww7cM!/r)

​	现在系统发了两个包。

​	

​	如果你是一个NS3用户，你可以用命令行参数系统控制全局变量和属性。

​	如果你是一个模型作者，你可以向你的对象添加新的属性，你的模型用户可以通过命令行参数系统设置这些属性。

​	如果你是一个脚本作者，你可以轻松地在你的脚本里添加新变量，并且将它们添加进命令行参数系统。

​	

#### 3.4.4 使用追踪系统

​	仿真的目的是生成输出以供进一步研究，而NS3追踪系统就是为了这个目的定制的。

​	因为NS3是由 C++ 编写的，所以 C++ 的标准输入输出在NS3里是可以使用的。

```C++
#include <iostream>
...
int main ()
{
  ...
  std::cout << "The value of x is " << x << std::endl;
  ...
}
```

​	 我们可以用日志模块来为我们的解决方法添加一些小结构，但这种方法会产生很多已知的问题。所以我们提供了一种生成事件的追踪子系统来解决那些我们认为重要的问题。

​	 NS3追踪系统的基本目标是：

*  对于基本的任务，追踪系统允许用户为常用的追踪发送端产生标准的追踪，并且可以定制哪些对象生成追踪。

*  中级用户必须能够拓展追踪系统来修改生成的输出格式，或者在不修改NS3核心的情况下插入新的追踪发送端。

* 高级用户可以修改NS3核心，以添加新的追踪发送端和接收端。

    

​	NS3追踪系统是建立在独立的追踪发送端和接收端概念上，并且有统一的机制来连接发送端和接收端。追踪发送端可以在仿真过程中产生信号事件，并且提供有关数据访问信道。例如，单独的追踪发送端是没用的，必须和接收端提供的有用信息代码段“相连”。追踪接收端是发送端提供的事件和时间的使用者。例如，可以创建一个的追踪接收端，当它连接到之前例子中的发送端时，它可以可以输出数据包中有用的信息。

​	 这种发送端和接收端明确分工的基本原理是允许用户将已有的发送端与新类型的接收端相连，而不需要编辑和重新编译NS3的核心。因此，上面的例子中，用户可以在他的脚本中定义一个新的追踪接收端，并通过仅编辑用户脚本将其附加到在模拟核心中定义的现有追踪源。

​	 NS3提供两种追踪机制：ASCII追踪和pcap追踪。 NS3提供了封装底层追踪系统并为我们提供了助手，以帮助我们了解配置一些易于理解的数据包追踪的细节。如果使用了这个功能，将在ASCII文件中输出结果——这就是为什么这种追踪得名ASCII追踪。对于熟悉NS2的用户，这种追踪与out.tr相似。

##### ASCII追踪

​	 在first.cc脚本中添加ASCII追踪输出。在Simulator::Run()前，添加下面的代码：

```C++
AsciiTraceHelper ascii;
pointToPoint.EnableAsciiAll (ascii.CreateFileStream ("first.tr"));
```

​	追一下`EnableAsciiAll()`这个函数：

```C++
//trace-helper.cc
void
AsciiTraceHelperForDevice::EnableAsciiAll (Ptr<OutputStreamWrapper> stream)
{
  EnableAsciiImpl (stream, std::string (), NodeContainer::GetGlobal ());
}
```

​	再追一下`EnableAsciiImpl()`这个函数：

```C++
void
AsciiTraceHelperForDevice::EnableAsciiImpl (Ptr<OutputStreamWrapper> stream, std::string prefix, NodeContainer n)
{
  NetDeviceContainer devs;
  for (NodeContainer::Iterator i = n.Begin (); i != n.End (); ++i)
    {
      Ptr<Node> node = *i;
      for (uint32_t j = 0; j < node->GetNDevices (); ++j)
        {
          devs.Add (node->GetDevice (j));
        }
    }
  EnableAsciiImpl (stream, prefix, devs);
}
```

​	追一下`CreateFileStream()`这个函数：

```C++
//trace-helper.cc
Ptr<OutputStreamWrapper>
AsciiTraceHelper::CreateFileStream (std::string filename, std::ios::openmode filemode)
{
  NS_LOG_FUNCTION (filename << filemode);

  Ptr<OutputStreamWrapper> StreamWrapper = Create<OutputStreamWrapper> (filename, filemode);

  //
  // Note that the ascii trace helper promptly forgets all about the trace file.
  // We rely on the reference count of the file object which will soon be owned
  // by the caller to keep the object alive.  If the caller uses the stream 
  // object to hook a trace source, ownership of the stream object will be
  // implicitly transferred to the callback which keeps the object alive.
  // When the callback is destroyed (when either the trace is disconnected or
  // the object with the trace source is deleted) the callback will be destroyed
  // and the stream object will be destroyed, releasing the pointer and closing
  // the underlying file.
  //
  return StreamWrapper;
}
```

​	其中，`CreateFileStream()`用未命名的对象在协议栈中创建了一个文件流，并把这个文件流传递给了调用方法，即创建了一个对象代表着一个名为“first.tr”的文件，并将创建后的结果传递给了`EnableAsciiAll()`。`EnableAsciiAll()`通过迭代器为将ASCII 追踪安装在仿真中的点到点设备上，并且我们想要接收端以ASCII格式写出数据包移动信息。 这两行代码用来打开一个将被写入名为“first.tr”文件中的数据流。代码段中的第二行告诉NS3在仿真中为所有点对点设备启用ASCII追踪功能，并且要用ASCII格式来写出数据流中数据包的移动信息。类似于NS2，追踪事件与一般的追踪相似，记录了“+”、“-”、“d”、“r”事件。正常编译运行：

```shell
$ ./waf --run scratch/first
```

​	此时，程序将创建一个名为“first.tr”的文件。由于waf的工作方式，这个文件将不在代码文件所在的目录下创建，而是在NS3根目录中创建。我们在ns3.31目录找到并打开：

![image-20200823224102288](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEHHjYCP*BrBV6v5Prm6Cy*FN6AEuuSEUMQonAA1aRjRFL*36zMyAU.gnu54tvRsyealYwTMubl0xmAu6aXlP8EQ!/r)

​	 文件中的每一行都对应一个追踪事件。 在这种情况下，我们将追踪模拟中每个点对点网络设备中存在的传输队列上的事件。 发送队列是一个队列，每个发往点对点信道的数据包都必须经过该队列。 注意，追踪文件中的每一行都以一个单独的字符开头（其后有一个空格）。 此字符将具有以下含义：

*  \+ ：设备队列中的入队操作。
*  \- ：设备队列中的出队操作。
*  d ：数据包被丢弃，通常是因为队列已满。
*  r ：数据包被网络备接收。



​	让我们更详细地了解跟踪文件中的第一行：

```C++
+  //操作。传输队列入队操作。
2  //发送数据包的时间
/NodeList/0/DeviceList/0/$ns3::PointToPointNetDevice/TxQueue/Enqueue  //告诉我们哪个追踪发送端发起这个事件（以追踪命名空间表示）。可以认为追踪命名空间有点像一个文件系统命名空间。命名空间的根为NodeList。NodeList是NS3核心代码管理的一个容器，这个容器包含有一个脚本中创建的所有节点。就像文件系统在根下有目录，在NodeList下有节点数目。字符串/NodeList/0是指NodeList中的第0个节点。每个节点中有一个已经安装好的设备列表。这个列表是在命名空间的下一个出现的。可以看到追踪事件来自节点中安装的第0个设备DeviceList/0。ns3::PointToPointNetDevice告诉我们第0个节点的设备列表的第0个位置的设备类型。//入队操作在最后部分的“trace path”TxQueue/Enqueue中体现。
ns3::PppHeader (
  Point-to-Point Protocol: IP (0x0021))  //表明数据包封装成点对点协议
  ns3::Ipv4Header (
    tos 0x0 DSCP Default ECN Not-ECT ttl 64 id 0 protocol 17 offset (bytes) 0 flags [none]
    length: 1052 10.1.1.1 > 10.1.1.2)  //显示数据包IP版本，发送端IP地址10.1.1.1，接收端地址为10.1.1.2 17号协议为Udp
    ns3::UdpHeader (
      length: 1032 49153 > 9)  //显示数据包的UDP头，端口号49153到9号
      Payload (size=1024)  //表示数据包大小为1024字节
```

​	下图为IPv4首部结构，结合查看：

![ipv4](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEIuWZqzqlzpUTfXDOIVhUaj*n7xitm*6YIirwBAwqbJsJS89n7IODn*HLOlVPpMG.uuI2P6XqbfPTe7q75hxIJc!/r)

* 版本号：IP包的版本，当前一般为IPv4，即0100。 
* 首部长度：IP包头长度（Internet Header Length，IHL），是一个4bit字段，是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节，表示头部报文中没有发送可选部分数据。 
* 服务类型（TOS）：其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。实际上，大部分主机会忽略这个字段，但一些动态路由协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。 
* 总长度：头部及数据项长度，最大长度为65535bytes。 
* 标识：当IP包较大需要进行分段时，用于标识该段所属的分组。通常每发一份报文，它的值会加1。 
* 标志：构成为[0]、[D]、[M]，其中D为1表示不分段，M为0表示为最后分段，为1表示非最后分段。 
* 片偏移：即分段偏移。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置。 
* 生存时间（TTL）：表示一个IP数据流的生命周期，由发送数据的源主机设置，通常为32、64、128等。每次IP数据包经过一个路由器的时候TTL就减一，当减到0时，这个数据包就消亡了。 
* 协议：传输层的协议类型。

| **协议代码** | **协议名称**                              |
| ------------ | ----------------------------------------- |
| 1            | ICMP (Internet Control Message Protocol)  |
| 2            | IGMP (Internet Group Management Protocol) |
| 3            | GGP (Gateway-to-Gateway Protocol)         |
| 4            | IP (IP in IP encapsulation)               |
| 6            | TCP (Transmission Control Protocol)       |
| 8            | EGP (Exterior Gateway Protocol)           |
| 17           | UDP (User Datagram Protocol)              |

* 首部校验和：根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（与ICMP、IGMP、TCP、UDP不同，IP不对头部后的数据进行校验）。 

* 选项：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求。 

* 数据：IP包携带的各种传输层报文。

​	IP报文头部实例：45 00 00 30 52 52 40 00 80 06 2c 23 c0 a8 01 01 d8 03 e2 15



​	追踪文件的第二行显示了这个数据包在这个节点上的传输队列中出队。

​	追踪文件中的第三行显示了具有回显服务器的节点上的网络设备正在接收数据包：

```C++
r //表示接收到了数据包
2.25732  //接收到数据包的时间
/NodeList/1/DeviceList/0/$ns3::PointToPointNetDevice/MacRx  //追踪发送端命名空间条目已经改变，这个事件来自节点1(NodeList/1)，即数据包的接收端(/MacRx)。
  ns3::PppHeader( //表明数据包封装成点到点协议
    Point-to-Point Protocol: IP(0x0021))
    ns3::Ipv4Header(
    	tos 0x0 DSCP Default ECN Not-ECT ttl 64 id 0 protocol 17 offset (bytes) 0 flags [none]
    	length: 1052 10.1.1.1>10.1.1.2)
    	ns3::UdpHeader (
      		length: 1032 49153 > 9)
      		Payload (size=1024)
```

​	通过查看文件中的其余追踪信息，可以很容易地追踪数据包的进度。

​	

##### PCAP追踪

​	NS3也支持创建.pcap格式的追踪文件，缩写pcap表示`packet capture`，事实上是包含有定义一个.pcap文件格式的API。可以读取并且显示这种格式的程序是Wireshark。然而，有很多其他分析器也使用这个数据包格式。本例中，我们用`tcpdump`来查看pcap追踪。在first.cc刚添加的ASCII追踪后中添加以下代码：

```C++
pointToPoint.EnablePcapAll ("first");
```

​	追一下`EnablePcapAll()`这个函数：

```C++
//trace-helper.cc
void
PcapHelperForDevice::EnablePcapAll (std::string prefix, bool promiscuous)
{
  EnablePcap (prefix, NodeContainer::GetGlobal (), promiscuous);
}
```

​	再追一下`EnablePcap()`这个函数：

```C++
//trace-helper.cc
void 
PcapHelperForDevice::EnablePcap (std::string prefix, uint32_t nodeid, uint32_t deviceid, bool promiscuous)
{
  NodeContainer n = NodeContainer::GetGlobal ();

  for (NodeContainer::Iterator i = n.Begin (); i != n.End (); ++i)
    {
      Ptr<Node> node = *i;
      if (node->GetId () != nodeid) 
        {
          continue;
        }

      NS_ABORT_MSG_IF (deviceid >= node->GetNDevices (), "PcapHelperForDevice::EnablePcap(): Unknown deviceid = " 
                       << deviceid);
      Ptr<NetDevice> nd = node->GetDevice (deviceid);
      EnablePcap (prefix, nd, promiscuous);
      return;
    }
}

void
PcapHelperForDevice::EnablePcap (std::string prefix, NodeContainer n, bool promiscuous)
{
  NetDeviceContainer devs;
  for (NodeContainer::Iterator i = n.Begin (); i != n.End (); ++i)
    {
      Ptr<Node> node = *i;
      for (uint32_t j = 0; j < node->GetNDevices (); ++j)
        {
          devs.Add (node->GetDevice (j));
        }
    }
  EnablePcap (prefix, devs, promiscuous);
}

void 
PcapHelperForDevice::EnablePcap (std::string prefix, NetDeviceContainer d, bool promiscuous)
{
  for (NetDeviceContainer::Iterator i = d.Begin (); i != d.End (); ++i)
    {
      Ptr<NetDevice> dev = *i;
      EnablePcap (prefix, dev, promiscuous);
    }
}

void 
PcapHelperForDevice::EnablePcap (std::string prefix, Ptr<NetDevice> nd, bool promiscuous, bool explicitFilename)
{
  EnablePcapInternal (prefix, nd, promiscuous, explicitFilename);
}
```

​	追一下`EnablePcapInternal()`这个函数：

```C++
// /src/wimax/helper/wimax-helper.cc
void
WimaxHelper::EnablePcapInternal (std::string prefix, Ptr<NetDevice> nd, bool explicitFilename, bool promiscuous)
{
  //
  // All of the Pcap enable functions vector through here including the ones
  // that are wandering through all of devices on perhaps all of the nodes in
  // the system.  We can only deal with devices of type WimaxNetDevice.
  //
  Ptr<WimaxNetDevice> device = nd->GetObject<WimaxNetDevice> ();
  if (device == 0)
    {
      NS_LOG_INFO ("WimaxHelper::EnablePcapInternal(): Device " << &device << " not of type ns3::WimaxNetDevice");
      return;
    }

  Ptr<WimaxPhy> phy = device->GetPhy ();
  PcapHelper pcapHelper;
  std::string filename;
  if (explicitFilename)
    {
      filename = prefix;
    }
  else
    {
      filename = pcapHelper.GetFilenameFromDevice (prefix, device);
    }

  Ptr<PcapFileWrapper> file = pcapHelper.CreateFile (filename, std::ios::out, PcapHelper::DLT_EN10MB);

  phy->TraceConnectWithoutContext ("Tx", MakeBoundCallback (&PcapSniffTxRxEvent, file));
  phy->TraceConnectWithoutContext ("Rx", MakeBoundCallback (&PcapSniffTxRxEvent, file));
}

int64_t
WimaxHelper::AssignStreams (int64_t stream)
{
  NS_LOG_FUNCTION (this << stream);
  return m_channel->AssignStreams (stream);
}
```

​	可以看到，这里`EnablePcapAll()`遍历了当前连接的所有节点容器，再调用`EnablePcap()`使用迭代器为每个节点容器中的每一个设备激活PCAP追踪。而且提供了可以对指定节点号设备号、指定节点容器、指定网络设备容器、以及指定设备号四种不同的追踪方法。

​	注意案例中的代码的字符串是“first”，而不是“first.pcap”。这是因为这里传递的参数只是一个前缀，而不是完整的文件名，在源码中我们也可以看到这一点。在仿真过程中，点对点助手使用迭代器为相应容器内的每一个设备创建追踪文件。文件名将包含预设前缀，节点号，设备号和“.pcap”后缀。

​	添加完成后，正常编译运行程序：

```shell
$ ./waf --run scratch/first
```

​	进入ns3.31目录，我们将会看到：

![image-20200823234555495](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEKCR*A29eJeXZhYgHz1i..zb59VA4yxvz4DldzWkqVlroOC3CXm7ZaeDRB0Thk4cURj4zP2VaKHnsHkfRAF5h74!/r)

​	会得到2个追踪文件：first-0-0.pcap，first-1-0.pcap。其中first-0-0.pcap代表第0个节点的第0个设备。

​	下面在命令行中用`tcpdump`读取pcap文件：

```shell
$ tcpdump -nn -tt -r first-0-0.pcap
$ tcpdump -nn -tt -r first-1-0.pcap
```

​	输出如下：

![image-20200823235238422](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEKmCHZ3VEBTz2EmE*Uqng1EDKidw4M4C2DoaaV1GsYQRVH.DlDL6WymShXoIF4z8wpIMw0v14aF6cNbyXOJErx0!/r)

​	也可以看到类似于之前我们在ASCII追踪中看到的信息。

​	

​	也可以通过wireshark读取数据包：

​	安装wireshark：

```shell
$ sudo apt-get install wireshark
```

​	用wireshark打开pcap数据包：

<img src="http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEGfFgxX9XcFxdO9GoiysQ7JY5IpYW67gYBhxphrbClCSg.9JYpsjWqGHeyS.9c.1ePEYr*9yIExXXSxWvUg8Ln8!/r"  />

​	

![image-20200823235852526](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrECUyF5qJp2cj32uOBZyJh7JZp1QDcxuoWBhlxsHjSFS3PFeeUNa656yr*lipvNbIsIMezVGBqD1kfte3eFpVv3E!/r)

​	同样也可以获取到我们想要的信息。

​	

### 3.5 second.cc

​	NS3为我们提供了CSMA（Carrier Sense Multiple Access、载波侦听多路访问）的网络设备和信道。

​	NS3的CSMA模型模拟了一个简单的以太网网络。但一个真正的以太网用带有指数退避算法的CSMA/CD（Carrier Sense Multiple Access with Collision Detection、带冲突检测的载波侦听多路访问技术）来共享传输媒介。NS3的CSMA设备和信道模型只是其子集。

​	

#### 3.5.1 代码学习

​	下面我们来看一下second.cc，second.cc基于first.cc添加了一个csma网络。

​	在vscode中打开我们之前拷过去的scartch/second.cc，代码如下：

```C++
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/csma-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"
#include "ns3/ipv4-global-routing-helper.h"

// Default Network Topology
//
//       10.1.1.0
// n0 -------------- n1   n2   n3   n4
//    point-to-point  |    |    |    |
//                    ================
//                      LAN 10.1.2.0


using namespace ns3;

NS_LOG_COMPONENT_DEFINE ("SecondScriptExample");

int 
main (int argc, char *argv[])
{
  bool verbose = true;
  uint32_t nCsma = 3;

  CommandLine cmd (__FILE__);
  cmd.AddValue ("nCsma", "Number of \"extra\" CSMA nodes/devices", nCsma);
  cmd.AddValue ("verbose", "Tell echo applications to log if true", verbose);

  cmd.Parse (argc,argv);

  if (verbose)
    {
      LogComponentEnable ("UdpEchoClientApplication", LOG_LEVEL_INFO);
      LogComponentEnable ("UdpEchoServerApplication", LOG_LEVEL_INFO);
    }

  nCsma = nCsma == 0 ? 1 : nCsma;

  NodeContainer p2pNodes;
  p2pNodes.Create (2);

  NodeContainer csmaNodes;
  csmaNodes.Add (p2pNodes.Get (1));
  csmaNodes.Create (nCsma);

  PointToPointHelper pointToPoint;
  pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
  pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));

  NetDeviceContainer p2pDevices;
  p2pDevices = pointToPoint.Install (p2pNodes);

  CsmaHelper csma;
  csma.SetChannelAttribute ("DataRate", StringValue ("100Mbps"));
  csma.SetChannelAttribute ("Delay", TimeValue (NanoSeconds (6560)));

  NetDeviceContainer csmaDevices;
  csmaDevices = csma.Install (csmaNodes);

  InternetStackHelper stack;
  stack.Install (p2pNodes.Get (0));
  stack.Install (csmaNodes);

  Ipv4AddressHelper address;
  address.SetBase ("10.1.1.0", "255.255.255.0");
  Ipv4InterfaceContainer p2pInterfaces;
  p2pInterfaces = address.Assign (p2pDevices);

  address.SetBase ("10.1.2.0", "255.255.255.0");
  Ipv4InterfaceContainer csmaInterfaces;
  csmaInterfaces = address.Assign (csmaDevices);

  UdpEchoServerHelper echoServer (9);

  ApplicationContainer serverApps = echoServer.Install (csmaNodes.Get (nCsma));
  serverApps.Start (Seconds (1.0));
  serverApps.Stop (Seconds (10.0));

  UdpEchoClientHelper echoClient (csmaInterfaces.GetAddress (nCsma), 9);
  echoClient.SetAttribute ("MaxPackets", UintegerValue (1));
  echoClient.SetAttribute ("Interval", TimeValue (Seconds (1.0)));
  echoClient.SetAttribute ("PacketSize", UintegerValue (1024));

  ApplicationContainer clientApps = echoClient.Install (p2pNodes.Get (0));
  clientApps.Start (Seconds (2.0));
  clientApps.Stop (Seconds (10.0));

  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();

  pointToPoint.EnablePcapAll ("second");
  csma.EnablePcap ("second", csmaDevices.Get (1), true);

  Simulator::Run ();
  Simulator::Destroy ();
  return 0;
}

```

​	

​	下面进行详细学习。

​	

* 1-15行代码：

```C++
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
```

​	仍然是一些版权信息，语言风格之类。

​	

* 17-23行代码：

```C++
#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/csma-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"
#include "ns3/ipv4-global-routing-helper.h"
```

​	相比first.cc，因为我们这个案例中多了csma网络，要把对应的头文件包含进来。以及这是个互联网络，我们需要某种路由协议来使数据能够正常发送与接收。

​	

* 25-31行代码：

```C++
// Default Network Topology
//
//       10.1.1.0
// n0 -------------- n1   n2   n3   n4
//    point-to-point  |    |    |    |
//                    ================
//                      LAN 10.1.2.0
```

​	是second.cc的拓扑图。

​	

* 34-36行代码：

```C++
using namespace ns3;

NS_LOG_COMPONENT_DEFINE ("SecondScriptExample");
```

​	是命名空间以及日志组件名称。

​	

* 38-42行代码：

```C++
int 
main (int argc, char *argv[])
{
  bool verbose = true;
  uint32_t nCsma = 3;
```

​	进入主函数部分，声明了一个bool型变量verbose，以及控制右侧csma节点个数的变量。

​	

* 44-48行代码：

```C++
CommandLine cmd (__FILE__);
cmd.AddValue ("nCsma", "Number of \"extra\" CSMA nodes/devices", nCsma);
cmd.AddValue ("verbose", "Tell echo applications to log if true", verbose);

cmd.Parse (argc,argv);
```

​	声明了一个命令行解析器，向命令行添加verbose及nCsma的信息，并读取了命令行参数。

​	

* 50-56行代码：

```C++
if (verbose)
  {
    LogComponentEnable ("UdpEchoClientApplication", LOG_LEVEL_INFO);
    LogComponentEnable ("UdpEchoServerApplication", LOG_LEVEL_INFO);
  }

nCsma = nCsma == 0 ? 1 : nCsma;
```

​	用verbose控制Server以及Client的日志组件。当verbose为真时（默认为真），启用Server以及Client的日志组件。可以通过命令行改变verbose的值。

​	判断了一下nCsma的值。因为我们后面要通过命令行传参，需要加一个判断来阻止某些非法数值。如果nCsma为0，则赋值为1。如果不为0，则为nCsma本身的值。这里是个三目运算符，如果看不懂的话加个括号会更好：

```C++
nCsma = (nCsma == 0) ? 1 : nCsma;
```

​	

* 58-63行代码：

```C++
NodeContainer p2pNodes;
p2pNodes.Create (2);

NodeContainer csmaNodes;
csmaNodes.Add (p2pNodes.Get (1));
csmaNodes.Create (nCsma);
```

​	创建了一个两个容器，第一个为点对点节点的容器，并在容器内创建两个节点。第二个为csma节点的容器，并将点对点容器的1号节点加入csma节点容器。然后创建了nCsma个节点。此时第一个节点容器中的第二个节点，既是点对点节点也是csma节点，此节点同时连接两种网络。

​	

* 65-67行代码：

```C++
PointToPointHelper pointToPoint;
pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));
```

​	如first.cc一样，用点对点助手创建了一个点对点连接，并设置连接的数据速率以及延迟。

​	

* 69-70行代码：

```C++
NetDeviceContainer p2pDevices;
p2pDevices = pointToPoint.Install (p2pNodes);
```

​	创建了点对点的网络设备容器，并为点对点节点容器内的每个节点安装网络设备。

​	

* 72-74行代码：

```C++
CsmaHelper csma;
csma.SetChannelAttribute ("DataRate", StringValue ("100Mbps"));
csma.SetChannelAttribute ("Delay", TimeValue (NanoSeconds (6560)));
```

​	出现了新类Csma助手，我们来追一下：

```C++
//csma-helper.h
class CsmaHelper : public PcapHelperForDevice, public AsciiTraceHelperForDevice
{
public:
  /**
   * Construct a CsmaHelper.
   */
  CsmaHelper ();
  virtual ~CsmaHelper () {}
  ……
    /**
   * \param n1 the name of the attribute to set
   * \param v1 the value of the attribute to set
   *
   * Set these attributes on each ns3::CsmaNetDevice created
   * by CsmaHelper::Install
   */
  void SetDeviceAttribute (std::string n1, const AttributeValue &v1);

  /**
   * \param n1 the name of the attribute to set
   * \param v1 the value of the attribute to set
   *
   * Set these attributes on each ns3::CsmaChannel created
   * by CsmaHelper::Install
   */
  void SetChannelAttribute (std::string n1, const AttributeValue &v1);
  ……
}  
```

​	再追一下`SetChannelAttribute`以及`SetChannelAttribute`方法：

```C++
void 
CsmaHelper::SetDeviceAttribute (std::string n1, const AttributeValue &v1)
{
  m_deviceFactory.Set (n1, v1);
}

void 
CsmaHelper::SetChannelAttribute (std::string n1, const AttributeValue &v1)
{
  m_channelFactory.Set (n1, v1);
}
```

​	可以看到，这几行代码声明了一个`CsmatHelper`类的csma连接信道，并通过调用`SetDeviceAttribute`以及`SetChannelAttribute`由“工厂”设置了信道的传输速率为100Mbps，信道延迟为6560ns。

​	但有个疑问，first.cc里的点对点助手的`SetChannelAttribute()`函数代码如下：

```C++
pointToPoint.SetChannelAttribute("Delay", StringValue("2ms"));
```

​	second.cc里csma助手的代码如下：

```C++
csma.SetChannelAttribute ("Delay", TimeValue (NanoSeconds (6560)));
```

​	可以看到，第二个参数不一样，前面我们也都分析过了，这两个方法都是通过向“工厂”传数据，带着这个疑问，修改second.cc里的信道延迟的参数：

```C++
csma.SetChannelAttribute ("Delay", StringValue("6560ns"));
```

​	修改之后编译运行，发现编译通过，运行结果与修改之前的结果也一样。推断这两种写法都可以。

​	同样的问题，first.cc中echoClient的代码是这样的：

```C++
echoClient.SetAttribute("Interval", TimeValue(Seconds(1.0)));
```

​	以同样的方式修改：

```C++
echoClient.SetAttribute("Interval", StringValue("1.0s"));
```

​	然后编译运行，发现同样编译通过，结果也一样。

​	

​	还有个疑问：点对点连接的设置属性的代码是这样：

```C++
pointToPoint.SetDeviceAttribute("DataRate", StringValue("5Mbps"));
pointToPoint.SetChannelAttribute("Delay", StringValue("2ms"));
```

​	csma连接设置属性的代码是这样：

```C++
csma.SetChannelAttribute("DataRate", StringValue("100Mbps"));
csma.SetChannelAttribute("Delay", TimeValue(NanoSeconds(6560)));
```

​	可以看到，点对点连接的数据速率是由`SetDeviceAttribute()`函数设置的，但csma连接的数据速率是由`SetChannelAttribute()`函数设置的，尝试修改first.cc的数据速率由`SetChannelAttribute()`函数设置，编译运行，发现无法编译通过。同样尝试修改second.cc的数据速率由`SetDeviceAttribute()`函数设置，编译运行发现同样无法编译通过。这里猜测是因为点对点连接是两点之间的连接，但csma网络不允许同一个信道上有多个不同数据速率的设备。

​	

* 76-77行代码：

```C++
NetDeviceContainer csmaDevices;
csmaDevices = csma.Install (csmaNodes);
```

​	创建了csma的网络设备容器，并为csma节点容器内的每一个节点安装网络设备。

​	注意：之前因为我们把点对点连接的1号节点加入了csma节点容器，此时点对点节点容器的1号节点（也是csma节点容器的0号节点）将同时具备点对点连接网络设备以及csma网络设备。

​	

* 79-81行代码：

```C++
InternetStackHelper stack;
stack.Install (p2pNodes.Get (0));
stack.Install (csmaNodes);
```

​	为节点安装协议栈，因为我们将点对点容器中的1号节点加入到了csma节点中，所以对点对点的0号节点，以及整个csma节点容器内的节点安装，即可完成对所有节点的协议栈安装。

​	

* 83-90行代码

```C++
Ipv4AddressHelper address;
address.SetBase ("10.1.1.0", "255.255.255.0");
Ipv4InterfaceContainer p2pInterfaces;
p2pInterfaces = address.Assign (p2pDevices);

address.SetBase ("10.1.2.0", "255.255.255.0");
Ipv4InterfaceContainer csmaInterfaces;
csmaInterfaces = address.Assign (csmaDevices);
```

​	用ipv4助手设置点对点设备以及csma设备所需的ip地址，子网掩码，并用ipv4接口容器存放分配好地址的网络设备。

​	

* 92-96行代码：

```C++
UdpEchoServerHelper echoServer (9);

ApplicationContainer serverApps = echoServer.Install (csmaNodes.Get (nCsma));
serverApps.Start (Seconds (1.0));
serverApps.Stop (Seconds (10.0));
```

​	定义了Udp回声服务器，并指定了端口号为9。通过Udp回声服务器的`Install()`方法将回声服务器安装在最右侧节点上（csma节点容器中0号节点为点对点连接的1号节点，1号节点为csma的0号节点，2号节点为csma的1号节点，3号节点为csma的2号节点，刚好是最后一个节点，所以这里的节点号就是nCsma）。将安装了回声服务器的节点用应用容器保存，并设置回声服务器在模拟开始1秒后启动，10秒之后停止。

​	

* 98-101行代码

```C++
UdpEchoClientHelper echoClient (csmaInterfaces.GetAddress (nCsma), 9);
echoClient.SetAttribute ("MaxPackets", UintegerValue (1));
echoClient.SetAttribute ("Interval", TimeValue (Seconds (1.0)));
echoClient.SetAttribute ("PacketSize", UintegerValue (1024));
```

​	为udp回声客户端指定向csma接口序号为nCsma的地址的9号端口发送消息。并采用`UdpEchoClientHelper`的`SetAttribute()`方法设置发送数据包个数，发送数据包间隔及数据包的大小。

​	

* 103-105行代码：

```C++
ApplicationContainer clientApps = echoClient.Install (p2pNodes.Get (0));
clientApps.Start (Seconds (2.0));
clientApps.Stop (Seconds (10.0));
```

​	如服务器那样用`Install()`方法将客户端安装在点对点节点容器的第0号节点上，并用应用程序容器存放安装结束的结果。设置Udp回声客户端在模拟启动后2秒启动，10秒停止。

​	

* 107行代码：

```C++
Ipv4GlobalRoutingHelper::PopulateRoutingTables ();
```

​	追一下`Ipv4GlobalRoutingHelper`这个类：

```C++
//ipv4-global-routing-helper.h
class Ipv4GlobalRoutingHelper  : public Ipv4RoutingHelper
{
public:
  /**
   * \brief Construct a GlobalRoutingHelper to make life easier for managing
   * global routing tasks.
   */
  Ipv4GlobalRoutingHelper ();
  ……
    /**
   * \brief Build a routing database and initialize the routing tables of
   * the nodes in the simulation.  Makes all nodes in the simulation into
   * routers.
   *
   * All this function does is call the functions
   * BuildGlobalRoutingDatabase () and  InitializeRoutes ().
   *
   */
  static void PopulateRoutingTables (void);
  ……
}
```

​	再追`Ipv4GlobalRoutingHelper::PopulateRoutingTables()`这个函数：

```C++
//ipv4-global-routing-helper.cc
void 
Ipv4GlobalRoutingHelper::PopulateRoutingTables (void)
{
  GlobalRouteManager::BuildGlobalRoutingDatabase ();
  GlobalRouteManager::InitializeRoutes ();
}
```

​	再追`GlobalRouteManager::BuildGlobalRoutingDatabase()`以及`GlobalRouteManager::InitializeRoutes()`这两个函数：

```C++
//globol-route-manager.cc
void
GlobalRouteManager::BuildGlobalRoutingDatabase (void) 
{
  NS_LOG_FUNCTION_NOARGS ();
  SimulationSingleton<GlobalRouteManagerImpl>::Get ()->
  BuildGlobalRoutingDatabase ();
}

void
GlobalRouteManager::InitializeRoutes (void)
{
  NS_LOG_FUNCTION_NOARGS ();
  SimulationSingleton<GlobalRouteManagerImpl>::Get ()->
  InitializeRoutes ();
}
```

```C++
//global-route-manager-impl.cc
//
// In order to build the routing database, we need to walk the list of nodes
// in the system and look for those that support the GlobalRouter interface.
// These routers will export a number of Link State Advertisements (LSAs)
// that describe the links and networks that are "adjacent" (i.e., that are
// on the other side of a point-to-point link).  We take these LSAs and put
// add them to the Link State DataBase (LSDB) from which the routes will 
// ultimately be computed.
//
void
GlobalRouteManagerImpl::BuildGlobalRoutingDatabase () 
{
  NS_LOG_FUNCTION (this);
//
// Walk the list of nodes looking for the GlobalRouter Interface.  Nodes with
// global router interfaces are, not too surprisingly, our routers.
//
  NodeList::Iterator listEnd = NodeList::End ();
  for (NodeList::Iterator i = NodeList::Begin (); i != listEnd; i++)
    {
      Ptr<Node> node = *i;

      Ptr<GlobalRouter> rtr = node->GetObject<GlobalRouter> ();
//
// Ignore nodes that aren't participating in routing.
//
      if (!rtr)
        {
          continue;
        }
//
// You must call DiscoverLSAs () before trying to use any routing info or to
// update LSAs.  DiscoverLSAs () drives the process of discovering routes in
// the GlobalRouter.  Afterward, you may use GetNumLSAs (), which is a very
// computationally inexpensive call.  If you call GetNumLSAs () before calling 
// DiscoverLSAs () will get zero as the number since no routes have been 
// found.
//
      Ptr<Ipv4GlobalRouting> grouting = rtr->GetRoutingProtocol ();
      uint32_t numLSAs = rtr->DiscoverLSAs ();
      NS_LOG_LOGIC ("Found " << numLSAs << " LSAs");

      for (uint32_t j = 0; j < numLSAs; ++j)
        {
          GlobalRoutingLSA* lsa = new GlobalRoutingLSA ();
//
// This is the call to actually fetch a Link State Advertisement from the 
// router.
//
          rtr->GetLSA (j, *lsa);
          NS_LOG_LOGIC (*lsa);
//
// Write the newly discovered link state advertisement to the database.
//
          m_lsdb->Insert (lsa->GetLinkStateId (), lsa); 
        }
    }
}


//-------------------------------------

//
// For each node that is a global router (which is determined by the presence
// of an aggregated GlobalRouter interface), run the Dijkstra SPF calculation
// on the database rooted at that router, and populate the node forwarding
// tables.
//
// This function parallels RFC2328, Section 16.1.1, and quagga ospfd
//
// This calculation yields the set of intra-area routes associated
// with an area (called hereafter Area A).  A router calculates the
// shortest-path tree using itself as the root.  The formation
// of the shortest path tree is done here in two stages.  In the
// first stage, only links between routers and transit networks are
// considered.  Using the Dijkstra algorithm, a tree is formed from
// this subset of the link state database.  In the second stage,
// leaves are added to the tree by considering the links to stub
// networks.
//
// The area's link state database is represented as a directed graph.
// The graph's vertices are routers, transit networks and stub networks.
//
// The first stage of the procedure (i.e., the Dijkstra algorithm)
// can now be summarized as follows. At each iteration of the
// algorithm, there is a list of candidate vertices.  Paths from
// the root to these vertices have been found, but not necessarily
// the shortest ones.  However, the paths to the candidate vertex
// that is closest to the root are guaranteed to be shortest; this
// vertex is added to the shortest-path tree, removed from the
// candidate list, and its adjacent vertices are examined for
// possible addition to/modification of the candidate list.  The
// algorithm then iterates again.  It terminates when the candidate
// list becomes empty. 
//
void
GlobalRouteManagerImpl::InitializeRoutes ()
{
  NS_LOG_FUNCTION (this);
//
// Walk the list of nodes in the system.
//
  NS_LOG_INFO ("About to start SPF calculation");
  NodeList::Iterator listEnd = NodeList::End ();
  for (NodeList::Iterator i = NodeList::Begin (); i != listEnd; i++)
    {
      Ptr<Node> node = *i;
//
// Look for the GlobalRouter interface that indicates that the node is
// participating in routing.
//
      Ptr<GlobalRouter> rtr = 
        node->GetObject<GlobalRouter> ();

      uint32_t systemId = Simulator::GetSystemId ();
      // Ignore nodes that are not assigned to our systemId (distributed sim)
      if (node->GetSystemId () != systemId) 
        {
          continue;
        }

//
// if the node has a global router interface, then run the global routing
// algorithms.
//
      if (rtr && rtr->GetNumLSAs () )
        {
          SPFCalculate (rtr->GetRouterId ());
        }
    }
  NS_LOG_INFO ("Finished SPF calculation");
}

//
// This method is derived from quagga ospf_spf_next ().  See RFC2328 Section 
// 16.1 (2) for further details.
//
// We're passed a parameter <v> that is a vertex which is already in the SPF
// tree.  A vertex represents a router node.  We also get a reference to the
// SPF candidate queue, which is a priority queue containing the shortest paths
// to the networks we know about.
//
// We examine the links in v's LSA and update the list of candidates with any
// vertices not already on the list.  If a lower-cost path is found to a
// vertex already on the candidate list, store the new (lower) cost.
//
void
GlobalRouteManagerImpl::SPFNext (SPFVertex* v, CandidateQueue& candidate)
{
  NS_LOG_FUNCTION (this << v << &candidate);

  SPFVertex* w = 0;
  GlobalRoutingLSA* w_lsa = 0;
  GlobalRoutingLinkRecord *l = 0;
  uint32_t distance = 0;
  uint32_t numRecordsInVertex = 0;
//
// V points to a Router-LSA or Network-LSA
// Loop over the links in router LSA or attached routers in Network LSA
//
  if (v->GetVertexType () == SPFVertex::VertexRouter)
    {
      numRecordsInVertex = v->GetLSA ()->GetNLinkRecords (); 
    }
  if (v->GetVertexType () == SPFVertex::VertexNetwork)
    {
      numRecordsInVertex = v->GetLSA ()->GetNAttachedRouters (); 
    }

  for (uint32_t i = 0; i < numRecordsInVertex; i++)
    {
// Get w_lsa:  In case of V is Router-LSA
      if (v->GetVertexType () == SPFVertex::VertexRouter) 
        {
          NS_LOG_LOGIC ("Examining link " << i << " of " << 
                        v->GetVertexId () << "'s " <<
                        v->GetLSA ()->GetNLinkRecords () << " link records");
//
// (a) If this is a link to a stub network, examine the next link in V's LSA.
// Links to stub networks will be considered in the second stage of the
// shortest path calculation.
//
          l = v->GetLSA ()->GetLinkRecord (i);
          NS_ASSERT (l != 0);
          if (l->GetLinkType () == GlobalRoutingLinkRecord::StubNetwork)
            {
              NS_LOG_LOGIC ("Found a Stub record to " << l->GetLinkId ());
              continue;
            }
//
// (b) Otherwise, W is a transit vertex (router or transit network).  Look up
// the vertex W's LSA (router-LSA or network-LSA) in Area A's link state
// database. 
//
          if (l->GetLinkType () == GlobalRoutingLinkRecord::PointToPoint)
            {
//
// Lookup the link state advertisement of the new link -- we call it <w> in
// the link state database.
//
              w_lsa = m_lsdb->GetLSA (l->GetLinkId ());
              NS_ASSERT (w_lsa);
              NS_LOG_LOGIC ("Found a P2P record from " << 
                            v->GetVertexId () << " to " << w_lsa->GetLinkStateId ());
            }
          else if (l->GetLinkType () == 
                   GlobalRoutingLinkRecord::TransitNetwork)
            {
              w_lsa = m_lsdb->GetLSA (l->GetLinkId ());
              NS_ASSERT (w_lsa);
              NS_LOG_LOGIC ("Found a Transit record from " << 
                            v->GetVertexId () << " to " << w_lsa->GetLinkStateId ());
            }
          else 
            {
              NS_ASSERT_MSG (0, "illegal Link Type");
            }
        }
// Get w_lsa:  In case of V is Network-LSA
      if (v->GetVertexType () == SPFVertex::VertexNetwork) 
        {
          w_lsa = m_lsdb->GetLSAByLinkData 
              (v->GetLSA ()->GetAttachedRouter (i));
          if (!w_lsa)
            {
              continue;
            }
          NS_LOG_LOGIC ("Found a Network LSA from " << 
                        v->GetVertexId () << " to " << w_lsa->GetLinkStateId ());
        }

// Note:  w_lsa at this point may be either RouterLSA or NetworkLSA
//
// (c) If vertex W is already on the shortest-path tree, examine the next
// link in the LSA.
//
// If the link is to a router that is already in the shortest path first tree
// then we have it covered -- ignore it.
//
      if (w_lsa->GetStatus () == GlobalRoutingLSA::LSA_SPF_IN_SPFTREE) 
        {
          NS_LOG_LOGIC ("Skipping ->  LSA "<< 
                        w_lsa->GetLinkStateId () << " already in SPF tree");
          continue;
        }
//
// (d) Calculate the link state cost D of the resulting path from the root to 
// vertex W.  D is equal to the sum of the link state cost of the (already 
// calculated) shortest path to vertex V and the advertised cost of the link
// between vertices V and W.
//
      if (v->GetLSA ()->GetLSType () == GlobalRoutingLSA::RouterLSA)
        {
          NS_ASSERT (l != 0);
          distance = v->GetDistanceFromRoot () + l->GetMetric ();
        }
      else
        {
          distance = v->GetDistanceFromRoot ();
        }

      NS_LOG_LOGIC ("Considering w_lsa " << w_lsa->GetLinkStateId ());

// Is there already vertex w in candidate list?
      if (w_lsa->GetStatus () == GlobalRoutingLSA::LSA_SPF_NOT_EXPLORED)
        {
// Calculate nexthop to w
// We need to figure out how to actually get to the new router represented
// by <w>.  This will (among other things) find the next hop address to send
// packets destined for this network to, and also find the outbound interface
// used to forward the packets.

// prepare vertex w
          w = new SPFVertex (w_lsa);
          if (SPFNexthopCalculation (v, w, l, distance))
            {
              w_lsa->SetStatus (GlobalRoutingLSA::LSA_SPF_CANDIDATE);
//
// Push this new vertex onto the priority queue (ordered by distance from the
// root node).
//
              candidate.Push (w);
              NS_LOG_LOGIC ("Pushing " << 
                            w->GetVertexId () << ", parent vertexId: " <<
                            v->GetVertexId () << ", distance: " <<
                            w->GetDistanceFromRoot ());
            }
          else
            NS_ASSERT_MSG (0, "SPFNexthopCalculation never " 
                           << "return false, but it does now!");
        }
      else if (w_lsa->GetStatus () == GlobalRoutingLSA::LSA_SPF_CANDIDATE)
        {
//
// We have already considered the link represented by <w>.  What wse have to
// do now is to decide if this new router represents a route with a shorter
// distance metric.
//
// So, locate the vertex in the candidate queue and take a look at the 
// distance.

/* (quagga-0.98.6) W is already on the candidate list; call it cw.
* Compare the previously calculated cost (cw->distance)
* with the cost we just determined (w->distance) to see
* if we've found a shorter path.
*/
          SPFVertex* cw;
          cw = candidate.Find (w_lsa->GetLinkStateId ());
          if (cw->GetDistanceFromRoot () < distance)
            {
//
// This is not a shorter path, so don't do anything.
//
              continue;
            }
          else if (cw->GetDistanceFromRoot () == distance)
            {
//
// This path is one with an equal cost.
//
              NS_LOG_LOGIC ("Equal cost multiple paths found.");

// At this point, there are two instances 'w' and 'cw' of the
// same vertex, the vertex that is currently being considered
// for adding into the shortest path tree. 'w' is the instance
// as seen from the root via vertex 'v', and 'cw' is the instance 
// as seen from the root via some other vertices other than 'v'.
// These two instances are being merged in the following code.
// In particular, the parent nodes, the next hops, and the root's
// output interfaces of the two instances are being merged.
// 
// Note that this is functionally equivalent to calling
// ospf_nexthop_merge (cw->nexthop, w->nexthop) in quagga-0.98.6
// (ospf_spf.c::859), although the detail implementation
// is very different from quagga (blame ns3::GlobalRouteManagerImpl)

// prepare vertex w
              w = new SPFVertex (w_lsa);
              SPFNexthopCalculation (v, w, l, distance);
              cw->MergeRootExitDirections (w);
              cw->MergeParent (w);
// SPFVertexAddParent (w) is necessary as the destructor of 
// SPFVertex checks if the vertex and its parent is linked
// bidirectionally
              SPFVertexAddParent (w);
              delete w;
            }
          else // cw->GetDistanceFromRoot () > w->GetDistanceFromRoot ()
            {
// 
// this path represents a new, lower-cost path to <w> (the vertex we found in
// the current link record of the link state advertisement of the current root
// (vertex <v>)
//
// N.B. the nexthop_calculation is conditional, if it finds a valid nexthop
// it will call spf_add_parents, which will flush the old parents
//
              if (SPFNexthopCalculation (v, cw, l, distance))
                {
//
// If we've changed the cost to get to the vertex represented by <w>, we 
// must reorder the priority queue keyed to that cost.
//
                  candidate.Reorder ();
                }
            } // new lower cost path found
        } // end W is already on the candidate list
    } // end loop over the links in V's LSA
}

//
// This method is derived from quagga ospf_nexthop_calculation() 16.1.1.
//
// Calculate nexthop from root through V (parent) to vertex W (destination)
// with given distance from root->W.
//
// As appropriate, set w's parent, distance, and nexthop information
//
// For now, this is greatly simplified from the quagga code
//
int
GlobalRouteManagerImpl::SPFNexthopCalculation (
  SPFVertex* v, 
  SPFVertex* w,
  GlobalRoutingLinkRecord* l,
  uint32_t distance)
{
  NS_LOG_FUNCTION (this << v << w << l << distance);
//
// If w is a NetworkVertex, l should be null
/*
  if (w->GetVertexType () == SPFVertex::VertexNetwork && l)
    {
        NS_ASSERT_MSG (0, "Error:  SPFNexthopCalculation parameter problem");
    }
*/
```

​	可以看到，代码首先建立了一个全局路由数据库。然后遍历整个模拟的所有节点，根据迪杰斯特拉算法在整个模拟中生成最短路径的网络拓扑。每个节点的行为就像是一个OSPF路由器，该OSPF路由器与其他所有其他路由器进行了即时通信。 每个节点生成链路通告并直接传递给全局路由管理器，该管理器使用此全局信息为每个节点构造路由表。

​	由于我们这个案例实际上建立了一个多网段互联网络，因此我们需要某种形式的路由。NS3提供了所谓的全局路由来帮助我们，这使得我们搭建的整个互联网络都可以在仿真中访问。

​	

* 109-110行代码：

```C++
pointToPoint.EnablePcapAll ("second");
csma.EnablePcap ("second", csmaDevices.Get (1), true);
```

​	对点对点连接的全部设备启动PCAP追踪，对csma连接的1号设备（也就是csma节点容器的1号节点上的设备）启动PCAP追踪，这里第三个参数我们不知道什么意思，右键转到声明追一下：

```C++
//trace-helper.h
class PcapHelperForDevice
{
public:
  /**
   * @brief Construct a PcapHelperForDevice
   */
  PcapHelperForDevice () {}

  /**
   * @brief Destroy a PcapHelperForDevice
   */
  virtual ~PcapHelperForDevice () {}

  /**
   * @brief Enable pcap output the indicated net device.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param nd Net device for which you want to enable tracing.
   * @param promiscuous If true capture all possible packets available at the device.
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  virtual void EnablePcapInternal (std::string prefix, Ptr<NetDevice> nd, bool promiscuous, bool explicitFilename) = 0;

  /**
   * @brief Enable pcap output the indicated net device.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param nd Net device for which you want to enable tracing.
   * @param promiscuous If true capture all possible packets available at the device.
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  void EnablePcap (std::string prefix, Ptr<NetDevice> nd, bool promiscuous = false, bool explicitFilename = false);

  /**
   * @brief Enable pcap output the indicated net device using a device previously
   * named using the ns-3 object name service.
   *
   * @param prefix filename prefix to use for pcap files.
   * @param ndName The name of the net device in which you want to enable tracing.
   * @param promiscuous If true capture all possible packets available at the device.
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  void EnablePcap (std::string prefix, std::string ndName, bool promiscuous = false, bool explicitFilename = false);

  /**
   * @brief Enable pcap output on each device in the container which is of the 
   * appropriate type.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param d container of devices of type ns3::CsmaNetDevice
   * @param promiscuous If true capture all possible packets available at the device.
   */
  void EnablePcap (std::string prefix, NetDeviceContainer d, bool promiscuous = false);

  /**
   * @brief Enable pcap output on each device (which is of the appropriate type)
   * in the nodes provided in the container.
   *
   * \param prefix Filename prefix to use for pcap files.
   * \param n container of nodes.
   * \param promiscuous If true capture all possible packets available at the device.
   */
  void EnablePcap (std::string prefix, NodeContainer n, bool promiscuous = false);

  /**
   * @brief Enable pcap output on the device specified by a global node-id (of
   * a previously created node) and associated device-id.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param nodeid the node id
   * @param deviceid the device id
   * @param promiscuous If true capture all possible packets available at the device.
   */
  void EnablePcap (std::string prefix, uint32_t nodeid, uint32_t deviceid, bool promiscuous = false);

  /**
   * @brief Enable pcap output on each device (which is of the appropriate type)
   * in the set of all nodes created in the simulation.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param promiscuous If true capture all possible packets available at the device.
   */
  void EnablePcapAll (std::string prefix, bool promiscuous = false);
};
```

​	CSMA网络是一个多点对点网络。这意味着在共享介质上可以存在多个端点。这些端点中的每一个都有一个与之关联的网络设备。从这种网络收集跟踪信息有两种基本的选择：一种方法是为每个网络设备创建跟踪文件，并仅存储该网络设备发出或使用的数据包。另一种方法是选择其中一个设备并将其置于混杂模式。然后，该单个设备“嗅探”网络中的所有数据包，并将它们存储在单个pcap文件中。例如，tcpdump就是这样工作的。第一个参数是我们要生成的文件的前缀，第二个参数是要激活PCAP的网络设备，第三个参数告诉csma助手程序是否以混杂模式捕获数据包（默认false，可以空着），第四个参数是否将第一个参数当作显式文件名（默认false，可以空着）。

​	这里要求csma设备容器中的1号设备启用混杂嗅探，从而模拟tcpdump的功能。

​	

* 112-114行代码：

```C++
Simulator::Run ();
Simulator::Destroy ();
return 0;
```

​	启动模拟，并销毁模拟。程序结束。

​	

#### 3.5.2 编译运行

​	下面来运行代码：

​	由于我们之前在first.cc里设置过环境变量，首先清空环境变量：

```shell
$ export NS_LOG=
```

​	可以通过

```shell
$ export -p
```

​	来查看自己的环境变量。

​	下面编译运行：

```shell
$ ./waf --run scratch/second
```

​	运行结果如下：

![image-20200825000644872](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBz42ZAgjGBAjuhyBl7EpPyMDhj4IGqQdAcy4q.BuP0wW.tWxy4ohfrXK*1ve0nzS3B4ElARJfcra7xJFOukOsM!/r)

​	在2s时Udp回声客户端向10.1.2.4的9号端口发送了1024字节的数据包，在2.0078秒Udp回声服务器收到来自于10.1.1.1的49153端口的1024字节大小的数据包。同一时刻向10.1.1.1的49153端口应答发送1024字节的数据包，2.01761秒Udp回升客户端收到来自10.1.2.4的9号端口发送的1024字节大小数据包。

​	同样在ns3的安装目录中，我们也可以看到以下三个追踪包：

![image-20200825001329176](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBHdaRUQKgS6vJkmMxEYyCMK0NZQw5f11TnpLeoM5QvxdSXrvuUVhYsQweslyaKhQgvHXHXO0OqRIokjuxRPn3A!/r)

​	命名依然遵循`前缀-节点号-设备号`的规则。回想一下，我们对点对点设备都启用了PCAP追踪，所以节点0、节点1会出现，我们对csma的节点2上的设备启用了混杂模式的嗅探，也就是2号节点。当然除了既是点对点节点又是csma节点的节点1，其他设备都只有1个设备。且节点1的1号设备是csma设备，由于我们在csma设备中只对节点2的设备启用了PCAP，所以节点1的1号设备在这里没有出现。

​	首先读取最左侧节点0号设备的pcap文件：

```shell
$ tcpdump -nn -tt -r second-0-0.pcap
```

​	输出如下：

![image-20200825002231504](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPueUpyz*1B*GFzkP9KiBdsWt62P4sCdZzhOHxCIvqgOT9oGKirOhlpDUIfA5xpFA4JKITNi68WFOK6Lhv8H134!/r)

​	可以看到，在2秒时10.1.1.1的49153端口向10.1.2.4的9号端口发送了Udp类型的1024字节的数据包，2.17607秒时10.1.1.1的49153端口收到了10.1.2.4的回显数据包。

​	

​	再读取节点1的0号设备的pcap文件：

```shell
$ tcpdump -nn -tt -r second-1-0.pcap
```

​	输出如下：

![image-20200825003228918](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEA9pj07xxPfSQCAMr1dAuxO4Ce1xJmidnuqmq5A1e0LuEk6nP97OH8KLiCbl1Wk6qmmADE9b7QKQJ0wY.qIstXI!/r)

​	可以看到，在2.003686秒时节点1收到了10.1.1.1的49153端口向10.1.2.4的9号端口发送的Udp类型的1024字节的数据包，并将其转发出去。2.013921秒时节点1收到了10.1.2.4的9号端口发往10.1.1.1的49153端口的回显数据包。

​	

​	最后读取节点2的0号设备的pcap文件：

```shell
$ tcpdump -nn -tt -r second-2-0.pcap
```

​	输出如下：

![image-20200825194724207](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEJ3VbuQ6MV.XhawsR5tdCgdp39XETPlSR4*mHwu7h.ZmovDxnP95DJGjMGSaAfuz9XZKZeQHLKhTvIgv66CSv*k!/r)

​	可以看到，输出的东西比前面多很多。链接类型现在为“以太网”。  总线网络需要ARP（地址解析协议）。 节点1知道它需要将数据包发送到IP地址10.1.2.4，但是它不知道相应节点的MAC地址。 它在整个CSMA网络上广播，询问IP地址为10.1.2.4的设备。 在这种情况下，最右边的节点回答说它位于MAC地址00:00:00:00:00:06。 虽然我们能看到这一过程，但节点2不直接参与此交换。是因为我们在前面设置了让它在嗅探网络并报告它看到的所有流量。同样，回显的数据包也是节点1通过ARP询问节点0的MAC地址从而传过去的。由于发送数据包是按照节点0-节点1-最后一个节点，所以我们在second-0-0.pcap看到2秒发送了数据包。而数据包又经过节点1，所以在second-1-0.pcap中看到2.003686秒数据包到达节点1，而节点2不参与数据交换，我们在second-2-0.pcap中看到的2.007803秒实际上是最右侧节点收到数据包的时间。回发数据包也是同理，先在second-2-0.pcap中看到了数据包到达节点1的时间为2.013921秒（在second-1-0.pcap同样可以看到），最后在second-0-0.pcap中看到2.013921秒数据包到达节点0。

​	注：ARP（地址解析协议、Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。

​	

​	最后，在程序的开始以及first.cc扩展中，我们添加了通过命令行参数控制仿真中CSMA节点数量的功能。 可以以与更改first.cc示例中回显的数据包数量相同的方式更改此参数。 将CSMA节点的数量设置为四个的情况下运行程序：

```shell
$ ./waf --run "scratch/second --nCsma=4"
```

​	运行结果如下：

![image-20200825202612273](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEFd.wwgAcr0.k3vxFKsVQdZKT8nRus*Wxw5cgb9nD8w*jRKQzQva.ZpN7u.pYt32G6kqOqrfcVnKaaq7*P.BYWo!/r)

​	可以看到，Udp回声服务器现在已经位于10.1.2.5（最后一个节点）。不再是之前的10.1.2.4。

​	

##### 对单设备进行追踪

​	之前的CSMA网络的追踪方法是让一个设备嗅探整个网络的数据包存于一个pcap文件中。当我们只想得到某个网络设备自身接收与发送的数据流时，NS3程序提供了将节点号和设备号作为参数的方法（详见前面first.cc以及second.cc的PCAP追踪部分）。利用下面的代码替换原来追踪点对点以及CSMA的两行代码：

```C++
pointToPoint.EnablePcap ("second", p2pNodes.Get (0)->GetId (), 0);
csma.EnablePcap ("second", csmaNodes.Get (nCsma)->GetId (), 0, false);
csma.EnablePcap ("second", csmaNodes.Get (nCsma-1)->GetId (), 0, false);
```

​	这里走的是方法：

```C++
//trace-helper.cc
void 
PcapHelperForDevice::EnablePcap (std::string prefix, uint32_t nodeid, uint32_t deviceid, bool promiscuous)
{
  NodeContainer n = NodeContainer::GetGlobal ();

  for (NodeContainer::Iterator i = n.Begin (); i != n.End (); ++i)
    {
      Ptr<Node> node = *i;
      if (node->GetId () != nodeid) 
        {
          continue;
        }

      NS_ABORT_MSG_IF (deviceid >= node->GetNDevices (), "PcapHelperForDevice::EnablePcap(): Unknown deviceid = " 
                       << deviceid);
      Ptr<NetDevice> nd = node->GetDevice (deviceid);
      EnablePcap (prefix, nd, promiscuous);
      return;
    }
}
```

​	其中第一个参数为前缀，第二个参数为节点号，第三个参数为设备号，第四个是否开启混杂嗅探模式（默认为否）。

​	再追一下节点容器.Get()这个方法：

```C++
//node-container.cc
Ptr<Node> 
NodeContainer::Get (uint32_t i) const
{
  return m_nodes[i];
}
```

​	再追一下GetID()这个方法：

```C++
//node.cc
uint32_t
Node::GetId (void) const
{
  NS_LOG_FUNCTION (this);
  return m_id;
}
```

​	可以看到，这两个方法结合起来先由Get()方法返回某一节点的地址，在通过GetID()返回这个节点的无符号32位整数形式的节点号。我们为了获得节点号，有两种选择：因为节点创建是按照从零开始单调递增的方式对节点进行编号。可以通过按照节点创建的顺序来“手动”计算该编号。文件开头的网络拓扑图中已经做了此操作，最后一个CSMA节点将是节点号nCsma +1。在规模比较大较大的仿真中，这样的方法可能会变得非常麻烦；另一种方法是通过上面节点容器的getID()方法。这样我们只需关心节点在节点容器的编号就可以，而不用全局去依次计算模拟中每一个节点的节点号。

​	

​	为了确保不会跟之前的数据搞混，用命令行清掉之前的.pcap以及.tr文件：

```shell
$ rm *.pcap
$ rm *.tr
```

​	可以通过ls命令来确认是否删除成功：

```shell
$ ls
```

​	下面通过命令行设置CSMA节点个数为100个：

```shell
$ ./waf --run "scratch/second --nCsma=100"
```

​	编译运行，输出如下：

![image-20200825213333960](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEALYTKuOYKziM32ywALPkN.vw8UaYi4fMNLsmEUNrCSgFnwWqv.EuLbJw0uLVKLIiLOR74EQwhMdyAz1eKRqu7I!/r)

​	并得到了以下3个pcap文件：

![image-20200825213645080](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEOI.qjjcdEOgmGR4AYRiBqsQmWH8NM1TCabFugkVd*Bg*Iq2g64yuPRgDPJlFud5mUbs*aSJFLgivTlX20leUzU!/r)

​	追踪文件second-0-0.pcap来自最左侧的点对点设备，它是数据包的来源。 文件second-101-0.pcap对应于Udp回声服务器所在的最右边的CSMA设备。 在Udp回声服务器节点上启用pcap跟踪的调用中的最后一个参数为false。 这意味着在该节点上收集的追踪信息处于非混杂嗅探模式。

​	为了说明混杂嗅探模式和非混杂嗅探之间的区别，我们也把最右侧倒数第二个节点设置成了非混杂嗅探。 查看second-100-0.pcap：

```shell
$ tcpdump -nn -tt -r second-100-0.pcap
```

​	输出如下：

![image-20200825214343614](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBd8VZ6izdkbzxYPb6kRudOCyqS5H326u0QIhMKaV9vpIpT3kVJ2SqHeVzwXDIwK9vAPIa7aqc5h3*0xTBF5Qm8!/r)

​	可以看到，CSMA网络的倒数第二个节点在这个数据交换中是一个旁观者，因为没有看到数据包的信息。它收到的只有CSMA网络的第一个节点广播的ARP请求。

​	再看一下second-101-0.pcap：

```shell
$ tcpdump -nn -tt -r second-101-0.pcap
```

​	输出如下：

![image-20200825215357724](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEAGSbqmKma.cvt1xZWV1Xjvygh*7.NvbcP2l2YWqEK*AF8tXdMQEejD7JDo*Ecb3JvbyD3Gx3t2valox0KByOTc!/r)

​	可以看到，出现了数据包的发送以及ARP回应的信息，但一开始我们将这两个节点都设置成了非混杂嗅探模式，所以实际上这个节点真正参与了数据的交换（事实也如此，这是Server所在的节点）。

​	

##### 模型、属性以及现实

​	无论何时使用模拟，准确地了解正在建模的内容和未建模的内容都是很重要的。例如，我们刚才使用的CSMA设备和信道，就好像它们是真正的以太网设备一样。并期望仿真结果能够直接反映出实际网络中将要发生的情况。但有时事实并非如此。

​	根据定义，模型是对现实的抽象。模型的作者最终有责任确定整个模型中所谓的“精度范围”和“适用范围”，从而确定仿真的组成部分。

​	在某些情况下，例如CSMA，很容易确定未建模的内容。通过阅读头文件（csma.h）可以发现CSMA模型中并没有碰撞检测（CD），并确定其在模拟中的适用性或您希望在结果中包括哪些警告。在其他情况下，配置与实际设备的现实不符的行为可能非常容易。花一些时间研究一些这样的实例以及在仿真中如何轻松地将仿真脱离现实，将会是值得的。

​	NS3提供了让用户可以轻松设置以更改模型行为的属性。考虑CsmaNetDevice的两个属性：MTU和EncapsulationMode。 MTU属性指示设备的最大传输单位。这是设备可以发送的最大协议数据单元（PDU）的大小。

​	CsmaNetDevice中的MTU默认为1500字节。此默认值对应于RFC 894中“在以太网上传输IP数据报的标准”中的数字。该数字实际上是从10Base5（全规格以太网）网络的最大数据包大小（1518字节）减去以太网数据包的DIX封装开销（18字节），最终将得到1500字节的最大可用数据大小（MTU）。人们还发现，IEEE 802.3网络的MTU为1492字节。这是因为LLC / SNAP封装给数据包增加了8个字节的额外开销。在这两种情况下，底层硬件能发送1518字节，但是并不能全部发送数据。

![fengzhuang](https://ss0.baidu.com/6ON1bjeh1BF3odCf/it/u=329741600,4028436989&fm=15&gp=0.jpg)

​	为了设置封装模式，CsmaNetDevice提供了一个名为EncapsulationMode的属性，该属性可以采用值DIX或LLC。这些分别对应于以太网和LLC/SNAP帧封装。

​	如果将MTU保留为1500字节并将封装模式更改为LLC，则结果将会使用LLC/SNAP帧封装1500字节的PDU，从而导致这个网络的数据包为1526字节。这在许多网络中都是非法的，因为以太网的每个数据包最多传输1518个字节。这很可能导致模拟无法完全反映我们所期望的现实。

​	更复杂的是，还存在巨型帧（1500<MTU<=9000字节）和超级巨型帧（MTU>9000字节），这些帧未经IEEE正式批准，但在某些高速（千兆位）网络中可用，并且网卡。可以将封装模式设置为DIX，并将CsmaNetDevice上的MTU属性设置为64000字节，甚至将与之关联的CSMA信道的数据速率设置为每秒10兆位。这实际上将建模出一个支持超大数据报的1980年代风格的“吸血鬼接头(vampire tap)”式10Base5网络制成的以太网。这当然是我们在现实中不曾做过又不会做的，但是配置起来非常容易。

> 注：吸血鬼接头，也叫穿刺线夹。用于在10Base5的总线拓扑结构中将收发器连接到主干粗同轴电缆的连接器。与切断同轴电缆将连接器连接到同轴电缆中的方式不同，吸血鬼接头刺穿电缆的绝缘层，并与主干的粗同轴电缆的导电芯直接接触，使得在不切断主干电缆的前提下可以接出一个分支来。因为穿刺钉像吸血鬼的牙齿，而这种结构整体看来就像一个吸血鬼在“吸”主干电缆上的“血”，故得名为“吸血鬼接头”。
>
> ​	长这样：
>
> ![image-20200826013159262](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEDK.kGSu3c974KFn8TmwGFXrU34WPh50Q9VUQl4J5KaGZTXFN3MS33BnSjn59eO9rlqnrBvEr2JClcLcQ7vRSek!/r)
>
>  
>
> ![image-20200826190122472](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEIF8wZT39oS5pS5mMQRulTNc3gVYaGuz.aSGHOgRcmvxMoQN.2NVAp2qRjlzGy7BPXlOsaaCcia*AezE0dg.hUQ!/r)



​	在上一个示例中，我们使用命令行创建了一个具有100个CSMA节点的仿真。也可以轻松地创建具有500个节点的仿真。如果我们实际上是对该10Base5吸血鬼接头式网络进行建模，则全规格以太网电缆的最大长度为500米，设备之间的最小间距为2.5米，这意味着在实际网络上只能有200个设备。可以很容易地以这种方式建立一个非法网络。根据我们要建模的内容，这可能会导致我们的模拟没有实际意义。

![image-20200826002642761](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEESZcmyY21IGP5MxQKngqibuu6NUxEkKDUfSi5wplBvu**5Otzj9Bx.hTIUA9tsP0XS0ZER90MXS7Rvp1dHWtj0!/r)

​	不仅是NS3的许多地方还是其他任何模拟器中都可能发生类似的情况：例如，我们能够以使节点同时占据相同空间的方式来定位节点，或者配置违反物理基本定律的放大器或噪声级。

​	NS3通常倾向于灵活性，许多模型将允许自由设置属性，而无需尝试强制执行任何任意一致性或特定的基础规范。

​	**（这一部分的翻译以及查询资料共花费了4小时，这个“吸血鬼接头”真的让人头大。）**

​	

### 3.6 third.cc

​	在本节中，我们将进一步扩展对NS3网络设备和信道的了解，以涵盖无线网络的示例。 NS3提供了一组802.11模型，这些模型尝试为我们提供符合802.11规范的精确MAC级别实现和符合802.11a规范的“不是太慢的” PHY级别模型。



#### 3.6.1 代码学习

​	让我们看一下third.cc，基于second.cc增加了wifi模块，打开scartch/third.cc，代码如下：

```C++
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include "ns3/core-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/network-module.h"
#include "ns3/applications-module.h"
#include "ns3/mobility-module.h"
#include "ns3/csma-module.h"
#include "ns3/internet-module.h"
#include "ns3/yans-wifi-helper.h"
#include "ns3/ssid.h"

// Default Network Topology
//
//   Wifi 10.1.3.0
//                 AP
//  *    *    *    *
//  |    |    |    |    10.1.1.0
// n5   n6   n7   n0 -------------- n1   n2   n3   n4
//                   point-to-point  |    |    |    |
//                                   ================
//                                     LAN 10.1.2.0

using namespace ns3;

NS_LOG_COMPONENT_DEFINE ("ThirdScriptExample");

int 
main (int argc, char *argv[])
{
  bool verbose = true;
  uint32_t nCsma = 3;
  uint32_t nWifi = 3;
  bool tracing = false;

  CommandLine cmd (__FILE__);
  cmd.AddValue ("nCsma", "Number of \"extra\" CSMA nodes/devices", nCsma);
  cmd.AddValue ("nWifi", "Number of wifi STA devices", nWifi);
  cmd.AddValue ("verbose", "Tell echo applications to log if true", verbose);
  cmd.AddValue ("tracing", "Enable pcap tracing", tracing);

  cmd.Parse (argc,argv);

  // The underlying restriction of 18 is due to the grid position
  // allocator's configuration; the grid layout will exceed the
  // bounding box if more than 18 nodes are provided.
  if (nWifi > 18)
    {
      std::cout << "nWifi should be 18 or less; otherwise grid layout exceeds the bounding box" << std::endl;
      return 1;
    }

  if (verbose)
    {
      LogComponentEnable ("UdpEchoClientApplication", LOG_LEVEL_INFO);
      LogComponentEnable ("UdpEchoServerApplication", LOG_LEVEL_INFO);
    }

  NodeContainer p2pNodes;
  p2pNodes.Create (2);

  PointToPointHelper pointToPoint;
  pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
  pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));

  NetDeviceContainer p2pDevices;
  p2pDevices = pointToPoint.Install (p2pNodes);

  NodeContainer csmaNodes;
  csmaNodes.Add (p2pNodes.Get (1));
  csmaNodes.Create (nCsma);

  CsmaHelper csma;
  csma.SetChannelAttribute ("DataRate", StringValue ("100Mbps"));
  csma.SetChannelAttribute ("Delay", TimeValue (NanoSeconds (6560)));

  NetDeviceContainer csmaDevices;
  csmaDevices = csma.Install (csmaNodes);

  NodeContainer wifiStaNodes;
  wifiStaNodes.Create (nWifi);
  NodeContainer wifiApNode = p2pNodes.Get (0);

  YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();
  YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();
  phy.SetChannel (channel.Create ());

  WifiHelper wifi;
  wifi.SetRemoteStationManager ("ns3::AarfWifiManager");

  WifiMacHelper mac;
  Ssid ssid = Ssid ("ns-3-ssid");
  mac.SetType ("ns3::StaWifiMac",
               "Ssid", SsidValue (ssid),
               "ActiveProbing", BooleanValue (false));

  NetDeviceContainer staDevices;
  staDevices = wifi.Install (phy, mac, wifiStaNodes);

  mac.SetType ("ns3::ApWifiMac",
               "Ssid", SsidValue (ssid));

  NetDeviceContainer apDevices;
  apDevices = wifi.Install (phy, mac, wifiApNode);

  MobilityHelper mobility;

  mobility.SetPositionAllocator ("ns3::GridPositionAllocator",
                                 "MinX", DoubleValue (0.0),
                                 "MinY", DoubleValue (0.0),
                                 "DeltaX", DoubleValue (5.0),
                                 "DeltaY", DoubleValue (10.0),
                                 "GridWidth", UintegerValue (3),
                                 "LayoutType", StringValue ("RowFirst"));

  mobility.SetMobilityModel ("ns3::RandomWalk2dMobilityModel",
                             "Bounds", RectangleValue (Rectangle (-50, 50, -50, 50)));
  mobility.Install (wifiStaNodes);

  mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
  mobility.Install (wifiApNode);

  InternetStackHelper stack;
  stack.Install (csmaNodes);
  stack.Install (wifiApNode);
  stack.Install (wifiStaNodes);

  Ipv4AddressHelper address;

  address.SetBase ("10.1.1.0", "255.255.255.0");
  Ipv4InterfaceContainer p2pInterfaces;
  p2pInterfaces = address.Assign (p2pDevices);

  address.SetBase ("10.1.2.0", "255.255.255.0");
  Ipv4InterfaceContainer csmaInterfaces;
  csmaInterfaces = address.Assign (csmaDevices);

  address.SetBase ("10.1.3.0", "255.255.255.0");
  address.Assign (staDevices);
  address.Assign (apDevices);

  UdpEchoServerHelper echoServer (9);

  ApplicationContainer serverApps = echoServer.Install (csmaNodes.Get (nCsma));
  serverApps.Start (Seconds (1.0));
  serverApps.Stop (Seconds (10.0));

  UdpEchoClientHelper echoClient (csmaInterfaces.GetAddress (nCsma), 9);
  echoClient.SetAttribute ("MaxPackets", UintegerValue (1));
  echoClient.SetAttribute ("Interval", TimeValue (Seconds (1.0)));
  echoClient.SetAttribute ("PacketSize", UintegerValue (1024));

  ApplicationContainer clientApps = 
    echoClient.Install (wifiStaNodes.Get (nWifi - 1));
  clientApps.Start (Seconds (2.0));
  clientApps.Stop (Seconds (10.0));

  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();

  Simulator::Stop (Seconds (10.0));

  if (tracing == true)
    {
      pointToPoint.EnablePcapAll ("third");
      phy.EnablePcap ("third", apDevices.Get (0));
      csma.EnablePcap ("third", csmaDevices.Get (0), true);
    }

  Simulator::Run ();
  Simulator::Destroy ();
  return 0;
}

```

​	下面进行详细学习：

* 1-15行代码：

```C++
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
```

​	仍然是程序的版权信息，代码模式等等。

​	

* 17-25行代码：

```C++
#include "ns3/core-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/network-module.h"
#include "ns3/applications-module.h"
#include "ns3/mobility-module.h"
#include "ns3/csma-module.h"
#include "ns3/internet-module.h"
#include "ns3/yans-wifi-helper.h"
#include "ns3/ssid.h"
```

​	头文件，相比second.cc，多了移动模型，wifi助手，ssid。

​	

* 27-36行代码：

```C++
// Default Network Topology
//
//   Wifi 10.1.3.0
//                 AP
//  *    *    *    *
//  |    |    |    |    10.1.1.0
// n5   n6   n7   n0 -------------- n1   n2   n3   n4
//                   point-to-point  |    |    |    |
//                                   ================
//                                     LAN 10.1.2.0
```

​	可以看到，在点对点网络左边，我们添加了10.1.3.0的WiFi网络。其中n0为AP节点，n5、6、7为STA节点。与nCsma相似，我们可以通过设置nWifi来控制在仿真中出现的STA节点数。在仿真中一定存在一个AP节点！

​	

* 38-40行代码：

```C++
using namespace ns3;

NS_LOG_COMPONENT_DEFINE ("ThirdScriptExample");
```

​	声明命名空间，以及日志记录组件名称。

​	

* 42-56行代码：

```C++
int 
main (int argc, char *argv[])
{
  bool verbose = true;
  uint32_t nCsma = 3;
  uint32_t nWifi = 3;
  bool tracing = false;

  CommandLine cmd (__FILE__);
  cmd.AddValue ("nCsma", "Number of \"extra\" CSMA nodes/devices", nCsma);
  cmd.AddValue ("nWifi", "Number of wifi STA devices", nWifi);
  cmd.AddValue ("verbose", "Tell echo applications to log if true", verbose);
  cmd.AddValue ("tracing", "Enable pcap tracing", tracing);

  cmd.Parse (argc,argv);
```

​	进入主函数，主函数内声明了bool型变量verbose（初值为真），用verbose控制Server以及Client的日志组件。当verbose为真时（默认为真），启用Server以及Client的日志组件。

​	其次定义了右侧CSMA节点数量的变量以及左侧WIFI节点的STA节点数（初值为3），以及定义了bool型变量tracing（初值为假），tracing为真时，启用PCAP追踪。

​	然后声明了命令行解析器，为解析器添加了以上变量的说明以及名称，最后读取命令行参数。

​	

* 58-65行代码：

```C++
// The underlying restriction of 18 is due to the grid position
// allocator's configuration; the grid layout will exceed the
// bounding box if more than 18 nodes are provided.
if (nWifi > 18)
  {
    std::cout << "nWifi should be 18 or less; otherwise grid layout exceeds the bounding box" << std::endl;
    return 1;
  }
```

​	判断了STA节点的个数不能超过18，这是由于网格位置分配器的配置而引起的。 如果超过了18个个节点，则网格布局将超出边界框。在这里如果超过了18，则输出提示信息，停止模拟。

​	

* 67-71行代码：

```C++
if (verbose)
  {
    LogComponentEnable ("UdpEchoClientApplication", LOG_LEVEL_INFO);
    LogComponentEnable ("UdpEchoServerApplication", LOG_LEVEL_INFO);
  }
```

​	用verbose来控制日志组件的启用，如果为真，则启用Udp回声服务器以及客户端的日志组件。

​	

* 73-74行代码：

```C++
NodeContainer p2pNodes;
p2pNodes.Create (2);
```

​	创建了点对点节点的容器，并创建两个节点。

​	

* 76-78行代码：

```C++
PointToPointHelper pointToPoint;
pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));
```

​	用点对点助手定义了一个点对点连接，并设置数据速率为5Mbps，延迟为2ms。

​	

* 80-81行代码：

```C++
NetDeviceContainer p2pDevices;
p2pDevices = pointToPoint.Install (p2pNodes);
```

​	创建了点对点节点的网络设备容器，为点对点节点安装网络设备后由定义的网络设备容器进行接收。

​	

* 83-85行代码：

```C++
NodeContainer csmaNodes;
csmaNodes.Add (p2pNodes.Get (1));
csmaNodes.Create (nCsma);
```

​	创建右侧CSMA节点的节点容器，首先将点对点容器内的节点1加入容器，又创建了nCsma个节点。

​	

* 87-89行代码：

```C++
CsmaHelper csma;
csma.SetChannelAttribute ("DataRate", StringValue ("100Mbps"));
csma.SetChannelAttribute ("Delay", TimeValue (NanoSeconds (6560)));
```

​	用CSMA助手创建右侧CSMA节点的连接，并设置了数据速率为100Mbps，延迟为6560ns。

​	

* 91-92行代码：

```C++
NetDeviceContainer csmaDevices;
csmaDevices = csma.Install (csmaNodes);
```

​	创建了CSMA的网络设备容器，为CSMA节点安装网络设备并由定义的网络设备容器接收。

​	

* 94-96行代码：

```C++
NodeContainer wifiStaNodes;
wifiStaNodes.Create (nWifi);
NodeContainer wifiApNode = p2pNodes.Get (0);
```

​	创建了WIFI STA节点的节点容器，并创建了nWifi个节点。创建了WIFI AP节点，并将点对点容器内的节点0加入该容器。

​	

* 98-100行代码：

```C++
YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();
YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();
phy.SetChannel (channel.Create ());
```

​	出现了新类`YansWifiChannelHelper`以及`YansWifiPhyHelper`，追一下：

```C++
//yans-wifi-helper.h
class YansWifiChannelHelper
{
public:
  /**
   * Create a channel helper without any parameter set. The user must set
   * them all to be able to call Create later.
   */
  YansWifiChannelHelper ();

  /**
   * Create a channel helper in a default working state. By default, we create
   * a channel model with a propagation delay equal to a constant, the speed of light,
   * and a propagation loss based on a log distance model with a reference loss of 46.6777 dB
   * at reference distance of 1m.
   * \returns YansWifiChannelHelper
   */
  static YansWifiChannelHelper Default (void);
  ……
    /**
   * \returns a new channel
   *
   * Create a channel based on the configuration parameters set previously.
   */
  Ptr<YansWifiChannel> Create (void) const;
  ……
}
```

```C++
//yans-wifi-helper.cc
YansWifiChannelHelper
YansWifiChannelHelper::Default (void)
{
  YansWifiChannelHelper helper;
  helper.SetPropagationDelay ("ns3::ConstantSpeedPropagationDelayModel");
  helper.AddPropagationLoss ("ns3::LogDistancePropagationLossModel");
  return helper;
}

void
YansWifiChannelHelper::AddPropagationLoss (std::string type,
                                           std::string n0, const AttributeValue &v0,
                                           std::string n1, const AttributeValue &v1,
                                           std::string n2, const AttributeValue &v2,
                                           std::string n3, const AttributeValue &v3,
                                           std::string n4, const AttributeValue &v4,
                                           std::string n5, const AttributeValue &v5,
                                           std::string n6, const AttributeValue &v6,
                                           std::string n7, const AttributeValue &v7)
{
  ObjectFactory factory;
  factory.SetTypeId (type);
  factory.Set (n0, v0);
  factory.Set (n1, v1);
  factory.Set (n2, v2);
  factory.Set (n3, v3);
  factory.Set (n4, v4);
  factory.Set (n5, v5);
  factory.Set (n6, v6);
  factory.Set (n7, v7);
  m_propagationLoss.push_back (factory);
}

void
YansWifiChannelHelper::SetPropagationDelay (std::string type,
                                            std::string n0, const AttributeValue &v0,
                                            std::string n1, const AttributeValue &v1,
                                            std::string n2, const AttributeValue &v2,
                                            std::string n3, const AttributeValue &v3,
                                            std::string n4, const AttributeValue &v4,
                                            std::string n5, const AttributeValue &v5,
                                            std::string n6, const AttributeValue &v6,
                                            std::string n7, const AttributeValue &v7)
{
  ObjectFactory factory;
  factory.SetTypeId (type);
  factory.Set (n0, v0);
  factory.Set (n1, v1);
  factory.Set (n2, v2);
  factory.Set (n3, v3);
  factory.Set (n4, v4);
  factory.Set (n5, v5);
  factory.Set (n6, v6);
  factory.Set (n7, v7);
  m_propagationDelay = factory;
}

Ptr<YansWifiChannel>
YansWifiChannelHelper::Create (void) const
{
  Ptr<YansWifiChannel> channel = CreateObject<YansWifiChannel> ();
  Ptr<PropagationLossModel> prev = 0;
  for (std::vector<ObjectFactory>::const_iterator i = m_propagationLoss.begin (); i != m_propagationLoss.end (); ++i)
    {
      Ptr<PropagationLossModel> cur = (*i).Create<PropagationLossModel> ();
      if (prev != 0)
        {
          prev->SetNext (cur);
        }
      if (m_propagationLoss.begin () == i)
        {
          channel->SetPropagationLossModel (cur);
        }
      prev = cur;
    }
  Ptr<PropagationDelayModel> delay = m_propagationDelay.Create<PropagationDelayModel> ();
  channel->SetPropagationDelayModel (delay);
  return channel;
}
```

```C++
//yans-wifi-helper.h
/**
 * \brief Make it easy to create and manage PHY objects for the YANS model.
 *
 * The YANS PHY model is described in "Yet Another Network Simulator",
 * http://cutebugs.net/files/wns2-yans.pdf
 *
 * The Pcap and ASCII traces generated by the EnableAscii and EnablePcap methods defined
 * in this class correspond to PHY-level traces and come to us via WifiPhyHelper
 *
 */
class YansWifiPhyHelper : public WifiPhyHelper
{
public:
  /**
   * Create a PHY helper without any parameter set. The user must set
   * them all to be able to call Install later.
   */
  YansWifiPhyHelper ();

  /**
   * Create a PHY helper in a default working state.
   * \returns a default YansWifiPhyHelper
   */
  static YansWifiPhyHelper Default (void);

  /**
   * \param channel the channel to associate to this helper
   *
   * Every PHY created by a call to Install is associated to this channel.
   */
  void SetChannel (Ptr<YansWifiChannel> channel);
  /**
   * \param channelName The name of the channel to associate to this helper
   *
   * Every PHY created by a call to Install is associated to this channel.
   */
  void SetChannel (std::string channelName);

private:
  /**
   * \param node the node on which we wish to create a wifi PHY
   * \param device the device within which this PHY will be created
   * \returns a newly-created PHY object.
   *
   * This method implements the pure virtual method defined in \ref ns3::WifiPhyHelper.
   */
  virtual Ptr<WifiPhy> Create (Ptr<Node> node, Ptr<NetDevice> device) const;

  Ptr<YansWifiChannel> m_channel; ///< YANS wifi channel
};
```

```C++
//yans-wifi-helper.cc
YansWifiPhyHelper::YansWifiPhyHelper ()
  : m_channel (0)
{
  m_phy.SetTypeId ("ns3::YansWifiPhy");
}

YansWifiPhyHelper
YansWifiPhyHelper::Default (void)
{
  YansWifiPhyHelper helper;
  helper.SetErrorRateModel ("ns3::NistErrorRateModel");
  return helper;
}

void
YansWifiPhyHelper::SetChannel (Ptr<YansWifiChannel> channel)
{
  m_channel = channel;
}

void
YansWifiPhyHelper::SetChannel (std::string channelName)
{
  Ptr<YansWifiChannel> channel = Names::Find<YansWifiChannel> (channelName);
  m_channel = channel;
}
```

​	看源码还是一头雾水，故去查了官网的WIFI模型：

![wifi](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBv0Cfg.Srpyac0y.d35BCCaeMLBoBi1fSmKAVQXJhXTNEDA260x1c68P8V7LDpb.m5t0eXZfdW9evDZuDXQ1wg!/r)

为了创建一个WifiNetDevice，用户主要需要配置五步：

​	1.配置WifiChannel：WifiChannel关系到信号在相同的信道上从一个设备到另一个设备。WifiChannel主要的配置是传播损耗模型和传播延时模型。

​	2.配置WifiPhy：WifiPhy关系到从WifiChannel发送和接收无线信号。这里，WifiPhy依赖于接收的信号的强度和噪声决定每一帧是否被成功解码。所以，WifiPhy的主要配置是误码率模型，该模型就是最后计算基于信号的成功解码帧的概率。

​	3.配置WifiMac：这一步更多的是与配置WIFI结构与设备等级有关。用户配置WIFI结构（例如adhoc or ap-sta）和是否支持Qos（802.11e），HT（802.11n），VHT（802.11ac）特性。

​	4.创建WifiDevice:在这一步，用户配置想要的wifi标准（例如802.11b,802.11g,802.11a,802.11n or 802.11ac）和速率控制算法。

​	5.配置mobility：mobility模型通常需要在WifiNetDevice可用之前配置。



​	**YansWifiChannelHelper**：YansWifiChannelHelper有一个不同寻常的名字。读者可能会疑惑为什么使用这样的名字。该模型是从yans simulator提取出来的，名字也是引用自它。该帮助类可以创建一个带有默认传播损耗模型（PropagationLoss）和传播延时模型（PropagationDelay）的WifiChannel。

​	**YansWifiPhyHelper**：物理层设备（基于ns3::WifiPhy）在NS3中是与ns3::WifiChannel相连接的。我们需要为YansWifiChannel创建合适的WifiPhy对象。这里YansWifiPhyHelper就可以胜任这个工作。YansWifiPhyHelper类配置了一个对象工厂来创建一个YansWifiPhy实例，并添加一些其他的对象到该实例中，包括可能补充的ErrorRateModel误码率模型和指向MobilityModel移动模型的指针。

​	**WifiMacHelper**：配置MAC模型。WifiMacHelper可以完成MAC low 模型和MAC high模型。用户必须决定采用哪种模型：802.11/WMM-style Qos，802.11n-style Hight throughput（HT），802.11ac-style Very High throughput（VHT）。

​	**WifiHelper**：配置速率控制算法。

​	

​	这样看完就知道大体思路了。这几行代码使用`YansWifiChannelHelper::Default()`和`YansWifiPhyHelper::Default()`方法分别配置信道以及物理层为默认参数。 然后创建一个信道对象并与PHY对象相连，以确保所有由YansWifiPhyHelper创建的物理层对象共享相同的底层信道，即它们共享相同的无线媒介并可以相互交流干预。

​	

* 102-103行代码：

```C++
WifiHelper wifi;
wifi.SetRemoteStationManager ("ns3::AarfWifiManager");
```

​	这里使用WIFI速率控制算法为ARRF。

真实设备的算法有：ArfWifiManager(WifiHelper的默认算法)【Automatic Rate Fallback(ARF) algorithm 自动速率回退算法 1997年】、OnoeWifiManager、ConstantRateWifiManager、MinstrelWifiManager

文献中的算法：IdealWifiManager、AarfWifiManager【2004年】、AmrrWifiManager、CaraWifiManager
RraaWifiManager【2006年】、AarfcdWifiManager、ParfWifiManager、AparfWifiManager

​	

* 105-109行代码：

```C++
WifiMacHelper mac;
Ssid ssid = Ssid ("ns-3-ssid");
mac.SetType ("ns3::StaWifiMac",
             "Ssid", SsidValue (ssid),
             "ActiveProbing", BooleanValue (false));
```

​	开始配置MAC层，首先用Ssid方法设置WIFI的SSID，设置MAC类型为`ns3::StaWifiMac`，将设置的SSID配置到MAC层上，而这里Qos没写，默认为false。这样我们即将创建的实例将会是基础结构BSS（即具有AP的BSS）中的非QoS非AP站（STA）。最后自动探测为false表示探测请求不会发送给由这个helper创建出来的MAC层。

此代码首先创建一个802.11服务集标识符（SSID）对象，该对象将用于设置MAC层实现的“Ssid”属性的值。辅助程序将创建的特定种类的MAC层由Attribute指定为“ns3::StaWifiMac”类型。默认情况下，WifiMacHelper对象的“QosSupported”属性设置为false。这两种配置的组合意味着下一个创建的MAC实例将是基础结构型BSS（即具有AP的BSS）中的非QoS非AP站（STA）。最后，“ActiveProbing”属性设置为false。这意味着探测请求将不会由此助手创建的MAC发送。

>概念解释：
>
>**基本服务集BSS（Basic Service Set）**，基本服务集的组成情况有两种：a.由一个接入点和若干个站点组成；b.由若干个站点组成，最少两个。为什么这样分呢？主要和802.11网络类型有关。有接入点的，称为基础结构型基本服务集（infrastructure BSS）；无接入点的，称为独立型基本服务集（Independent BSS，简称IBSS），IBSS也有其它的叫法，称为Ad Hoc Network。
>
>**服务集识别码SSID（Service Set IDentifier）**，当我们去到一个新地方的时候，开口第一句就是：“请问WIFI账号和密码是多少？”，这里的WIFI账号就是SSID。SSID是通过接入点广播出来了。同时，我们在设置无线路由器时，可修改SSID的名称。

​    

* 111-112行代码：

```C++
NetDeviceContainer staDevices;
staDevices = wifi.Install (phy, mac, wifiStaNodes);
```

​	追一下wifi助手的install方法：

```C++
//wifi-helper.cc
NetDeviceContainer
WifiHelper::Install (const WifiPhyHelper &phyHelper,
                     const WifiMacHelper &macHelper, NodeContainer c) const
{
  return Install (phyHelper, macHelper, c.Begin (), c.End ());
}

NetDeviceContainer
WifiHelper::Install (const WifiPhyHelper &phyHelper,
                     const WifiMacHelper &macHelper,
                     NodeContainer::Iterator first,
                     NodeContainer::Iterator last) const
{
  NetDeviceContainer devices;
  for (NodeContainer::Iterator i = first; i != last; ++i)
    {
      Ptr<Node> node = *i;
      Ptr<WifiNetDevice> device = CreateObject<WifiNetDevice> ();
      if (m_standard >= WIFI_PHY_STANDARD_80211n_2_4GHZ)
        {
          Ptr<HtConfiguration> htConfiguration = CreateObject<HtConfiguration> ();
          device->SetHtConfiguration (htConfiguration);
        }
      if ((m_standard == WIFI_PHY_STANDARD_80211ac) || (m_standard == WIFI_PHY_STANDARD_80211ax_5GHZ))
        {
          Ptr<VhtConfiguration> vhtConfiguration = CreateObject<VhtConfiguration> ();
          device->SetVhtConfiguration (vhtConfiguration);
        }
      if (m_standard >= WIFI_PHY_STANDARD_80211ax_2_4GHZ)
        {
          Ptr<HeConfiguration> heConfiguration = CreateObject<HeConfiguration> ();
          device->SetHeConfiguration (heConfiguration);
        }
      Ptr<WifiRemoteStationManager> manager = m_stationManager.Create<WifiRemoteStationManager> ();
      Ptr<WifiMac> mac = macHelper.Create (device);
      Ptr<WifiPhy> phy = phyHelper.Create (node, device);
      mac->SetAddress (Mac48Address::Allocate ());
      mac->ConfigureStandard (m_standard);
      phy->ConfigureStandard (m_standard);
      device->SetMac (mac);
      device->SetPhy (phy);
      device->SetRemoteStationManager (manager);
      node->AddDevice (device);
      if ((m_standard >= WIFI_PHY_STANDARD_80211ax_2_4GHZ) && (m_obssPdAlgorithm.IsTypeIdSet ()))
        {
          Ptr<ObssPdAlgorithm> obssPdAlgorithm = m_obssPdAlgorithm.Create<ObssPdAlgorithm> ();
          device->AggregateObject (obssPdAlgorithm);
          obssPdAlgorithm->ConnectWifiNetDevice (device);
        }
      devices.Add (device);
      NS_LOG_DEBUG ("node=" << node << ", mob=" << node->GetObject<MobilityModel> ());
      // Aggregate a NetDeviceQueueInterface object if a RegularWifiMac is installed
      Ptr<RegularWifiMac> rmac = DynamicCast<RegularWifiMac> (mac);
      if (rmac)
        {
          Ptr<NetDeviceQueueInterface> ndqi;
          BooleanValue qosSupported;
          PointerValue ptr;
          Ptr<WifiMacQueue> wmq;
          Ptr<WifiAckPolicySelector> ackSelector;

          rmac->GetAttributeFailSafe ("QosSupported", qosSupported);
          if (qosSupported.Get ())
            {
              ndqi = CreateObjectWithAttributes<NetDeviceQueueInterface> ("NTxQueues",
                                                                          UintegerValue (4));

              rmac->GetAttributeFailSafe ("BE_Txop", ptr);
              ackSelector = m_ackPolicySelector[AC_BE].Create<WifiAckPolicySelector> ();
              ackSelector->SetQosTxop (ptr.Get<QosTxop> ());
              ptr.Get<QosTxop> ()->SetAckPolicySelector (ackSelector);
              wmq = ptr.Get<QosTxop> ()->GetWifiMacQueue ();
              ndqi->GetTxQueue (0)->ConnectQueueTraces (wmq);

              rmac->GetAttributeFailSafe ("BK_Txop", ptr);
              ackSelector = m_ackPolicySelector[AC_BK].Create<WifiAckPolicySelector> ();
              ackSelector->SetQosTxop (ptr.Get<QosTxop> ());
              ptr.Get<QosTxop> ()->SetAckPolicySelector (ackSelector);
              wmq = ptr.Get<QosTxop> ()->GetWifiMacQueue ();
              ndqi->GetTxQueue (1)->ConnectQueueTraces (wmq);

              rmac->GetAttributeFailSafe ("VI_Txop", ptr);
              ackSelector = m_ackPolicySelector[AC_VI].Create<WifiAckPolicySelector> ();
              ackSelector->SetQosTxop (ptr.Get<QosTxop> ());
              ptr.Get<QosTxop> ()->SetAckPolicySelector (ackSelector);
              wmq = ptr.Get<QosTxop> ()->GetWifiMacQueue ();
              ndqi->GetTxQueue (2)->ConnectQueueTraces (wmq);

              rmac->GetAttributeFailSafe ("VO_Txop", ptr);
              ackSelector = m_ackPolicySelector[AC_VO].Create<WifiAckPolicySelector> ();
              ackSelector->SetQosTxop (ptr.Get<QosTxop> ());
              ptr.Get<QosTxop> ()->SetAckPolicySelector (ackSelector);
              wmq = ptr.Get<QosTxop> ()->GetWifiMacQueue ();
              ndqi->GetTxQueue (3)->ConnectQueueTraces (wmq);
              ndqi->SetSelectQueueCallback (m_selectQueueCallback);
            }
          else
            {
              ndqi = CreateObject<NetDeviceQueueInterface> ();

              rmac->GetAttributeFailSafe ("Txop", ptr);
              wmq = ptr.Get<Txop> ()->GetWifiMacQueue ();
              ndqi->GetTxQueue (0)->ConnectQueueTraces (wmq);
            }
          device->AggregateObject (ndqi);
        }
    }
  return devices;
}
```

​	可以看到，wifi助手的install方法的第一个参数是PHY层，第二个参数是MAC层，第三个参数是一个节点容器，采用迭代器循环为节点容器的每一个节点安装wifi模型。如点对点助手、CSMA助手一样，它的返回值也是安装之后的网络设备容器，我们只需声明一个网络设备容器接收即可。

​	

* 114-115行代码：

```C++
mac.SetType ("ns3::ApWifiMac",
             "Ssid", SsidValue (ssid));
```

​	我们已经为所有STA节点配置了WIFI，现在我们需要配置AP（接入点）节点。 我们通过更改WifiMacHelper的默认属性以反映AP的要求来开始此过程。这里已为STA节点安装完毕，故复用了WifiMacHelper。设置MAC层类型为ApWifiMac，设置了AP的SSID。

​	

* 117-118行代码：

```C++
NetDeviceContainer apDevices;
apDevices = wifi.Install (phy, mac, wifiApNode);
```

​	采用Wifi助手的install方法为wifiApNode节点容器的节点安装网络设备，并由定义的网络设备容器接收。因为前面我们创建物理层的时候就已经让所有节点都共享相同的底层信道能使得他们互相交流，所以这里我们在安装网络设备时依然要安装之前配置的PHY层。

​	

* 120-128行代码：

```C++
MobilityHelper mobility;

mobility.SetPositionAllocator ("ns3::GridPositionAllocator",
                               "MinX", DoubleValue (0.0),
                               "MinY", DoubleValue (0.0),
                               "DeltaX", DoubleValue (5.0),
                               "DeltaY", DoubleValue (10.0),
                               "GridWidth", UintegerValue (3),
                               "LayoutType", StringValue ("RowFirst"));
```

​	我们希望STA节点是可移动的（在边界框内四处游荡），并且希望使AP节点保持静止。 我们使用MobilityHelper来简化我们的工作。 首先，我们实例化MobilityHelper对象，并设置一些控制“位置分配器”功能的属性。首先使用二维网格来初始化STA节点。设置网格起点坐标的X、Y都为0，设置节点之间x轴、y轴的间隔为5.0，10.0，设置网格宽度为3，设置分配节点时布局类型为行优先（先分配行再分配列）。

​	

* 130-132行代码：

```C++
mobility.SetMobilityModel ("ns3::RandomWalk2dMobilityModel",
                           "Bounds", RectangleValue (Rectangle (-50, 50, -50, 50)));
mobility.Install (wifiStaNodes);
```

​	网格初始化完成后，配置节点的运动状态。`RandomWalk2dMobilityModel`为NS3自带的2d运动模型，bounds属性设置节点移动的边界。定义了一个100*100的正方形的边界，节点在这个边界内以任意方向任意速度运动。然后将移动模型绑定在STA节点上。

​	

* 134-135行代码：

```C++
mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
mobility.Install (wifiApNode);
```

​	我们希望AP节点是静止不动的，配置节点静止，然后将模型绑定在AP节点上。

​	

* 137-140行代码：

```C++
InternetStackHelper stack;
stack.Install (csmaNodes);
stack.Install (wifiApNode);
stack.Install (wifiStaNodes);
```

​	用网络协议栈助手为每个节点容器安装协议栈。

​	

* 142-154行代码：

```C++
Ipv4AddressHelper address;

address.SetBase ("10.1.1.0", "255.255.255.0");
Ipv4InterfaceContainer p2pInterfaces;
p2pInterfaces = address.Assign (p2pDevices);

address.SetBase ("10.1.2.0", "255.255.255.0");
Ipv4InterfaceContainer csmaInterfaces;
csmaInterfaces = address.Assign (csmaDevices);

address.SetBase ("10.1.3.0", "255.255.255.0");
address.Assign (staDevices);
address.Assign (apDevices);
```

​	设置点对点、CSMA、WIFI的基准地址，用ipv4助手的assign方法分配给对应网络设备，并用ipv4接口容器保存分派好地址的网络设备。

​	

* 156-160行代码：

```C++
UdpEchoServerHelper echoServer (9);

ApplicationContainer serverApps = echoServer.Install (csmaNodes.Get (nCsma));
serverApps.Start (Seconds (1.0));
serverApps.Stop (Seconds (10.0));
```

​	创建Udp回声服务器，指定端口号为9。将服务器安装在最右侧CSMA节点上，然后定义一个应用容器存放安装后的结果。并设置应用的启动时间为模拟开始后1秒，停止时间为模拟开始后10秒。

​	

* 162-165行代码：

```C++
UdpEchoClientHelper echoClient (csmaInterfaces.GetAddress (nCsma), 9);
echoClient.SetAttribute ("MaxPackets", UintegerValue (1));
echoClient.SetAttribute ("Interval", TimeValue (Seconds (1.0)));
echoClient.SetAttribute ("PacketSize", UintegerValue (1024));
```

​	创建Udp回声客户端，指定它向csma接口的第nCsma个地址的9号端口发送数据包，设置发送数据包个数为1个，设置发送数据包时间间隔为1秒，设置单个数据包大小为1024字节。

​	

* 167-170行代码：

```C++
ApplicationContainer clientApps = 
  echoClient.Install (wifiStaNodes.Get (nWifi - 1));
clientApps.Start (Seconds (2.0));
clientApps.Stop (Seconds (10.0));
```

​	将回声客户端安装在STA的最后一个节点。因为前面的nCsma的0号节点是点对点的1号节点，容器内共nCsma+1个节点，最后一个节点就是nCsma。而此处STA节点只有nWifi个，所以最后一个节点是nWifi-1。并设置客户端在模拟启动后2秒运行，模拟启动后10秒停止。

​	

* 172行代码：

```C++
Ipv4GlobalRoutingHelper::PopulateRoutingTables ();
```

​	因为我们这个拓扑是互联网络，需要路由协议。这里开启全局路由来保证拓扑网络通畅。

​	

* 174行代码：

```C++
Simulator::Stop (Seconds (10.0));
```

​	因为我们的WIFI会一直产生信标以及运动模型都是一直在运行的，所以我们要全局终止掉所有活动，否则会进入死循环，无法返回主函数。

​	

* 176-181行代码：

```C++
if (tracing == true)
  {
    pointToPoint.EnablePcapAll ("third");
    phy.EnablePcap ("third", apDevices.Get (0));
    csma.EnablePcap ("third", csmaDevices.Get (0), true);
  }
```

​	用变量tracing来控制是否启用PCAP追踪，在点对点连接的所有节点开启PCAP，在AP节点开启PCAP追踪，再在最左侧CSMA节点上开启PCAP追踪，此时左侧点对点节点也是AP节点，右侧点对点节点也是CSMA节点。

​	

* 183-186行代码：

```C++
  Simulator::Run ();
  Simulator::Destroy ();
  return 0;
}
```

​	模拟运行，摧毁模拟，主函数结束。

​	

#### 3.6.2 编译运行

​	下面来编译运行：

​	进入ns3.31文件夹，编译运行：

```shell
$ ./waf --run scratch/third
```

​	以下为运行结果：

![image-20200827193540766](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPB7zRrDtYNOLOqed.3dVo*XPfrTqeHszCpp4MLhkrYr5CJ4Rw.TePC.HCzGO2cTlonCu7mHxuUPwsl3oxxNOwY!/r)

​	可以看到，客户端位于STA的最后一个节点（10.1.1.3）上，它向CSMA节点的最后一个节点（10.1.2.4）上的服务器的9号端口发送数据包。2.01799秒时服务器收到来自客户端的数据包并发送回显数据包，2.03371秒客户端收到服务器发送的回显数据包。

​	

​	由于程序中默认追踪是不开启的，我们再次运行时用命令行将追踪开启：

```shell
$ ./waf --run "scratch/third --tracing=true"
```



​	同样，查看ns3.31目录下，生成了4个PCAP数据包：

![image-20200827195334295](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrENF509MZaUB16crx6nU7i9RKZd2xUJjAaVnCPCxitiPbRe56tkwsbDTIHcwfp2EyMrW0GhjFJNWQR8OSpAlPRuI!/r)

​	我们来分析一下：third-0-0.pcap对应左侧点对点节点（AP节点）的0号点对点设备，third-0-1.pcap对应左侧点对点节点（AP节点）的1号AP设备。third-1-0.pcap对应右侧点对点节点（CSMA节点）的0号点对点设备，third-1-1.pcap对应右侧点对点节点（CSMA节点）的1号CSMA设备。

​	Udp回声客户端位于WIFI网络上，我们先看一下WIFI网络的网络嗅探：

```shell
$ tcpdump -nn -tt -r third-0-1.pcap
```

​	结果如下：

![image-20200827201941328](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEO*bdkuWVTYUQLY09kaRIeaWzJ07pFCyabp4hG7NhqS5na417UP30qkQ.CGl2DSoT*Pj2fhuG02g8wdpBxsc2.0!/r)

![image-20200827201959094](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEGNz5aF2xB4T7Dmg3YiXdmc6Pz.OUCBsG2hgQSaxkrea291tCL.5h3XsB20y9bDAADdruIs7NW7vZfmQ2hxp0hU!/r)

​	可以看到连接类型为802.1，SSID信标的生成过程，以及数据包的发送及接收。

​	

​	再看一下左侧点对点设备的PCAP：

```shell
$ tcpdump -nn -tt -r third-0-0.pcap
```

​	输出如下：

![image-20200827202558448](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEHfd.ruUjSraolgzuArRf3290WfMYhU.rbipGBtzAYK3c146q5O0EzspshZfiXzMmxxkhm3KHbMsD9sqhTQHGhM!/r)

​	这里的PCAP是WIFI到CSMA，可以看到只是时间上略有差别。

​	

​	再看一下右侧CSMA设备的PCAP：

```shell
$ tcpdump -nn -tt -r third-1-0.pcap
```

​	输出如下：

![image-20200827203537463](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBeNErEdOWle7DDoGIDdtxQBqyAZPn4n0a8URL0bMFQfulvwXK9L.CCiMPyk5BxFH*6PBwMp6EPM9qb5Ckw6N7Q!/r)

​	仍然是在数据包到达的时间上有所区别

​		

​	再看一下我们开启了混杂嗅探的CMSA最左侧节点的PCAP：

```shell
$ tcpdump -nn -tt -r third-1-1.pcap
```

​	输出如下：

![image-20200827203725601](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBdYurae.XRlUYvhmiMCsnBD4b0Lwt3Hd2IMIUJPYmuFJgv6h99qq*qvfrTBUVr.exP.1yszKN3Vrn5FC7r5a4c!/r)

​	与second.cc类似，比较好理解。

​	

##### 对节点位置进行追踪

​	我们在这个案例中配置了移动模型，但是不知道模型具体移动到了哪里。使用移动性模型预定义的`CourseChange`追踪源来发起追踪事件。我们将需要编写一个追踪接收器以连接到该源，它将为我们显示我们需要的的信息。

​	在`NS_LOG_COMPONENT_DEFINE()`后添加如下代码：

```C++
void
CourseChange (std::string context, Ptr<const MobilityModel> model)
{
  Vector position = model->GetPosition ();
  NS_LOG_UNCOND (context <<
    " x = " << position.x << ", y = " << position.y);
}
```

​	这段代码从移动模型中提取信息并无条件记录相应节点的位置，还需更改带有Udp回声客户端的STA节点更改位置时调用这个函数。

​	在`Simulator::Run()`前，添加以下代码：

```C++
std::ostringstream oss;
oss <<
  "/NodeList/" << wifiStaNodes.Get (nWifi - 1)->GetId () <<
  "/$ns3::MobilityModel/CourseChange";

Config::Connect (oss.str (), MakeCallback (&CourseChange));
```

​	这里首先创建了一个包含要连接的事件的追踪名称空间路径的字符串。我们必须使用前面用过的GetId方法找出我们想要的节点。 在third.cc中默认数量的CSMA和无线节点的情况下，这个STA节点是节点7。通过调用Config::Connect将节点7的追踪发送端和接收端相连，并且传递了命名空间路径。节点7的每个位置变化都将挂接到我们的跟踪接收器中，该追踪接收器将依次打印出新位置。

​	保存，再次运行模拟：

```shell
$ ./waf --run scratch/third
```

​	此时我们能看到位置的输出：

![image-20200827224111092](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPrETbINVWsENgzIj*CMJKSwuvPNecCb0iRxeMZH2M1JSdOBurFcDdB13iwooLbkHgpIs.LGPJkm19bZavFhlS4!/r)

​	

​	还可以通过可视化来观察节点的移动轨迹：

```shell
$ ./waf --run scratch/third --vis
```

![image-20200827224814021](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEGcbEDa4Rom8j6wg5N8vxIPCswYnQE6c3d8ZxPeAp8KUL0IQHIcPhA14KDh1t9MzPLldN3jsTOvEBLoMs4FlN0g!/r)

​	

##### NS3中的队列

​	在NS3中选择排队规则可能会对性能产生很大影响，对于用户来说，了解默认安装的内容以及如何更改默认值并观察性能非常重要。从结构上讲，NS3将设备层与Internet主机的IP层或流量控制层分开。从NS3的最新版本开始，传出数据包在到达通道对象之前会经过两个队列层。遇到的第一个队列层是NS3中的“流量控制层”；在这里，活动队列管理（RFC7567）和由于服务质量（QoS）引起的优先级通过使用排队规则以与设备无关的方式进行。通常在网络设备对象中找到第二个队列层。不同的设备（例如LTE，WIFI）具有这些队列的不同实现。这种两层方法反映了实际发现的内容（提供优先级的软件队列和特定于链接类型的硬件队列）。实际上，它可能比这还要复杂。例如，地址解析协议的队列很小。 Linux中的WIFI具有四层队列。

​	仅当设备队列已满时，流量控制层才由网络设备通知，以便流量控制层可以停止向网络设备发送数据包。否则，排队规则的积压始终为空，并且无效。当前，点对点、CSMA、WIFI、简单网络设备的网络设备支持流控制，即通知流量控制层的能力，这些网络设备使用Queue对象（或Queue子类的对象）存储其数据包。

​	排队规则的性能在很大程度上受网络设备使用的队列大小的影响。当前，在NS3中默认情况下不会针对配置的链接属性（带宽，延迟）自动调整队列，并且通常是最简单的变体（例如具有拖尾行为的FIFO调度）。但是，可以通过启用BQL（字节队列限制）来动态调整队列的大小，BQL是在Linux内核中实现的算法，用于调整设备队列的大小以应对缓冲区膨胀，同时避免饥饿。当前，支持流控制的网络设备也支持BQL。

​	

在NS3中，有以下队列模型：

​	在流量控制层，有以下选项：

* PFifoFastQueueDisc：默认最大大小为1000个数据包
* FifoQueueDisc：默认最大大小为1000个数据包
* RedQueueDisc：默认最大大小为25个数据包
* CoDelQueueDisc：默认最大大小为1500 KB
* FqCoDelQueueDisc：默认最大大小为10024个数据包
* PieQueueDisc：默认最大大小为25个数据包
* MqQueueDisc：此队列没有容量限制
* TbfQueueDisc：默认最大大小为1000个数据包

​	默认情况下，将IPv4或IPv6地址分配给与网络关联的接口时将在网络设备上安装pfifo_fast排队规则，除非已在网络设备上安装了排队规则。

​	

​	在设备层，有设备特定的队列：

* PointToPointNetDevice：默认配置（由助手设置）是安装默认大小的DropTail队列（100个数据包）
* CsmaNetDevice：默认配置（由助手设置）是安装默认大小（100个数据包）的DropTail队列
* WiFiNetDevice：默认配置是为非QoS站安装默认大小（100个数据包）的DropTail队列，为QoS站安装四个默认大小（100个数据包）的DropTail队列
* SimpleNetDevice：默认配置是安装默认大小的DropTail队列（100个数据包）
* LTENetDevice：排队发生在RLC层（RLC UM默认缓冲区为10 * 1024字节，RLC AM没有缓冲区限制）。
* UanNetDevice：MAC层默认有10个数据包队列

​	

​	网络设备使用的队列类型可以通过设备助手来改变：

```C++
NodeContainer nodes;
nodes.Create (2);

PointToPointHelper p2p;
p2p.SetQueue ("ns3::DropTailQueue", "MaxSize", StringValue ("50p"));

NetDeviceContainer devices = p2p.Install (nodes);
```

​	

​	可以通过流量控制助手来修改网络设备上安装的队列磁盘的类型：

```C++
InternetStackHelper stack;
stack.Install (nodes);

TrafficControlHelper tch;
tch.SetRootQueueDisc ("ns3::CoDelQueueDisc", "MaxSize", StringValue ("1000p"));
tch.Install (devices);
```

​	

​	可以通过流量控制助手在支持BQL的设备上启用BQL：

```C++
InternetStackHelper stack;
stack.Install (nodes);

TrafficControlHelper tch;
tch.SetRootQueueDisc ("ns3::CoDelQueueDisc", "MaxSize", StringValue ("1000p"));
tch.SetQueueLimits ("ns3::DynamicQueueLimits", "HoldTime", StringValue ("4ms"));
tch.Install (devices);
```

​	

### 3.7 追踪

​	共有两种从NS3获取输出的基本策略：使用通用的预定义批量输出机制并解析其内容以提取有趣的信息；或以某种方式开发出一种输出机制，该机制可以准确（或仅）传达所需的信息。

​	使用预定义的批量输出机制的优点是不需要对NS3进行任何更改，但是可能需要编写脚本来分析和过滤感兴趣的数据。通常，PCAP或NS_LOG输出消息是在模拟运行期间收集的，并分别通过脚本运行，这些脚本使用grep，sed或awk解析消息并将数据缩减并将其转换为可管理的形式。因这种形式必须编写程序来进行转换，因此这不是自由的。 NS_LOG输出不被视为NS3 API的一部分，并且在版本之间切换也不会发出警告。此外，NS_LOG输出仅在调试版本中可用，因此依赖它会导致性能下降。当然，如果在任何预定义的输出机制中都不存在感兴趣的信息，则此方法将失效。

​	NS3提供了另一种称为追踪的机制，该机制避免了大容量输出机制中固有的一些问题。它有几个重要的优点。首先，可以通过仅追踪我们兴趣的事件来减少必须管理的数据量（对于大型仿真，将所有内容转储到磁盘以进行后处理会造成I/O瓶颈）。其次，如果使用此方法，则可以直接控制输出的格式，从而避免使用sed，awk，perl或python脚本进行进一步的处理。如果需要，可以将输出直接格式化为gnuplot可接受的格式，例如（另请参见GnuplotHelper）。您可以在核心中添加挂钩，然后其他用户可以访问它们，但是除非明确要求，否则挂钩不会产生任何信息。由于这些原因，作者认为NS3追踪系统是从模拟中获取信息的最佳方法，因此也是NS3中我们要了解的最重要机制之一。

​	有很多方法可以从程序中获取信息。 最直接的方法是将信息直接打印到标准输出中，如下所示：

```C++
#include <iostream>
...
void
SomeFunction (void)
{
  uint32_t x = SOME_INTERESTING_VALUE;
  ...
  std::cout << "The value of x is " << x << std::endl;
  ...
}
```

​	但随着程序中打印语句数量的增加，处理大量输出的任务将变得越来越复杂。最终我们可能会觉得需要控制以某种方式打印哪些信息，可能是通过打开或关闭某些类别的打印或者增加或减少所需的信息量来实现的。如果沿着这个思路继续下去，可能会发现我们已经重新实现了NS_LOG机制（请参阅使用日志记录模块）。为了避免这种情况，可能要考虑的第一件事就是使用NS_LOG本身。

​	如果我们修改对应模块的代码以输出我们想要的信息，首先要添加NS_LOG语句，并且还必须编写代码（如grep，sed或awk脚本中的代码）来解析日志输出，同时还需要隔离我们的信息。这是因为即使我们可以控制日志系统输出的内容，也只能控制日志组件级别的日志，而日志组件级别通常是整个源代码文件。

​	如果要将代码添加到现有模块，则还必须使用其他开发人员都感兴趣的输出。可能会发现，为了获取所需的少量信息可能需要遍历大量与您无关的无关消息，也可能会被迫将巨大的日志文件保存到磁盘，并在我们想要实现它时将它们处理成好多行。

​	由于在NS3中无法保证NS_LOG输出的稳定性，因此我们可能还会发现依赖的日志输出片段在不同NS3版本之间消失或改变。如果我们依赖输出的结构，则可能会发现添加或删除了其他消息有可能会影响代码的解析。

​	由于这些原因，作者认为使用到std::cout和NS_LOG消息是从NS3中获取更多信息的快速而肮脏的方法，但不适合认真的工作。

​	NS3追踪系统旨在沿着这些路线工作，并且与Attribute和Config子系统很好地集成在一起，从而允许使用相对简单的方案。

​	NS3的Tracing系统大体分为3个部分：**trace source**，**trace sink**，以及**将trace source和trace sink关联起来的方法**。

​	trace source是一个实体，它可以用来标记仿真中发生的时间，也可以提供一个访问底层数据的方法。例如，当一个网络设备或者网卡收到一个网络分组时，trace source可以指示并提供一个途经将分组的内容传递给对该分组感兴趣的trace sink。此外，trace source还可以在感兴趣的状态发生变化时给出相应的指示。例如，TCP网络协议模块中的拥塞窗口发生改变时，trace source会给出指示。

​	trace source提供信息，而trace sink消费信息。trace source本身不起任何作用，只有当它和一段有实际功能的代码相关联时才有意义，这段代码就是使用trace source提供的信息来做相关事物的。使用（或消费）trace source提供信息的实体称为trace sink。

​	一个trace source产生的信息可以没有trace sink消费，也可以有一个或者多个trace sink消费。它们之间是一对多的关系。

​	在NS3中，回调系统的目的是使得一段代码可以在没有任何特别的模块间依赖的情况下调用一个函数。这意味着需要某种间接的方式调用函数——使用函数的地址调用。事实上trace sink就是某个callback。 一个trace sink想消费某个源事件产生的消息时，它可以把自己作为一个callback添加到由trace source控制的callbacks列表中。当相关兴趣事件发生时，source就调用operator()方法，并传给该方法0个或多个参数，这些参数就是sink函数的指针，通过指针间接调用sink函数。对于这个问题，更多的细节可以参考《ns-3 Manual》。 

### 3.8 fourth.cc

#### 3.8.1 代码学习

​	简单的追踪示例，代码如下：

```C++
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include "ns3/object.h"
#include "ns3/uinteger.h"
#include "ns3/traced-value.h"
#include "ns3/trace-source-accessor.h"

#include <iostream>

using namespace ns3;

class MyObject : public Object
{
public:
  /**
   * Register this type.
   * \return The TypeId.
   */
  static TypeId GetTypeId (void)
  {
    static TypeId tid = TypeId ("MyObject")
      .SetParent<Object> ()
      .SetGroupName ("Tutorial")
      .AddConstructor<MyObject> ()
      .AddTraceSource ("MyInteger",
                       "An integer value to trace.",
                       MakeTraceSourceAccessor (&MyObject::m_myInt),
                       "ns3::TracedValueCallback::Int32")
    ;
    return tid;
  }

  MyObject () {}
  TracedValue<int32_t> m_myInt;
};

void
IntTrace (int32_t oldValue, int32_t newValue)
{
  std::cout << "Traced " << oldValue << " to " << newValue << std::endl;
}

int
main (int argc, char *argv[])
{
  Ptr<MyObject> myObject = CreateObject<MyObject> ();
  myObject->TraceConnectWithoutContext ("MyInteger", MakeCallback (&IntTrace));

  myObject->m_myInt = 1234;
}

```

​	下面进行代码学习：

* 17-22行：

```C++
#include "ns3/object.h"
#include "ns3/uinteger.h"
#include "ns3/traced-value.h"
#include "ns3/trace-source-accessor.h"

#include <iostream>
```

​	首先要定义自己的类，该类的父类为Object，因此要引入头文件 #include “ns3/object.h”。

​	再引入ns-3自定义的无符号整形所声明的头文件 #include “ns3/uinteger.h”。

​	#include "ns3/traced-value.h"头文件中引入了要跟踪数据的类型，即TracedValue。

​	#include "ns3/trace-source-accessor.h"头文件中包含了本程序要使用的能把自定义数据转换为trace source的函数。

​	以及标准输入输出流iostream。

​	

* 26-49行代码：

```C++
class MyObject : public Object
{
public:
  /**
   * Register this type.
   * \return The TypeId.
   */
  static TypeId GetTypeId (void)
  {
    static TypeId tid = TypeId ("MyObject")
      .SetParent<Object> ()
      .SetGroupName ("Tutorial")
      .AddConstructor<MyObject> ()
      .AddTraceSource ("MyInteger",
                       "An integer value to trace.",
                       MakeTraceSourceAccessor (&MyObject::m_myInt),
                       "ns3::TracedValueCallback::Int32")
    ;
    return tid;
  }

  MyObject () {}
  TracedValue<int32_t> m_myInt;
};
```

​	因为Tracing系统和属性系统有很大关联，而属性系统和对象相关联，所以，每一个要追踪的数据都必须属于一个特定的类，这里这个类定义为`MyObject`，要追踪的数据为`m_myInt`。

​	`GetTypeId()`函数定义了一个关于`MyObject`的元数据集，并返回标识类`TypeId`。NS3中所有由Object类派生的类都可以包含在一个叫`TypeId`的元数据类，该类用来记录关于类的元信息，以便在对象聚合以及构建管理中使用，`TypeId`类中设计了用唯一的字符串来标识一个类、子类的基类以及子类中可以访问的构造函数。

​	`SetParent()`函数的作用是表明该类和父类的关系，避免在向上或向下类型转换时发生不必要的错误。

​	`AddConstructor()`函数的作用是在用户使用对象工厂机制时，不用考虑类的具体细节就可以创建对象。

​	`AddTraceSource()`函数的作用是提供一个“挂钩”，把自定义的名为“MyInterger”的trace source与系统外相关联。其中第一个参数是trace source的名字，使其在Config系统中可见；第二个参数是用于解释的帮助字符串；第三个参数比较重要，其中的`MakeTraceSourceAccessor()`函数的作用是使MyObject类的成员变量m_myInt成为一个可存取的trace source；第四个参数表示TraceValue类型的typedef名称，它为正确的回调函数签名生成文档。 

​	TracedValue m_myInt<int32_t>提供了一个用于驱动callback过程的框架，每当相关数据改变时，TracedValue机制将提供该变量的老值和新值，本例中是一个int32_t值。这个值对应的trace sink函数traceSink需要进行以下形式的签名：

```C++
void (* traceSink) (int32_t oldValue, int32_t newValue); 
```

​	

* 51-55行代码：

```C++
void
IntTrace (int32_t oldValue, int32_t newValue)
{
  std::cout << "Traced " << oldValue << " to " << newValue << std::endl;
}
```

​	上面代码定义了trace sink函数IntTrace，函数的行为就是输出trace source改变前后的值。它直接对应于回调函数签名。一旦它与trace source连接起来，函数IntTrace就会在TracedValue改变时被调用。而连接是在第三方函数中完成的（例如fourth.cc中的main函数）。 
​	ps：这与callback机制相吻合，回调机制中有三方面：回调函数、调用函数、第三方函数；第三方函数连接调用函数与回调函数。 

​	

* 57-64行代码：

```C++
int
main (int argc, char *argv[])
{
  Ptr<MyObject> myObject = CreateObject<MyObject> ();
  myObject->TraceConnectWithoutContext ("MyInteger", MakeCallback (&IntTrace));

  myObject->m_myInt = 1234;
}
```

​	主函数中首先创建了trace source所在类的对象myObject，然后使用`TraceConnectWithoutContext()`函数将自己定义的trace sink函数连接到由属性名指定的trace source。其中第一个参数是trace source名，第二个参数使用`MakeCallBack()`方法调用之前定义的trace sink函数IntTrace，当被追踪的数据m_myInt发生改变时，IntTrace函数才会被调用。

​	最后一行代码可以看作是把常量1234赋值给m_myInt，系统会识别这一行为，并将m_myInt赋值前和赋值后的两个值作为形参传递给trace sink的回调函数IntTrace。

​	

​	总的来看，trace source是一个变量，这个变量管理着一个callbacks列表。trace sink是一个函数，这个函数是回调执行的目标。属性和对象类型信息系统用于建立trace source与trace sink间的连接。“hitting” source这个动作就是对trace source执行一次调用callbacks的运算。 

​	

#### 3.8.2 编译运行

​	下面来编译运行：

```shell
$ ./waf --run scratch/fourth
```

​	输出如下：

![image-20200828210447028](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBXIkLuXvHCaUqvtdHn*kYxHjopOtaCqS1dHg1kJe.p2WfvrwbLEHG.XJuNHbNQGOhjD1O0W4wB1f0jrlUqbBZM!/r)

​	可以看到，在主函数中我们对myInt进行赋值，的确调用了tracing。

​	

​	下面我们注释掉赋值语句并保存运行：

```C++
//myObject->m_myInt = 1234;
```

![image-20200828210801043](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEEmhY0gwvjC6G5tdrOTF1MgTNEqd5j4GQu7d5c0mf.*Ry9IYXWU0Hb7z5w6vanho6cq2xKZN8jm0UYbf8CEFi9g!/r)

​	可以看到，不会有任何的输出。

​	

​	再次修改赋值语句，使得多次赋值以及赋重复值：

```C++
myObject->m_myInt = 0;
myObject->m_myInt = 1234;
myObject->m_myInt = 4567;
myObject->m_myInt = 4567;
myObject->m_myInt = 6789;
```

​	保存，编译运行：

![image-20200828211453759](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPAypwvc4eblR3zLCRzMpUWo00L21EsuNUeCefN1L0UXSS5isrB7SM.zTb7MbH1Nm.AdPctiv9kphyY9ynKox78!/r)

​	可以看到，我们一共进行了五次赋值操作，在运行结果中只追踪到三次值改变的结果，而且由于我们在定义m_myInt时未进行初始化，故默认值为0，我们在第一次赋值为0时，没有改变值，所以没有trace到。

​	

### 3.9 连接到Config

​	事实上，刚才在fourth.cc中使用的TraceConnectWithoutContext调用在平时的应用中较为少见，更典型的是使用Config系统通过config path来选择一个trace source。

​	回忆一下在third.cc后半部我们定义了一个CourseChange来输出移动节点的位置变化信息，这个函数就是trace sink。

```C++
void
CourseChange (std::string context, Ptr<const MobilityModel> model)
{
  Vector position = model->GetPosition ();
  NS_LOG_UNCOND (context <<
    " x = " << position.x << ", y = " << position.y);
}
```

​	当我们把CourseChange连接到trace source上时，我们使用了config path来指定源：

```C++
std::ostringstream oss;
oss <<
  "/NodeList/" << wifiStaNodes.Get (nWifi - 1)->GetId () <<
  "/$ns3::MobilityModel/CourseChange";

Config::Connect (oss.str (), MakeCallback (&CourseChange));
```

​	使用Config类的第一个静态成员函数Connect将二者关联在一起。这个函数有两个参数。其中，第二个参数`MakeCallback (&CourseChange)`的功能是使函数`CourseChange`成为一个回调函数。第一个参数`oss.str()`是一个由各种字符组成的字符串，这很像刚才我们看到的`TraceConnectWithoutContext()`函数。下面来分析这个作为路径的字符串所代表的含义：

​	假设`wifiStaNodes.Get(nWifi-1)->GetId()`得到的值为7，那么上面的配置路径config path即为：/NodeList/7/$ns3::MobilityModel/CourseChange。config path的最后一部分一定是某个对象的某个属性。如果有这个“CourseChange”属性所在对象的指针，可以将上面代码换成下列形式：

```C++
Ptr<Object> theObject = wifiStaNodes.Get (nWifi - 1);
theObject->TraceConnectWithoutContext ("CourseChange", MakeCallback (&CourseChange));
```

​	或者

```C++
Ptr<Object> theObject = wifiStaNodes.Get (nWifi - 1);
theObject->TraceConnect ("CourseChange", MakeCallback (&CourseChange));
```

​	Config函数采用的path表示了一个对象指针链，path的每一部分对应了某个对象属性。最后一段是我们关注的属性，前面的部分是包含或寻找对象用的。Config代码解析且走查这个path直到它得到最后的一段，然后将其解释为路径最后一个对象的一个属性。Config函数之后会对调用近似的TraceConnect方法或TraceConnectWithoutContext方法。下面来分析一下path的细节。 

​	第一个“/”符号代表后面要紧跟的是命名空间，后面所跟的“/”符号可以像目录与子目录一样来理解。这里用到的命名空间为NodeList。而NodeList是一个仿真中使用的节点的一个列表，紧随其后的是这个列表的一个索引，这里是通过Get函数来获取该节点，再通过GetId函数来得到该节点的索引。下一段字符串的第一个字符为“$”，当程序遇到这个符号时，就会调用函数GetObject来返回一个对象，因为在实际仿真中使用的对象聚合技术已经把许多对象全都集成在这个节点中。因为节点中集成了所需要的对象，所以后面就要给出返回对象的类型，此处要返回的对象类型是MobilityModel。而类MobilityModel有一个CourseChange属性，也就是我们要追踪的trace sources。可以在源代码src/mobility/model/mobility-model.cc找到CourseChange：

```C++
//mobility-model.cc
TypeId 
MobilityModel::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::MobilityModel")
    .SetParent<Object> ()
    .SetGroupName ("Mobility")
    .AddAttribute ("Position", "The current position of the mobility model.",
                   TypeId::ATTR_SET | TypeId::ATTR_GET,
                   VectorValue (Vector (0.0, 0.0, 0.0)),
                   MakeVectorAccessor (&MobilityModel::SetPosition,
                                       &MobilityModel::GetPosition),
                   MakeVectorChecker ())
    .AddAttribute ("Velocity", "The current velocity of the mobility model.",
                   TypeId::ATTR_GET,
                   VectorValue (Vector (0.0, 0.0, 0.0)), // ignored initial value.
                   MakeVectorAccessor (&MobilityModel::GetVelocity),
                   MakeVectorChecker ())
    .AddTraceSource ("CourseChange", 
                     "The value of the position and/or velocity vector changed",
                     MakeTraceSourceAccessor (&MobilityModel::m_courseChangeTrace),
                     "ns3::MobilityModel::TracedCallback")
  ;
  return tid;
}
```

​	其中，`.AddTraceSource()`方法就很像我们在fourth.cc里接触的那样。

​	再追相应的头文件`mobility-model.h`：

```C++
  /**
   *  TracedCallback signature.
   *
   * \param [in] model Value of the MobilityModel.
   */
  typedef void (* TracedCallback)(Ptr<const MobilityModel> model);

  /**
   * Used to alert subscribers that a change in direction, velocity,
   * or position has occurred.
   */
  ns3::TracedCallback<Ptr<const MobilityModel> > m_courseChangeTrace;
```

​	这样就能跟`.AddTraceSource()`里的参数对上了。

​	

​	回想一下third.cc中的输出：

```shell
/NodeList/7/$ns3::MobilityModel/CourseChange x = 11.3273, y = 4.04175
```

​	输出的第一个部分就是所谓的Context，它是一段Config代码定位的trace source的路径，指明了由哪个部分触发了回调。第二部分则是不断变化被追踪到的数值。

​	third.cc中的输出包含了是谁调用了trace sink，但fourth.cc里没有。需要有某种方法来确定哪个trace source实际上触发了回调。简单的方法是使用Config::Connect()连接，而不是使用Config::ConnectWithoutContext()。

​	

### 3.10 关于追踪系统的问题

​	对于tracing系统的初学者来说，会常提出： 

​	1.我知道在模拟核心代码中肯定有某个trace source，但是我怎么找到那些能用的？ 

​	2.我找到了trace source，怎么制定config path？ 

​	3.我找到了trace source和config path，怎么指定返回类型和回调函数中规范的参数？ 

​	4.我做了上述所有工作，但有错误信息 。

​	下面我们依次解决。

​	

#### 3.10.1 可用的追踪源

​	如何找到可用的追踪源呢？如果我们访问NS3项目网站，会发现有一个名为Documentation的导航栏，访问这个链接进入文档页。其中有一个名为”Latest Release”的连接，点击它可以找到最新版NS3的文档。然后，选择“API Documentation”，进入NS3的API文档页，在侧边栏里能够找到`All TraceSources`： 

![image-20200828230658127](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEG38fxu.*BR3YYiwm0*uAe9UF0cb4ng9bFyYDttChs.y8g3PEFoqTZHfRTBKGFL8D47bApHPrIgW.ZFnAj9DHsM!/r)

​	并且利用好Ctrl + F 查找，能很快的找到我们想要类对应的trace source。

​	

#### 3.10.2 配置路径

​	如果知道我们关注的对象是哪个，那么可以在上节中提到的`All TraceSources`中找到对象所属类的“Detailed Description”。例如点击“API Documentation”——“All TraceSources”——“ns3:::MobilityModel”连接，可以打开MobilityModel的相关信息页。然后在“更多信息”中找到Detailed Description，其中会有三个列表：

* Config Paths：该类的一个典型Config paths列表

* Attributes: 该类提供的属性列表

* TraceSources：该类能够提供的所有TraceSources 

​	

​	首先讨论Config Paths。假设在所有追踪源中我们找到了CourseChange，如何连接它？而third.cc使用的移动模型是ns3::RandomWalk2dMobilityModel，在Class List的ns3类下找到该类，进入其详细页面的Detailed Description中找到Config Paths列表：

![image-20200829000244252](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEO55kdpHL9ORjaXyOnffngwt4UJQPFlQaHZOyRi1AN2SiKhAOPerNnszVCEqyFBfhSyENDHJpYCiZurdpk4c1ec!/r)

​	这段文档告诉我们如何获取RandomWalk2dMobilityModel （路径），实际例子里我们使用的是：“/NodeList/7/$ns3::MobilityModel”, 因为CourseChange在基类MobilityModel中也被定义为config paths，所以既可以用基类的路径，也可以用上面给出的详细路径。如果用到某些RandomWalk2dMobilityModel中才有的跟踪源，那么就要使用上面的实现类路径了。

​	除了看API文档，还有一个从源码找config paths的方法，那就是使用linux中的find命令和grep工具查看源代码。在命令行输入以下代码：

```shell
$ cd src
$ find . -name '*.cc' | xargs grep CourseChange | grep Connect
```

![image-20200829001436176](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEAj.WsutEVv8jjm3lpzeOMzaY.YtcGwb*b6ieEwPpd5BmftfTA80ETc4znqKKvGIQathqoPMSv.Z2SRRl8p5yhw!/r)

​	

#### 3.10.3 回调函数签名

​	当我们找到了跟踪源和配置路径，如何知道回调函数的返回类型和形参等相关要求？ 

​	最简单的办法是查看回调签名（Callback Signature）的typedef，它在所用类的API文档的“Detailed Description”中被记录。还是以CourseChange为例，在ns3::RandomWalk2MobilityModel中的Detailed Description有如下内容：

![image-20200829002259503](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEMSjq.EDAT0rh97sqe.66bOImL*DCGnX22FX6pwMF5qyBmwsJkImWK4IZ2xqhFToXXrUIS.g7omngJL6Jpi1IwI!/r)

​	告诉我们去它的父类里找，可以找到它的回调签名：

```C++
typedef void(* ns3::MobilityModel::TracedCallback) (Ptr< const MobilityModel > model)
```

​	这也是我们之前追过的内容。

​	

​	打开src/mobility/examples/main-random-topology.cc，看一下将“CourseChange”trace source连接到同一文件中的CourseChange函数：

```C++
static void 
 CourseChange (std::string context, Ptr<const MobilityModel> position)
 {
   Vector pos = position->GetPosition ();
   std::cout << Simulator::Now () << ", pos=" << position << ", x=" << pos.x << ", y=" << pos.y
             << ", z=" << pos.z << std::endl;
 }
```

​	可以看到，第一个参数是"context"参数，如果使用ConnectWithoutContext()连接了回调，需要在签名中省略context参数。如果偶然情况下没有记录回调签名，并且没有任何示例参考，那么可能很难从源代码中真正找出正确的回调函数签名。

​	回调的返回值将始终为空。可以从声明中的模板参数列表中找到TracedCallback()函数的实参列表。回想一下，对于我们当前的示例，在mobility-model.h中，我们先前在其中找到：

```C++
ns3::TracedCallback<Ptr<const MobilityModel> > m_courseChangeTrace;
```

​	声明中的模板参数列表与回调函数的形参之间存在一一对应的关系。 这里有一个模板参数`Ptr<const MobilityModel>`。 这告诉我们需要一个返回void并以`Ptr<const MobilityModel>`为参数的函数。 例如：

```C++
void
CourseChange (Ptr<const MobilityModel> model)
{
  ...
}
```

​	这就是`Config::ConnectWithoutContext()`所需要的函数，如果我们需要一个context，则我们需要用`Config::Connect()`以及参数带context的回调函数。使用以下回调函数：

```C++
void
CourseChange (std::string context, Ptr<const MobilityModel> model)
{
  ...
}
```

​	如果要确保CourseChange回调函数仅在本地文件中可见，可以添加关键字static：

```C++
static void
CourseChange (std::string path, Ptr<const MobilityModel> model)
{
  ...
}
```

​	这就是我们在third.cc后半部使用的。

​	

#### 3.10.4 追踪值

​	fourth.cc演示了一个简单的追踪代码片段，该代码使用TracedValue <int32_t>演示了追踪代码的基础。 我们只是简单介绍了TracedValue的真正含义，以及如何找到回调的返回类型和形式参数。

​	如前所述，文件traced-value.h引入了用于遵循值语义的数据跟踪所必需的声明。 通常，值语义只是意味着可以传递对象本身，而不是传递对象的地址。 NS3扩展了该要求，以包括为纯旧数据（POD、plain-old-data）类型预定义的全套赋值样式运算符：

```C++
//traced-value.h

  /**
   * Assignment.
   * \param [in] o The value to assign to this instance.
   * \return This TracedValue.
   */
  TracedValue &operator = (const TracedValue &o)
  {
    TRACED_VALUE_DEBUG ("x=");
    Set (o.m_v);
    return *this;
  }

  TracedValue &operator++ ()
  {
    TRACED_VALUE_DEBUG ("++x");
    T tmp = Get ();
    ++tmp;
    Set (tmp);
    return *this;
  }

  TracedValue operator++ (int)
  {
    TRACED_VALUE_DEBUG ("x++");
    TracedValue old (*this);
    T tmp = Get ();
    tmp++;
    Set (tmp);
    return old;
  }

  TracedValue &operator-- ()
  {
    TRACED_VALUE_DEBUG ("--x");
    T tmp = Get ();
    --tmp;
    Set (tmp);
    return *this;
  }

  TracedValue operator-- (int)
  {
    TRACED_VALUE_DEBUG ("x--");
    TracedValue old (*this);
    T tmp = Get ();
    tmp--;
    Set (tmp);
    return old;
  }

template <typename T, typename U>
TracedValue<T> &operator += (TracedValue<T> &lhs, const U &rhs)
{
  TRACED_VALUE_DEBUG ("x+=");
  T tmp = lhs.Get ();
  tmp += rhs;
  lhs.Set (tmp);
  return lhs;
}

template <typename T, typename U>
TracedValue<T> &operator -= (TracedValue<T> &lhs, const U &rhs)
{
  TRACED_VALUE_DEBUG ("x-=");
  T tmp = lhs.Get ();
  tmp -= rhs;
  lhs.Set (tmp);
  return lhs;
}

template <typename T, typename U>
TracedValue<T> &operator *= (TracedValue<T> &lhs, const U &rhs)
{
  TRACED_VALUE_DEBUG ("x*=");
  T tmp = lhs.Get ();
  tmp *= rhs;
  lhs.Set (tmp);
  return lhs;
}

template <typename T, typename U>
TracedValue<T> &operator /= (TracedValue<T> &lhs, const U &rhs)
{
  TRACED_VALUE_DEBUG ("x/=");
  T tmp = lhs.Get ();
  tmp /= rhs;
  lhs.Set (tmp);
  return lhs;
}

template <typename T, typename U>
TracedValue<T> &operator %= (TracedValue<T> &lhs, const U &rhs)
{
  TRACED_VALUE_DEBUG ("x%=");
  T tmp = lhs.Get ();
  tmp %= rhs;
  lhs.Set (tmp);
  return lhs;
}

template <typename T, typename U>
TracedValue<T> &operator <<= (TracedValue<T> &lhs, const U &rhs)
{
  TRACED_VALUE_DEBUG ("x<<=");
  T tmp = lhs.Get ();
  tmp <<= rhs;
  lhs.Set (tmp);
  return lhs;
}

template <typename T, typename U>
TracedValue<T> &operator >>= (TracedValue<T> &lhs, const U &rhs)
{
  TRACED_VALUE_DEBUG ("x>>=");
  T tmp = lhs.Get ();
  tmp >>= rhs;
  lhs.Set (tmp);
  return lhs;
}

template <typename T, typename U>
TracedValue<T> &operator &= (TracedValue<T> &lhs, const U &rhs)
{
  TRACED_VALUE_DEBUG ("x&=");
  T tmp = lhs.Get ();
  tmp &= rhs;
  lhs.Set (tmp);
  return lhs;
}

template <typename T, typename U>
TracedValue<T> &operator |= (TracedValue<T> &lhs, const U &rhs)
{
  TRACED_VALUE_DEBUG ("x|=");
  T tmp = lhs.Get ();
  tmp |= rhs;
  lhs.Set (tmp);
  return lhs;
}

template <typename T, typename U>
TracedValue<T> &operator ^= (TracedValue<T> &lhs, const U &rhs)
{
  TRACED_VALUE_DEBUG ("x^=");
  T tmp = lhs.Get ();
  tmp ^= rhs;
  lhs.Set (tmp);
  return lhs;
}
```

​	我们能够追踪这些运算符对具有值语义的C++对象所做的所有更改。

​	通过修改fourth.cc的myInt的赋值过程进行验证：

![image-20200829201756567](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEG4d7GTUnsxxUGJZBNPvkDR25dTYog.UAORxtQ1OL0YeYdD8wqrPUDEJGKLHmu85nJssAYJkuHPRsRNdcQ8BzYg!/r)

​	

### 3.11 fifth.cc

#### 3.11.1 准备工作

​	在进入fifth.cc之前，先进行准备工作。

​	取材自有关TCP的一本最著名的书。 W. Richard Stevens撰写的“TCP/IP Illustrated, Volume 1: The Protocols”的366页图21.10：拥塞窗口和序列号与时间的关系图。我们使用追踪系统和gnuplot在NS3中重新创建该图的cwnd部分。

​	首先要考虑的是我们如何获取数据。我们需要追踪什么？事实证明，NS3 TCP大部分的实现位于src/internet/model/tcp-socket-base.cc中，而拥塞控制变量位于src/internet/model/tcp-bic.cc中。因此，让我们参考NS3文档中的“All TraceSource”列表以了解我们需要的内容。会发现：

![image-20200829211004434](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBzz*8uahRvSO4ryYsCAS5i4tZTuxe5dtUpxyfOR*LH8rHP9W5wIuqVxPMn1Mu3HXlQzhkp3n2nzPaVIP49B9vQ!/r)

![image-20200829211952570](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEDQxFvRz40aRWLtuBpAkVV*JqTDiZfBdrsaTnt0phBOmU0bc586UsaSbuVh.QzbH6Unzrp8vBoOHdgncHKE2jas!/r)

​	其中，这两个一个是TCP连接的拥塞窗口，一个是TCP慢启动的门槛。点击他们的Callback signature，进入找到相应的条目：

![image-20200829212245472](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEBZAxc88IfpFJHnsZDgrCsifG.lwEUpJtWhJ.khHD.fcLWdquEcouvH2NgZiA8ZOqDNf.rW8nQlg9zTfhMMbjUY!/r)

​	现在应该完全理解此代码了。 如果我们有一个指向TcpSocketBase对象的指针，则在提供适当的回调目标的情况下可以将trace sink连接到“CongestionWindow”这个trace source 。而且我们知道我们必须提供带有该签名的回调函数。

​	最好尝试找到可以我们修改的现成代码而不是从头开始。 因此，现在的首要任务是找到一些已经钩住“CongestionWindow”这个trace source的代码，并查看我们是否可以对其进行修改。和往常一样，可以通过grep查找：

```shell
$ find . -name '*.cc' | xargs grep CongestionWindow
```

![image-20200829213614642](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEF3mGjkAT4LSl8wbSuzcRcdEVwxINlXlm7xx7Kiz9fWRXZv6zTzqcwKRzoyglFVRj3FGd.x7erocHZ6FJeon*Ac!/r)

​	可以看到有上面几个文件中有现成的实现，在vscode里打开src/test/ns3tcp/ns3tcp-cwnd-test-suite.cc并搜索“CongestionWindow”，将会找到以下代码：

```C++
Ptr<Socket> ns3TcpSocket = Socket::CreateSocket (nodes.Get (0), TcpSocketFactory::GetTypeId ());
ns3TcpSocket->TraceConnectWithoutContext ("CongestionWindowInflated", MakeCallback (&Ns3TcpCwndTestCase1::CwndChange, this));
```

​	这对我们来说应该很熟悉。上面我们提到如果我们有一个指向TcpSocketBase的指针，则可以将trace sink连接到“CongestionWindow”这个trace source。这就是我们这里所需要的，这行代码完全符合我们的要求。如果我们查看这两段代码位于的`Ns3TcpCwndTestCase1::DoRun (void)`函数，将会发现它看起来很像我们平时编写的main函数。因为它是由测试框架运行的脚本，我们可以将其复制出来进行修改并放在main函数中。fifth.cc就是如此。

​	fifth.cc告诉我们了一个极其重要的规则，在使用任何类型的trace source之前必须了解对应的规则：必须确保Config::Connect命令的目标存在，然后才能尝试使用它。这与说在尝试调用对象之前必须实例化对象没有什么不同。

​	让我们回到基础。任何NS3脚本中都存在三个基本执行阶段。第一阶段有时称为“配置时间”或“设置时间”，它存在于main函数的调用Simulator::Run()之前。第二阶段有时称为“模拟时间”，存在于Simulator::Run()积极执行其事件的时间段内。完成模拟执行后，Simulator::Run()将控制权返回给主函数。发生这种情况时，脚本将进入可称为“拆卸阶段”的阶段，即拆散并释放在安装过程中创建的结构和对象。

​	尝试使用追踪系统时，最常见的错误可能是假设在仿真期间动态构造的实体在配置期间可用。NS3的套接字是一个动态对象，通常由应用程序创建以在节点之间进行通信。 NS3的应用程序始终具有与其关联的“开始时间”和“停止时间”。在大多数情况下，除非在某个“开始时间”调用其StartApplication()方法，否则应用程序将不会尝试创建动态对象。这是为了确保在应用程序尝试执行任何操作之前已完全配置模拟（如果尝试连接到配置期间尚不存在的节点，会发生什么情况？）。因此，如果在仿真过程中动态创建了一个trace source，那么在配置阶段就无法将trace source连接到trace sink。

​	解决这个问题有两个方法：一是创建一个在创建动态对象之后运行的模拟器事件，并在执行该事件时挂钩追踪。二是在配置时创建动态对象，然后将其挂接，并将该对象提供给系统以在仿真期间使用。在fifth.cc中采用了第二种方法。这需要我们创建MyApp应用程序，其全部目的是将Socket作为参数。

​	

#### 3.11.2 代码学习

​	我们想看看NS3中TCP拥塞窗口中的变化。 我们需要加快流程并在发送者的套接字上挂接CongestionWindow属性。 通常，人们会使用开关应用程序来生成流，但这有两个问题。 首先，开关应用程序的套接字要等到应用程序启动时才创建，因此我们无法在配置时挂接套接字。 其次，即使我们可以在开始时间之后安排一次调用，套接字也不是公共的，因此我们无法使用它。

​	因此，我们可以编写一个简单的开关应用程序，该开关可以完成我们想要的工作。 从好的方面来说，我们不需要开关应用程序的所有复杂部分。 在不好的方面来说，我们没有助手。因此我们必须更多地自己写一些细节，但这是微不足道的。

​	首先，我们创建一个套接字并在其上进行追踪连接。 然后，将此套接字传递到简单应用程序的构造函数中，然后将其安装在源节点中。

​	

​	下面开始代码学习，代码如下：

```C++
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <fstream>
#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"

using namespace ns3;

NS_LOG_COMPONENT_DEFINE ("FifthScriptExample");

// ===========================================================================
//
//         node 0                 node 1
//   +----------------+    +----------------+
//   |    ns-3 TCP    |    |    ns-3 TCP    |
//   +----------------+    +----------------+
//   |    10.1.1.1    |    |    10.1.1.2    |
//   +----------------+    +----------------+
//   | point-to-point |    | point-to-point |
//   +----------------+    +----------------+
//           |                     |
//           +---------------------+
//                5 Mbps, 2 ms
//
//
// We want to look at changes in the ns-3 TCP congestion window.  We need
// to crank up a flow and hook the CongestionWindow attribute on the socket
// of the sender.  Normally one would use an on-off application to generate a
// flow, but this has a couple of problems.  First, the socket of the on-off 
// application is not created until Application Start time, so we wouldn't be 
// able to hook the socket (now) at configuration time.  Second, even if we 
// could arrange a call after start time, the socket is not public so we 
// couldn't get at it.
//
// So, we can cook up a simple version of the on-off application that does what
// we want.  On the plus side we don't need all of the complexity of the on-off
// application.  On the minus side, we don't have a helper, so we have to get
// a little more involved in the details, but this is trivial.
//
// So first, we create a socket and do the trace connect on it; then we pass 
// this socket into the constructor of our simple application which we then 
// install in the source node.
// ===========================================================================
//
class MyApp : public Application 
{
public:

  MyApp ();
  virtual ~MyApp();

  void Setup (Ptr<Socket> socket, Address address, uint32_t packetSize, uint32_t nPackets, DataRate dataRate);

private:
  virtual void StartApplication (void);
  virtual void StopApplication (void);

  void ScheduleTx (void);
  void SendPacket (void);

  Ptr<Socket>     m_socket;
  Address         m_peer;
  uint32_t        m_packetSize;
  uint32_t        m_nPackets;
  DataRate        m_dataRate;
  EventId         m_sendEvent;
  bool            m_running;
  uint32_t        m_packetsSent;
};

MyApp::MyApp ()
  : m_socket (0), 
    m_peer (), 
    m_packetSize (0), 
    m_nPackets (0), 
    m_dataRate (0), 
    m_sendEvent (), 
    m_running (false), 
    m_packetsSent (0)
{
}

MyApp::~MyApp()
{
  m_socket = 0;
}

void
MyApp::Setup (Ptr<Socket> socket, Address address, uint32_t packetSize, uint32_t nPackets, DataRate dataRate)
{
  m_socket = socket;
  m_peer = address;
  m_packetSize = packetSize;
  m_nPackets = nPackets;
  m_dataRate = dataRate;
}

void
MyApp::StartApplication (void)
{
  m_running = true;
  m_packetsSent = 0;
  m_socket->Bind ();
  m_socket->Connect (m_peer);
  SendPacket ();
}

void 
MyApp::StopApplication (void)
{
  m_running = false;

  if (m_sendEvent.IsRunning ())
    {
      Simulator::Cancel (m_sendEvent);
    }

  if (m_socket)
    {
      m_socket->Close ();
    }
}

void 
MyApp::SendPacket (void)
{
  Ptr<Packet> packet = Create<Packet> (m_packetSize);
  m_socket->Send (packet);

  if (++m_packetsSent < m_nPackets)
    {
      ScheduleTx ();
    }
}

void 
MyApp::ScheduleTx (void)
{
  if (m_running)
    {
      Time tNext (Seconds (m_packetSize * 8 / static_cast<double> (m_dataRate.GetBitRate ())));
      m_sendEvent = Simulator::Schedule (tNext, &MyApp::SendPacket, this);
    }
}

static void
CwndChange (uint32_t oldCwnd, uint32_t newCwnd)
{
  NS_LOG_UNCOND (Simulator::Now ().GetSeconds () << "\t" << newCwnd);
}

static void
RxDrop (Ptr<const Packet> p)
{
  NS_LOG_UNCOND ("RxDrop at " << Simulator::Now ().GetSeconds ());
}

int 
main (int argc, char *argv[])
{
  CommandLine cmd (__FILE__);
  cmd.Parse (argc, argv);
  
  NodeContainer nodes;
  nodes.Create (2);

  PointToPointHelper pointToPoint;
  pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
  pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));

  NetDeviceContainer devices;
  devices = pointToPoint.Install (nodes);

  Ptr<RateErrorModel> em = CreateObject<RateErrorModel> ();
  em->SetAttribute ("ErrorRate", DoubleValue (0.00001));
  devices.Get (1)->SetAttribute ("ReceiveErrorModel", PointerValue (em));

  InternetStackHelper stack;
  stack.Install (nodes);

  Ipv4AddressHelper address;
  address.SetBase ("10.1.1.0", "255.255.255.252");
  Ipv4InterfaceContainer interfaces = address.Assign (devices);

  uint16_t sinkPort = 8080;
  Address sinkAddress (InetSocketAddress (interfaces.GetAddress (1), sinkPort));
  PacketSinkHelper packetSinkHelper ("ns3::TcpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), sinkPort));
  ApplicationContainer sinkApps = packetSinkHelper.Install (nodes.Get (1));
  sinkApps.Start (Seconds (0.));
  sinkApps.Stop (Seconds (20.));

  Ptr<Socket> ns3TcpSocket = Socket::CreateSocket (nodes.Get (0), TcpSocketFactory::GetTypeId ());
  ns3TcpSocket->TraceConnectWithoutContext ("CongestionWindow", MakeCallback (&CwndChange));

  Ptr<MyApp> app = CreateObject<MyApp> ();
  app->Setup (ns3TcpSocket, sinkAddress, 1040, 1000, DataRate ("1Mbps"));
  nodes.Get (0)->AddApplication (app);
  app->SetStartTime (Seconds (1.));
  app->SetStopTime (Seconds (20.));

  devices.Get (1)->TraceConnectWithoutContext ("PhyRxDrop", MakeCallback (&RxDrop));

  Simulator::Stop (Seconds (20));
  Simulator::Run ();
  Simulator::Destroy ();

  return 0;
}


```

​	

* 62-86行代码：

```C++
class MyApp : public Application 
{
public:

  MyApp ();
  virtual ~MyApp();

  void Setup (Ptr<Socket> socket, Address address, uint32_t packetSize, uint32_t nPackets, DataRate dataRate);

private:
  virtual void StartApplication (void);
  virtual void StopApplication (void);

  void ScheduleTx (void);
  void SendPacket (void);

  Ptr<Socket>     m_socket;
  Address         m_peer;
  uint32_t        m_packetSize;
  uint32_t        m_nPackets;
  DataRate        m_dataRate;
  EventId         m_sendEvent;
  bool            m_running;
  uint32_t        m_packetsSent;
};
```

​	可以看到，该类继承自Application类。 这里的代码与src/network/model/application.h相似。MyApp类必须重写StartApplication和StopApplication方法。 当在仿真过程中需要MyApp启动和停止发送数据时，将自动调用这些方法。

​	

* 开关应用程序

​	值得花一些时间来解释事件实际上是如何在系统中开始的。 虽然这是另一个相当深入的解释，但是这样做很有用，因为这涉及NS3的某些非常重要的部分如何工作，并揭示了一些重要的习惯用法。 如果打算开发新模型，则可能需要了解这段内容。

​	启动事件的最常见方法是启动应用程序。 这是由于NS3脚本的以下几行代码所致：

```C++
ApplicationContainer apps = ...
apps.Start (Seconds (1.0));
apps.Stop (Seconds (10.0));
```

​	在first.cc中，我们曾经追过.Start及.Stop两个方法，核心是以下两句代码：

```C++
app->SetStartTime (start);
app->SetStopTime (stop);
```

​	这些调用的最终结果是希望模拟器自动调用我们的应用程序以告诉他们何时启动和停止。对于MyApp，它继承自Application类并重写了StartApplication和StopApplication。这就是模拟器将在适当的时候调用的功能。对于MyApp，将发现MyApp::StartApplication进行了初始绑定，并在套接字上进行了连接，然后通过调用MyApp::SendPacket启动数据流。 MyApp::StopApplication通过取消任何未决的发送事件来停止生成数据包，然后关闭套接字。

​	NS3的优点之一是可以完全忽略模拟器在正确的时间“自动”调用应用程序的实现细节。如果查看src/network/model/application.cc，会发现Application的SetStartTime方法仅设置成员变量m_startTime，而SetStopTime方法仅设置m_stopTime。

```C++
//application.cc
void
Application::SetStartTime (Time start)
{
  NS_LOG_FUNCTION (this << start);
  m_startTime = start;
}
void
Application::SetStopTime (Time stop)
{
  NS_LOG_FUNCTION (this << stop);
  m_stopTime = stop;
}
```

​	这里没有任何提示，这条路可能会结束。

​	

​	再次进行尝试的关键是要知道系统中所有节点的全局列表。每当在模拟中创建节点时，指向该节点的指针都会添加到全局NodeList中。查看src/network/model/node-list.cc并搜索NodeList::Add：

```C++
//node-list.cc
uint32_t
NodeList::Add (Ptr<Node> node)
{
  NS_LOG_FUNCTION (node);
  return NodeListPriv::Get ()->Add (node);
}
```

​	可以发现，这里公共静态实现调用名为NodeListPriv::Add的私有实现。这是在NS3中相对普遍的。因此追一下NodeListPriv::Add。在那里会发现：

```C++
//node-list.cc
uint32_t
NodeListPriv::Add (Ptr<Node> node)
{
  NS_LOG_FUNCTION (this << node);
  uint32_t index = m_nodes.size ();
  m_nodes.push_back (node);
  Simulator::ScheduleWithContext (index, TimeStep (0), &Node::Initialize, node);
  return index;

}
```

​	这告诉我们每当在模拟中创建节点时都会产生副作用，即安排了在零时发生的对该节点的Initialize方法的调用。现在不要过多地解读这个名字。这并不意味着节点将要开始做任何事情，它可以解释为对节点的信息调用，告诉节点模拟已经开始而不是通过调用高速节点要去做某事。

​	因此，NodeList::Add间接安排在零时对Node::Initialize的调用，以告知新节点模拟已开始。但是如果在src/network/model/node.h中查找，则找不到名为Node::Initialize的方法。事实证明，Initialize方法是从Object类继承的。仿真开始时系统中的所有对象都会被通知，而Node类的对象只是这些对象中的一种。

​	接下来查看src/core/model/object.cc并搜索Object::Initialize：

```C++
//object.cc
void
Object::Initialize (void)
{
  /**
   * Note: the code here is a bit tricky because we need to protect ourselves from
   * modifications in the aggregate array while DoInitialize is called. The user's
   * implementation of the DoInitialize method could call GetObject (which could
   * reorder the array) and it could call AggregateObject which would add an
   * object at the end of the array. To be safe, we restart iteration over the
   * array whenever we call some user code, just in case.
   */
  NS_LOG_FUNCTION (this);
restart:
  uint32_t n = m_aggregates->n;
  for (uint32_t i = 0; i < n; i++)
    {
      Object *current = m_aggregates->buffer[i];
      if (!current->m_initialized)
        {
          current->DoInitialize ();
          current->m_initialized = true;
          goto restart;
        }
    }
}
```

​	由于NS3对象支持聚合，所以这段代码并不像期望的那样简单。然后，Object::Initialize中的代码循环遍历所有已聚合在一起的对象并调用其DoInitialize方法。这是在NS3中非常常见的另一种习惯用法，有时也称为“模板设计模式”：一种在实现之间保持不变的公共非虚拟API方法，并调用子类继承并实现的私有虚拟实现方法。名称通常类似于公用API的MethodName和私有API的DoMethodName。

​	这告诉我们，我们应该在src/network/model/node.cc中寻找Node::DoInitialize方法：

```C++
//node.cc
void 
Node::DoInitialize (void)
{
  NS_LOG_FUNCTION (this);
  for (std::vector<Ptr<NetDevice> >::iterator i = m_devices.begin ();
       i != m_devices.end (); i++)
    {
      Ptr<NetDevice> device = *i;
      device->Initialize ();
    }
  for (std::vector<Ptr<Application> >::iterator i = m_applications.begin ();
       i != m_applications.end (); i++)
    {
      Ptr<Application> application = *i;
      application->Initialize ();
    }

  Object::DoInitialize ();
}
```

​	这将继续我们的尝试。这个方法遍历了Node中的所有设备，然后遍历Node中的所有应用程序，分别调用device->Initialize和application->Initialize方法。Device类和Application类都继承自Object类，因此下一步将是查看调用Application::DoInitialize时发生的情况。追一下src/network/model/application.cc：

```C++
//application.cc
void
Application::DoInitialize (void)
{
  NS_LOG_FUNCTION (this);
  m_startEvent = Simulator::Schedule (m_startTime, &Application::StartApplication, this);
  if (m_stopTime != TimeStep (0))
    {
      m_stopEvent = Simulator::Schedule (m_stopTime, &Application::StopApplication, this);
    }
  Object::DoInitialize ();
}
```

​	在这里，我们终于走到了尽头。如果一切顺利，则在实现NS3应用程序时，新应用程序将从类Application继承。重写StartApplication和StopApplication方法并提供用于启动和停止新应用程序中的数据流的机制。在仿真中创建节点后，会将其添加到全局NodeList中。将节点添加到此NodeList的操作导致将模拟器事件安排为零时刻，该事件将在仿真开始时调用新添加节点的Node::Initialize方法。由于Node继承自Object，因此会在Node上调用Object::Initialize方法，然后又对聚集到Node上的所有Object调用DoInitialize方法（考虑移动性模型）。由于节点对象已重写了DoInitialize，因此在模拟开始时将调用该方法。Node::DoInitialize方法调用该节点上所有应用程序的Initialize方法。由于应用程序也是对象，因此将导致调用Application::DoInitialize。调用Application::DoInitialize时，它将为应用程序上调用的StartApplication和StopApplication计划事件。这些调用旨在启动和停止来自应用程序的数据流。

​	

* 88-103行代码：

```C++
MyApp::MyApp ()
  : m_socket (0), 
    m_peer (), 
    m_packetSize (0), 
    m_nPackets (0), 
    m_dataRate (0), 
    m_sendEvent (), 
    m_running (false), 
    m_packetsSent (0)
{
}

MyApp::~MyApp()
{
  m_socket = 0;
}
```

​	当然，MyApp需要一个构造函数以及析构函数。这里使用参数列表为私有变量进行了赋初值。

​	

* 105-113行代码：

```C++
void
MyApp::Setup (Ptr<Socket> socket, Address address, uint32_t packetSize, uint32_t nPackets, DataRate dataRate)
{
  m_socket = socket;
  m_peer = address;
  m_packetSize = packetSize;
  m_nPackets = nPackets;
  m_dataRate = dataRate;
}
```

​	这就是为什么要自定义MyApp类的关键所在。这段代码应该比较好理解，就是初始化一些成员变量。从追踪的角度来看，最重要的一点是我们需要在配置期间为应用程序提供`Ptr <Socket>`套接字。结合主函数来看，我们将把套接字创建为TcpSocket，并在将其传递给Setup方法之前钩住其“CongestionWindow”这个trace source。

​	

* 115-123行代码：

```C++
void
MyApp::StartApplication (void)
{
  m_running = true;
  m_packetsSent = 0;
  m_socket->Bind ();
  m_socket->Connect (m_peer);
  SendPacket ();
}
```

​	上面的代码重写了StartApplication函数，模拟器将自动调用该实现以在适当的时间运行我们的Application。 可以看到它执行了Socket Bind操作。 如果熟悉伯克利套接字，这并不奇怪。 正如所期望的那样，它在连接的本地端执行所需的工作。 以下连接将执行在地址m_peer与TCP建立连接所需的操作。 现在应该很清楚为什么我们需要将很多时间推迟到仿真时间，因为Connect需要一个功能齐全的网络来完成。 连接之后，应用程序通过调用SendPacket开始创建模拟事件。

​	

* 125-139行代码：

```C++
void 
MyApp::StopApplication (void)
{
  m_running = false;

  if (m_sendEvent.IsRunning ())
    {
      Simulator::Cancel (m_sendEvent);
    }

  if (m_socket)
    {
      m_socket->Close ();
    }
}
```

​	上面的代码重写了StopApplication函数，解释了如何停止创建模拟事件。每次安排模拟事件时都会创建一个事件。 如果事件正在等待执行或正在执行，则其方法IsRunning将返回true。 在此代码中，如果IsRunning返回true，则我们取消该事件并将其从模拟器事件队列中删除。 通过这样做，我们打破了应用程序用来继续发送其数据包的事件链，并使应用程序静默。 在使应用程序静默之后，我们关闭套接字，这将断开TCP连接。

​	当执行m_socket = 0时，该套接字实际上已在析构函数中删除。 这将删除对基础`Ptr <Socket>`的最后一个引用，该引用导致调用该Object的析构函数。

​	

* 141-151行代码：

```C++
void 
MyApp::SendPacket (void)
{
  Ptr<Packet> packet = Create<Packet> (m_packetSize);
  m_socket->Send (packet);

  if (++m_packetsSent < m_nPackets)
    {
      ScheduleTx ();
    }
}
```

​	在StartApplication里写了SendPacket函数，这里是它的实现。在这里SendPacket创建了一个数据包，然后执行一次发送操作。应用程序需要对事件链进行调度，因此下一行将调用ScheduleTx调度另一个发送事件（SendPacket），直到应用程序发送足够的消息为止。

​	

* 153-161行代码：

```C++
void 
MyApp::ScheduleTx (void)
{
  if (m_running)
    {
      Time tNext (Seconds (m_packetSize * 8 / static_cast<double> (m_dataRate.GetBitRate ())));
      m_sendEvent = Simulator::Schedule (tNext, &MyApp::SendPacket, this);
    }
}
```

​	 如果应用程序正在运行时（尚未调用StopApplication），ScheduleTx将安排一个新事件，该事件再次调用SendPacket。 警报阅读器会出现某些吸引新用户的东西。 一个应用程序的数据速率与基础信道的数据速率无关，它只是应用程序产生位的速率。 它不考虑用于传输数据的各种协议或通道的任何开销。 如果将应用程序的数据速率设置为与基础信道相同的数据速率，则最终将导致缓冲区溢出。

​	

* 163-167行代码：

```C++
static void
CwndChange (uint32_t oldCwnd, uint32_t newCwnd)
{
  NS_LOG_UNCOND (Simulator::Now ().GetSeconds () << "\t" << newCwnd);
}
```

​	fifth.cc的目的是从TCP获取跟踪回调，以指示拥塞窗口已更新。跟之前fourth.cc的大体相似，这里是trace sink的实现。该功能仅记录当前仿真时间和拥塞窗口每次更改时的的新值。 能够想象到我们可以将结果输出到图形程序（gnuplot或Excel）中，从而得到一段时间内拥塞窗口变化的图像。

​	

* 169-173行代码：

```C++
static void
RxDrop (Ptr<const Packet> p)
{
  NS_LOG_UNCOND ("RxDrop at " << Simulator::Now ().GetSeconds ());
}
```

​	我们将通过在主代码代码中添加一个错误模型来想看一下数据包是在何时被丢弃， 所以在这又添加了一个trace sink。该trace sink将连接到点对点NetDevice的“PhyRxDrop”这个trace source。 当NetDevice的物理层丢弃数据包时将触发此trace source。 查看src/point-to-point/model/point-to-point-net-device.cc，会发现此追踪源指向PointToPointNetDevice::m_phyRxDropTrace。 

![image-20200830214738916](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPHM7oliyB3F3jZjHHxx8w*HFM847gqCBM*GG3etqRFQ41mBUI7Lh2H78E1ZNedk8ICYxoKbeD23S8nG7YJcoaE!/r)

​	然后，如果在src/point-to-point/model/point-to-point-net-device.h中查找这个变量，则会发现它对应的声明为`TracedCallback<Ptr<const Packet> > m_phyRxDropTrace`。 这告诉我们对应的回调目标应该是一个返回void并接受单个参数`Ptr <const Packet>`的函数，所以我们应该使用ConnectWithoutContext。

​	

* 175-189行代码：

```C++
int 
main (int argc, char *argv[])
{
  CommandLine cmd (__FILE__);
  cmd.Parse (argc, argv);
  
  NodeContainer nodes;
  nodes.Create (2);

  PointToPointHelper pointToPoint;
  pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
  pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));

  NetDeviceContainer devices;
  devices = pointToPoint.Install (nodes);
```

​	进入主函数。与之前的一样：声明命令行解析器，读取命令行参数，创建两个节点，设置点对点连接并为节点安装网络设备。

​	

* 191-193行代码：

```C++
Ptr<RateErrorModel> em = CreateObject<RateErrorModel> ();
em->SetAttribute ("ErrorRate", DoubleValue (0.00001));
devices.Get (1)->SetAttribute ("ReceiveErrorModel", PointerValue (em));
```

​	这几行代码与之前不同。 如果我们追踪表现良好的连接会导致拥塞窗口单调增加。 我们想查看一些有趣的东西，所以引入了链接错误。将导致丢包以及重复的ACK并触发一些关于拥塞窗口的更有趣的表现。

​	NS3提供了可以附加到Channel上的ErrorModel对象。 我们这里使用了RateErrorModel，它允许我们以给定的速率将错误引入到Channel中。

​	上面的代码实例化了RateErrorModel对象，然后将“ErrorRate”属性设置为所需的值。 然后我们将生成的实例化RateErrorModel设置为点对点NetDevice使用的错误模型。 这将引起一些数据的重传，并使我们的模拟变得更有趣。

​	

* 195-200行代码：

```C++
InternetStackHelper stack;
stack.Install (nodes);

Ipv4AddressHelper address;
address.SetBase ("10.1.1.0", "255.255.255.252");
Ipv4InterfaceContainer interfaces = address.Assign (devices);
```

​	仍然与之前的一样，为节点安装协议栈，创建接口，分配地址。

​	

* 202-207行代码：

```C++
uint16_t sinkPort = 8080;
Address sinkAddress (InetSocketAddress (interfaces.GetAddress (1), sinkPort));
PacketSinkHelper packetSinkHelper ("ns3::TcpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), sinkPort));
ApplicationContainer sinkApps = packetSinkHelper.Install (nodes.Get (1));
sinkApps.Start (Seconds (0.));
sinkApps.Stop (Seconds (20.));
```

​	这里实例化了一个PacketSinkHelper并告诉它使用类ns3::TcpSocketFactory创建套接字。 此类实现一种称为“对象工厂”的设计模式，这是一种用于指定用于以抽象方式创建对象的类的常用机制。 在这里我们不必自己创建对象，而是向PacketSinkHelper提供一个字符串，该字符串指定用于创建对象的TypeId字符串，然后可以使用该字符串创建由工厂创建的对象的实例。剩下的参数告诉应用程序应绑定到哪个地址和端口。

​	然后创建了sinkapp，将它安装在右侧节点上，并设置了它的启动时间与停止时间。

​	

* 209-210行代码：

```C++
Ptr<Socket> ns3TcpSocket = Socket::CreateSocket (nodes.Get (0), TcpSocketFactory::GetTypeId ());
ns3TcpSocket->TraceConnectWithoutContext ("CongestionWindow", MakeCallback (&CwndChange));
```

​	第一句代码调用静态成员函数Socket::CreateSocket，并为创建套接字的对象工厂提供Node和显式TypeId。 与上面的PacketSinkHelper调用相比这是一个较低级别的调用，它使用显式C++类型而不是由字符串引用的类型。 否则从概念上讲这将是同一件事。

​	创建TcpSocket并将其安装到节点后，我们可以使用TraceConnectWithoutContext将CongestionWindow这个trace source连接到trace sink。

​	

* 212-216行代码：

```C++
Ptr<MyApp> app = CreateObject<MyApp> ();
app->Setup (ns3TcpSocket, sinkAddress, 1040, 1000, DataRate ("1Mbps"));
nodes.Get (0)->AddApplication (app);
app->SetStartTime (Seconds (1.));
app->SetStopTime (Seconds (20.));
```

​	我们编写了自己的MyApp，因此我们可以在配置期间使用刚制作的套接字并将其用于仿真时间。 现在我们必须实例化该应用程序。与前面的案例不同，我们没有创建一个助手来管理应用程序，因此我们将不得不“手动”创建和安装它：

​	第一行创建一个MyApp类型的我们自己的应用程序。 第二行告诉应用程序要使用哪个套接字，连接到哪个地址，在每个发送事件中发送多少数据，要生成多少个发送事件以及从这些事件中产生数据的速率。接下来我们手动将MyApp应用程序添加到源节点，并在应用程序上显式调用Start和Stop方法，以告知它何时启动和停止。

​	

* 218行代码：

```C++
devices.Get (1)->TraceConnectWithoutContext ("PhyRxDrop", MakeCallback (&RxDrop));
```

​	在右侧点对点节点的NetDevice上将由属性“PhyRxDrop”定义的trace source连接到trace sink RxDrop。

​	

* 220-225行代码：

```C++
  Simulator::Stop (Seconds (20));
  Simulator::Run ();
  Simulator::Destroy ();

  return 0;
}
```

​	告诉模拟器在模拟开始20秒后停止处理时间。当Simulator::Run被调用时配置时间结束，并且紧接着模拟时间开始。 我们实际上是Simulator::Run调用期间通过创建应用程序并告诉它其如何连接和发送数据以及安排所有的工作的。

​	

#### 3.11.3 编译运行

​	命令行输入以下代码：

```shell
$ ./waf --run scratch/fifth
```

​	可以在命令行中看到输出太多了。这些无关的waf消息和RxDrop消息一起被打印到我们感兴趣的信息中。让我们注释掉RxDrop的声明及打印数据包被丢弃的第169-173、218行代码：

```C++
// static void
// RxDrop(Ptr<const Packet> p)
// {
//     NS_LOG_UNCOND("RxDrop at " << Simulator::Now().GetSeconds());
// }
……
……
//devices.Get (1)->TraceConnectWithoutContext ("PhyRxDrop", MakeCallback (&RxDrop));
```

​	将输出重定向到名为cwnd.dat的文件：

```shell
$ ./waf --run scratch/fifth > cwnd.dat 2>&1
```

​	这里由于我们将输出重定向了，所以在命令行里看不到任何输出。进入ns3.31目录，将会找到输出文件：

![image-20200830233058430](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPWPkQwQiUwttkYG4JuGOzXAfCsCfK*f3*.EXcMbH3PjEqaJAGBHR6469EiWVCekQY9Orf7zvEyRbqwz8XT2BpI!/r)

​	下面将输出信息用gnuplot绘制出图像：

​	在vscode中打开，共997行代码。删除掉前6行waf的过程，保存。

​	安装gnuplot，命令行输入：

```shell
$ sudo apt-get install gnuplot -y
```

​	提示输入root密码，输入后自动安装。

​	安装后，在命令行输入以下代码进行绘图：

```shell
$ gnuplot
gnuplot> set terminal png size 640,480
gnuplot> set output "cwnd.png"
gnuplot> plot "cwnd.dat" using 1:2 title 'Congestion Window' with linespoints
gnuplot> exit
```

​	在ns3.31目录中，能看到我们得到的图：

![image-20200831000329101](http://m.qpic.cn/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEOzUc1dOkjQ3Y9RrArYTDgTNwAB5GazZ.bXKlimLXSzA.V.QKi2N.ECsLbc2wBuJBMnF4IwXcgWCl9vzkHNu8RA!/b&bo=gALgAQAAAAABF1M!&rf=viewer_4)

​	

### 3.12 sixth.cc

​	在fifth.cc中展示了如何挂钩trace source以从模拟中获得我们感兴趣的信息。回想我们在fourth.cc中使用std::cout输出日志，还讨论了为了筛选出感兴趣的信息而必须解析日志输出的问题。我们花了很多时间来实现一个示例，它展示了我们使用NS3追踪系统解决的所有问题，但是我们还没有完成。

​	我们要做的最重要的事情之一就是能够轻松地控制模拟输出的数量。并且我们还希望将这些数据保存到文件中，以便以后参考使用。我们可以使用NS3中提供的中级跟踪助手来完成此任务并完成整个过程。

​	sixth.cc将fifth.cc中的cwnd变化存储为制表符分隔的ASCII文件，而drop事件存储在PCAP文件中。实现这一目标只需要进行少量的修改。

​	

#### 3.12.1 代码学习

​	以下为sixth.cc的代码，大体框架与fifth.cc相似，主要关注与fifth.cc不同的地方：

```C++
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <fstream>
#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"

using namespace ns3;

NS_LOG_COMPONENT_DEFINE ("SixthScriptExample");

// ===========================================================================
//
//         node 0                 node 1
//   +----------------+    +----------------+
//   |    ns-3 TCP    |    |    ns-3 TCP    |
//   +----------------+    +----------------+
//   |    10.1.1.1    |    |    10.1.1.2    |
//   +----------------+    +----------------+
//   | point-to-point |    | point-to-point |
//   +----------------+    +----------------+
//           |                     |
//           +---------------------+
//                5 Mbps, 2 ms
//
//
// We want to look at changes in the ns-3 TCP congestion window.  We need
// to crank up a flow and hook the CongestionWindow attribute on the socket
// of the sender.  Normally one would use an on-off application to generate a
// flow, but this has a couple of problems.  First, the socket of the on-off
// application is not created until Application Start time, so we wouldn't be
// able to hook the socket (now) at configuration time.  Second, even if we
// could arrange a call after start time, the socket is not public so we
// couldn't get at it.
//
// So, we can cook up a simple version of the on-off application that does what
// we want.  On the plus side we don't need all of the complexity of the on-off
// application.  On the minus side, we don't have a helper, so we have to get
// a little more involved in the details, but this is trivial.
//
// So first, we create a socket and do the trace connect on it; then we pass
// this socket into the constructor of our simple application which we then
// install in the source node.
// ===========================================================================
//
class MyApp : public Application
{
public:
  MyApp ();
  virtual ~MyApp ();

  /**
   * Register this type.
   * \return The TypeId.
   */
  static TypeId GetTypeId (void);
  void Setup (Ptr<Socket> socket, Address address, uint32_t packetSize, uint32_t nPackets, DataRate dataRate);

private:
  virtual void StartApplication (void);
  virtual void StopApplication (void);

  void ScheduleTx (void);
  void SendPacket (void);

  Ptr<Socket>     m_socket;
  Address         m_peer;
  uint32_t        m_packetSize;
  uint32_t        m_nPackets;
  DataRate        m_dataRate;
  EventId         m_sendEvent;
  bool            m_running;
  uint32_t        m_packetsSent;
};

MyApp::MyApp ()
  : m_socket (0),
    m_peer (),
    m_packetSize (0),
    m_nPackets (0),
    m_dataRate (0),
    m_sendEvent (),
    m_running (false),
    m_packetsSent (0)
{
}

MyApp::~MyApp ()
{
  m_socket = 0;
}

/* static */
TypeId MyApp::GetTypeId (void)
{
  static TypeId tid = TypeId ("MyApp")
    .SetParent<Application> ()
    .SetGroupName ("Tutorial")
    .AddConstructor<MyApp> ()
    ;
  return tid;
}

void
MyApp::Setup (Ptr<Socket> socket, Address address, uint32_t packetSize, uint32_t nPackets, DataRate dataRate)
{
  m_socket = socket;
  m_peer = address;
  m_packetSize = packetSize;
  m_nPackets = nPackets;
  m_dataRate = dataRate;
}

void
MyApp::StartApplication (void)
{
  m_running = true;
  m_packetsSent = 0;
  m_socket->Bind ();
  m_socket->Connect (m_peer);
  SendPacket ();
}

void
MyApp::StopApplication (void)
{
  m_running = false;

  if (m_sendEvent.IsRunning ())
    {
      Simulator::Cancel (m_sendEvent);
    }

  if (m_socket)
    {
      m_socket->Close ();
    }
}

void
MyApp::SendPacket (void)
{
  Ptr<Packet> packet = Create<Packet> (m_packetSize);
  m_socket->Send (packet);

  if (++m_packetsSent < m_nPackets)
    {
      ScheduleTx ();
    }
}

void
MyApp::ScheduleTx (void)
{
  if (m_running)
    {
      Time tNext (Seconds (m_packetSize * 8 / static_cast<double> (m_dataRate.GetBitRate ())));
      m_sendEvent = Simulator::Schedule (tNext, &MyApp::SendPacket, this);
    }
}

static void
CwndChange (Ptr<OutputStreamWrapper> stream, uint32_t oldCwnd, uint32_t newCwnd)
{
  NS_LOG_UNCOND (Simulator::Now ().GetSeconds () << "\t" << newCwnd);
  *stream->GetStream () << Simulator::Now ().GetSeconds () << "\t" << oldCwnd << "\t" << newCwnd << std::endl;
}

static void
RxDrop (Ptr<PcapFileWrapper> file, Ptr<const Packet> p)
{
  NS_LOG_UNCOND ("RxDrop at " << Simulator::Now ().GetSeconds ());
  file->Write (Simulator::Now (), p);
}

int
main (int argc, char *argv[])
{
  CommandLine cmd (__FILE__);
  cmd.Parse (argc, argv);
  
  NodeContainer nodes;
  nodes.Create (2);

  PointToPointHelper pointToPoint;
  pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
  pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));

  NetDeviceContainer devices;
  devices = pointToPoint.Install (nodes);

  Ptr<RateErrorModel> em = CreateObject<RateErrorModel> ();
  em->SetAttribute ("ErrorRate", DoubleValue (0.00001));
  devices.Get (1)->SetAttribute ("ReceiveErrorModel", PointerValue (em));

  InternetStackHelper stack;
  stack.Install (nodes);

  Ipv4AddressHelper address;
  address.SetBase ("10.1.1.0", "255.255.255.252");
  Ipv4InterfaceContainer interfaces = address.Assign (devices);

  uint16_t sinkPort = 8080;
  Address sinkAddress (InetSocketAddress (interfaces.GetAddress (1), sinkPort));
  PacketSinkHelper packetSinkHelper ("ns3::TcpSocketFactory", InetSocketAddress (Ipv4Address::GetAny (), sinkPort));
  ApplicationContainer sinkApps = packetSinkHelper.Install (nodes.Get (1));
  sinkApps.Start (Seconds (0.));
  sinkApps.Stop (Seconds (20.));

  Ptr<Socket> ns3TcpSocket = Socket::CreateSocket (nodes.Get (0), TcpSocketFactory::GetTypeId ());

  Ptr<MyApp> app = CreateObject<MyApp> ();
  app->Setup (ns3TcpSocket, sinkAddress, 1040, 1000, DataRate ("1Mbps"));
  nodes.Get (0)->AddApplication (app);
  app->SetStartTime (Seconds (1.));
  app->SetStopTime (Seconds (20.));

  AsciiTraceHelper asciiTraceHelper;
  Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("sixth.cwnd");
  ns3TcpSocket->TraceConnectWithoutContext ("CongestionWindow", MakeBoundCallback (&CwndChange, stream));

  PcapHelper pcapHelper;
  Ptr<PcapFileWrapper> file = pcapHelper.CreateFile ("sixth.pcap", std::ios::out, PcapHelper::DLT_PPP);
  devices.Get (1)->TraceConnectWithoutContext ("PhyRxDrop", MakeBoundCallback (&RxDrop, file));

  Simulator::Stop (Seconds (20));
  Simulator::Run ();
  Simulator::Destroy ();

  return 0;
}


```

​	下面仅列出不一样的代码。

* 178-183行代码：

```C++
static void
CwndChange (Ptr<OutputStreamWrapper> stream, uint32_t oldCwnd, uint32_t newCwnd)
{
  NS_LOG_UNCOND (Simulator::Now ().GetSeconds () << "\t" << newCwnd);
  *stream->GetStream () << Simulator::Now ().GetSeconds () << "\t" << oldCwnd << "\t" << newCwnd << std::endl;
}
```

​	添加了一个“stream”参数。这是一个保存C++ 输出流的对象。事实上它是一个非常简单的对象，但是它可以管理流的生命周期并解决甚至有经验的C++ 用户都遇到的问题。std::ostream的拷贝构造函数是私有的，这意味着std::ostream不遵循值语义，并且不能在包括NS3回调系统的任何需要复制流的机制中使用。因为它需要遵循值语义的对象。这段代码的最后一句很熟悉，如果把`*stream->GetStream()`换成`std::cout`就更熟悉了。

​	追一下OutputStreamWapper类：

```C++
//output-stream-wrapper.h
class OutputStreamWrapper : public SimpleRefCount<OutputStreamWrapper>
{
public:
  /**
   * Constructor
   * \param filename file name
   * \param filemode std::ios::openmode flags
   */
  OutputStreamWrapper (std::string filename, std::ios::openmode filemode);
  /**
   * Constructor
   * \param os output stream
   */
  OutputStreamWrapper (std::ostream* os);
  ~OutputStreamWrapper ();

  /**
   * Return a pointer to an ostream previously set in the wrapper.
   *
   * \see SetStream
   *
   * \returns a pointer to the encapsulated std::ostream
   */
  std::ostream *GetStream (void);

private:
  std::ostream *m_ostream; //!< The output stream
  bool m_destroyable; //!< Can be destroyed
};
```

​	再追一下实现：

```C++
//output-stream-wrapper.cc
OutputStreamWrapper::OutputStreamWrapper (std::string filename, std::ios::openmode filemode)
  : m_destroyable (true)
{
  NS_LOG_FUNCTION (this << filename << filemode);
  std::ofstream* os = new std::ofstream ();
  os->open (filename.c_str (), filemode);
  m_ostream = os;
  FatalImpl::RegisterStream (m_ostream);
  NS_ABORT_MSG_UNLESS (os->is_open (), "AsciiTraceHelper::CreateFileStream():  " <<
                       "Unable to Open " << filename << " for mode " << filemode);
}

OutputStreamWrapper::OutputStreamWrapper (std::ostream* os)
  : m_ostream (os), m_destroyable (false)
{
  NS_LOG_FUNCTION (this << os);
  FatalImpl::RegisterStream (m_ostream);
  NS_ABORT_MSG_UNLESS (m_ostream->good (), "Output stream is not valid for writing.");
}

OutputStreamWrapper::~OutputStreamWrapper ()
{
  NS_LOG_FUNCTION (this);
  FatalImpl::UnregisterStream (m_ostream);
  if (m_destroyable) delete m_ostream;
  m_ostream = 0;
}

std::ostream *
OutputStreamWrapper::GetStream (void)
{
  NS_LOG_FUNCTION (this);
  return m_ostream;
}
```

​	可以看到`Ptr<OutputStreamWrapper>`实际上只是携带了`std::ofstream`，可以像在其他任何输出流中一样在这里使用它。

​	

* 185-190行代码：

```C++
static void
RxDrop (Ptr<PcapFileWrapper> file, Ptr<const Packet> p)
{
  NS_LOG_UNCOND ("RxDrop at " << Simulator::Now ().GetSeconds ());
  file->Write (Simulator::Now (), p);
}
```

​	RxDrop中也有类似的情况，可以向PCAP文件中写入时间戳以及数据包。

​	

* 234-236行代码：

```C++
AsciiTraceHelper asciiTraceHelper;
Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("sixth.cwnd");
ns3TcpSocket->TraceConnectWithoutContext ("CongestionWindow", MakeBoundCallback (&CwndChange, stream));
```

​	追一下.CreateFileStream()这个方法：

```C++
//trace-helper.h
class AsciiTraceHelper
{
public: 
……
Ptr<OutputStreamWrapper> CreateFileStream (std::string filename, 
                                             std::ios::openmode filemode = std::ios::out);
……
};
```

​	再追一下实现：

```C++
//trace-helper.cc
Ptr<OutputStreamWrapper>
AsciiTraceHelper::CreateFileStream (std::string filename, std::ios::openmode filemode)
{
  NS_LOG_FUNCTION (filename << filemode);

  Ptr<OutputStreamWrapper> StreamWrapper = Create<OutputStreamWrapper> (filename, filemode);

  //
  // Note that the ascii trace helper promptly forgets all about the trace file.
  // We rely on the reference count of the file object which will soon be owned
  // by the caller to keep the object alive.  If the caller uses the stream 
  // object to hook a trace source, ownership of the stream object will be
  // implicitly transferred to the callback which keeps the object alive.
  // When the callback is destroyed (when either the trace is disconnected or
  // the object with the trace source is deleted) the callback will be destroyed
  // and the stream object will be destroyed, releasing the pointer and closing
  // the underlying file.
  //
  return StreamWrapper;
}
```

​	在这段代码中我们将创建ASCII追踪文件，创建一个负责管理它的对象，并使用回调创建函数的变体安排将该对象传递给trace sink。ASCII追踪助手提供了丰富的功能，从而使得我们更容易使用文本（ASCII）文件。我们将在这里说明文件流创建功能的用法。

​	CreateFileStream函数将实例化一个std::ofstream对象并创建一个新文件（或截断一个现有文件）。此std::ofstream对象打包在NS3对象中，以进行生命周期管理和解决拷贝构造函数的问题。

​	然后将表示文件的NS3对象传递给MakeBoundCallback()。该函数会像MakeCallback()一样创建一个回调，但会将一个新值“绑定”到该回调。在调用之前，此新值将作为第一个参数添加到回调中。

​	本质上，MakeBoundCallback(&CwndChange , stream)使得trace source在调用回调之前将附加的“stream”参数添加到形参列表中。这将更改CwndChange这个trace sink所需的签名以匹配上面包含“额外”的`Ptr<OutputStreamWrapper>`流参数的签名。

​	

* 238-240行代码：

```C++
PcapHelper pcapHelper;
Ptr<PcapFileWrapper> file = pcapHelper.CreateFile ("sixth.pcap", std::ios::out, PcapHelper::DLT_PPP);
devices.Get (1)->TraceConnectWithoutContext ("PhyRxDrop", MakeBoundCallback (&RxDrop, file));
```

​	追一下.CreateFile()这个方法：

```C++
//trace-helper.h
/**
   * @brief Create and initialize a pcap file.
   * 
   * @param filename file name
   * @param filemode file mode
   * @param dataLinkType data link type of packet data
   * @param snapLen maximum length of packet data stored in records
   * @param tzCorrection time zone correction to be applied to timestamps of packets
   * @returns a smart pointer to the Pcap file
   */
  Ptr<PcapFileWrapper> CreateFile (std::string filename,
                                   std::ios::openmode filemode,
                                   DataLinkType dataLinkType,
                                   uint32_t snapLen = std::numeric_limits<uint32_t>::max (),
                                   int32_t tzCorrection = 0);
```

​	再追一下实现：

```C++
tr<PcapFileWrapper>
PcapHelper::CreateFile (
  std::string filename, 
  std::ios::openmode filemode,
  DataLinkType dataLinkType,
  uint32_t    snapLen, 
  int32_t     tzCorrection)
{
  NS_LOG_FUNCTION (filename << filemode << dataLinkType << snapLen << tzCorrection);

  Ptr<PcapFileWrapper> file = CreateObject<PcapFileWrapper> ();
  file->Open (filename, filemode);
  NS_ABORT_MSG_IF (file->Fail (), "Unable to Open " << filename << " for mode " << filemode);

  file->Init (dataLinkType, snapLen, tzCorrection);
  NS_ABORT_MSG_IF (file->Fail (), "Unable to Init " << filename);

  //
  // Note that the pcap helper promptly forgets all about the pcap file.  We
  // rely on the reference count of the file object which will soon be owned
  // by the caller to keep the object alive.  If the caller uses the file 
  // object to hook a trace source, ownership of the file object will be
  // implicitly transferred to the callback which keeps the object alive.
  // When the callback is destroyed (when either the trace is disconnected or
  // the object with the trace source is deleted) the callback will be destroyed
  // and the file object will be destroyed, releasing the pointer and closing
  // the file.
  //
  return file;
}
```

​	这段代码我们实例化了一个PcapHelper对象来对我们的PCAP追踪文件执行与使用AsciiTraceHelper相同的操作。代码行用文件模式“std::ios::out”创建一个名为“sixth.pcap”的PCAP文件。如果找到具有该名称的现有文件，则新文件将被截断（删除内容）。最后一个参数是新PCAP文件的“数据链接类型”，与bpf.h中定义的PCAP库数据链接类型相同。在这种情况下，DLT_PPP表示PCAP文件将包含以点对点标题为前缀的数据包。这是因为数据包来自我们的点对点设备驱动程序。其他常见的数据链路类型是适用于csma设备的DLT_EN10MB（10 MB以太网）和适用于wifi设备的DLT_IEEE802_11（IEEE 802.11）。这些参数在src/network/helper/trace-helper.h中定义。列表中的条目与bpf.h中的条目匹配，但我们将它们复制出来以避免PCAP源依赖。最后像前面ASCII的那样，从CreateFile返回一个在绑定回调中使用的、表示PCAP文件的NS3对象。

​	

​	很重要的一点：虽然`Ptr<PcapFileWrapper> file`与`Ptr<OutputStreamWrapper> stream`的声明比较相似，但他们的基类完全不同。

```C++
//pcap-file-wrapper.h
class PcapFileWrapper : public Object
{
public:
  /**
   * \brief Get the type ID.
   * \return the object TypeId
   */
  static TypeId GetTypeId (void);

  PcapFileWrapper ();
  ~PcapFileWrapper ();
  ……
};
```

```C++
//output-stream-wrapper.h
class OutputStreamWrapper : public SimpleRefCount<OutputStreamWrapper>
{
public:
  /**
   * Constructor
   * \param filename file name
   * \param filemode std::ios::openmode flags
   */
  OutputStreamWrapper (std::string filename, std::ios::openmode filemode);
  /**
   * Constructor
   * \param os output stream
   */
  OutputStreamWrapper (std::ostream* os);
  ~OutputStreamWrapper ();

  /**
   * Return a pointer to an ostream previously set in the wrapper.
   *
   * \see SetStream
   *
   * \returns a pointer to the encapsulated std::ostream
   */
  std::ostream *GetStream (void);

private:
  std::ostream *m_ostream; //!< The output stream
  bool m_destroyable; //!< Can be destroyed
};
```



​	`Ptr<PcapFileWrapper>`凭借其继承性而成为NS3对象，它是指向NS3对象的智能指针，这是相当重要的东西，它支持SetAttribute并集成到Config系统中。 另一方面，`Ptr<OutputStreamWrapper>`根本不是NS3对象，它仅仅是一个恰好支持介入式引用计数的C++对象。它是一个非常轻巧的指向引用计数对象的智能指针。 可以通过在sixth.cc中输入`file->`与`stream->`给的代码提示提示来看出来二者功能的多少。在对对象可能具有的“能力”进行任何假设之前要先查看要引用的对象。

​	

#### 3.12.2 编译运行

​	下面来编译运行，在命令行输入：

```shell
$ ./waf --run scratch/sixth
```

​	虽然我们看到输出仍然很多，但我们能在ns3.31目录下看到生成的文件：

![image-20200831221033144](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEHJ2Jb1eCBKLLK.IexTEhxfqHN2QUarFNYf*n0IPAYSwVuwSOBXg.dI0OT.T5TgcE8THHhr6tj3TCS6d3iMFk4k!/r)

​	可以在vscode里打开sixth.cwnd来查看输出：

![image-20200831221729018](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrELNr0F.nY.VQcBDW26qSwteZZTZd363WQKFAiUOYPzKD*Wp637ytX76PM9tUsHuJXg.dySWMPOn2XL5oCKiGp0A!/r)

​	由于我们在fifth.cc中只打印了新的cwnd，而在sixth.cc中新旧都打印了。所以fifth.cc的数据是两列，而sixth.cc的数据是三列。

​	

​	用tcpdump查看PCAP数据包：

```shell
$ tcpdump -nn -tt -r sixth.pcap
```

![image-20200831222712507](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEPRIOKqlHCfC8qUrsc6IBpsgjhu4797Vq38t1KofHVns249AUkcqXvenqwIbxuLxmVuT2FWKsSSdWLZXb5bWRDQ!/r)

​	其中包含在模拟中被丢弃的数据包。 并且该文件中没有其他正常发送的数据包。

​	

​	总结一下，我们已将重要事件从TCP实现和设备驱动程序的中间拉出来，并且将这些事件直接存储在可使用常见工具打开的文件中。 我们做到了这一点但没有修改任何涉及的核心代码，并且只用了以下18行核心代码就做到了：

```C++
static void
CwndChange (Ptr<OutputStreamWrapper> stream, uint32_t oldCwnd, uint32_t newCwnd)
{
  NS_LOG_UNCOND (Simulator::Now ().GetSeconds () << "\t" << newCwnd);
  *stream->GetStream () << Simulator::Now ().GetSeconds () << "\t" << oldCwnd << "\t" << newCwnd << std::endl;
}

AsciiTraceHelper asciiTraceHelper;
Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("sixth.cwnd");
ns3TcpSocket->TraceConnectWithoutContext ("CongestionWindow", MakeBoundCallback (&CwndChange, stream));

static void
RxDrop (Ptr<PcapFileWrapper> file, Ptr<const Packet> p)
{
  NS_LOG_UNCOND ("RxDrop at " << Simulator::Now ().GetSeconds ());
  file->Write (Simulator::Now (), p);
}

PcapHelper pcapHelper;
Ptr<PcapFileWrapper> file = pcapHelper.CreateFile ("sixth.pcap", std::ios::out, PcapHelper::DLT_PPP);
devices.Get (1)->TraceConnectWithoutContext ("PhyRxDrop", MakeBoundCallback (&RxDrop, file));
```

​	

### 3.13 追踪助手

​	NS3的追踪助手为配置和选择不同的跟踪事件并将其写入文件提供了一个丰富的环境。 在前面的部分（second.cc、third.cc）中，我们看到了用于其他（设备）助手中的多种追踪助手方法。以前我们曾经使用过以下代码：

```C++
pointToPoint.EnablePcapAll ("second");
pointToPoint.EnablePcap ("second", p2pNodes.Get (0)->GetId (), 0);
csma.EnablePcap ("third", csmaDevices.Get (0), true);
pointToPoint.EnableAsciiAll (ascii.CreateFileStream ("first.tr"));
```

​	可能不明显的是，系统中所有与追踪相关的方法都有一个一致的模型。 现在我们将花一点时间看一下“全局”。

​	当前在NS3中有两个主要的追踪助手用例：设备助手和协议助手。 设备助手着眼于指定在哪个节点的哪个设备上启用哪些追踪的问题。 例如，可能想要指定应该在特定节点上的特定设备上启用PCAP追踪。 这源于NS3的设备概念模型以及各种设备助手的概念模型。 所以自然而然地，创建的PCAP文件遵循`<前缀>-<节点号>-<设备号>`的命名规则。协议助手着眼于指定在哪个协议的哪个接口上启用哪些追踪的问题。 这是从NS3协议栈概念模型以及网络协议栈助手的概念模型得出的。 同理，追踪文件应遵循`<前缀>-<协议号>-<接口号>`的命名规则。

​	因此，追踪助手问题自然地属于二维分类法。 有一些细微的差别会阻止所有四个类的行为相同，但是我们会尽力使它们都尽可能相似地工作。 只要有可能的话，所有类中的所有方法都会有相似点。

|          | **PCAP追踪** | **ASCII追踪** |
| -------- | ------------ | ------------- |
| 设备助手 | ✔            | ✔             |
| 协议助手 | ✔            | ✔             |

​	我们使用一种称为mixin的方法将追踪功能添加到我们的助手类中。mixin是有部分或者全部实现的接口，其主要作用是代码复用。它是一个由子类继承时提供功能的类。 从mixin继承不被视为一种特殊形式，但实际上是一种收集功能的方式。让我们快速看一下这四种情况及其各自的mixin：

​	

#### 3.13.1 设备助手

##### PCAP追踪

​	这些助手的目的是使向NS3设备添加一致的PCAP追踪工具变得容易。 我们希望所有PCAP追踪样式在所有设备上都可以正常工作，因此这些助手的方法由设备助手继承。 

​	PcapHelperForDevice类为在NS3设备中使用PCAP追踪提供了高级功能的mixin。每个设备都必须实现一个从此类mixin继承的单个虚拟方法。



​	以下代码都在src/network/helper/trace-helper.h中：

```C++
class PcapHelperForDevice
{
public:
……
/**
   * @brief Enable pcap output the indicated net device.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param nd Net device for which you want to enable tracing.
   * @param promiscuous If true capture all possible packets available at the device.
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  virtual void EnablePcapInternal (std::string prefix, Ptr<NetDevice> nd, bool promiscuous, bool explicitFilename) = 0;
……
};
```

​	此方法的签名反映了此级别上以设备为中心的情况。 从PcapHelperForDevice类继承的所有公共方法都将调用这个独立于设备的实现方法。 例如，最低级别的PCAP方法：

```C++
/**
   * @brief Enable pcap output the indicated net device.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param nd Net device for which you want to enable tracing.
   * @param promiscuous If true capture all possible packets available at the device.
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  void EnablePcap (std::string prefix, Ptr<NetDevice> nd, bool promiscuous = false, bool explicitFilename = false);

//对应的实现
  void 
PcapHelperForDevice::EnablePcap (std::string prefix, Ptr<NetDevice> nd, bool promiscuous, bool explicitFilename)
{
  EnablePcapInternal (prefix, nd, promiscuous, explicitFilename);
}
```

​	将直接调用EnablePcapInternal的设备实现。 所有其他公共的PCAP跟踪方法均以该实现为基础，以提供其他用户级别的功能。 对用户而言，意味着系统中的所有设备助手都将具有所有可用的PCAP追踪方法。 如果正确实现EnablePcapInternal，则这些方法在所有设备上都将以相同的方式工作。

​	

###### 方法

```C++
  /**
   * @brief Enable pcap output the indicated net device.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param nd Net device for which you want to enable tracing.
   * @param promiscuous If true capture all possible packets available at the device.
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  void EnablePcap (std::string prefix, Ptr<NetDevice> nd, bool promiscuous = false, bool explicitFilename = false);

  /**
   * @brief Enable pcap output the indicated net device using a device previously
   * named using the ns-3 object name service.
   *
   * @param prefix filename prefix to use for pcap files.
   * @param ndName The name of the net device in which you want to enable tracing.
   * @param promiscuous If true capture all possible packets available at the device.
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  void EnablePcap (std::string prefix, std::string ndName, bool promiscuous = false, bool explicitFilename = false);

  /**
   * @brief Enable pcap output on each device in the container which is of the 
   * appropriate type.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param d container of devices of type ns3::CsmaNetDevice
   * @param promiscuous If true capture all possible packets available at the device.
   */
  void EnablePcap (std::string prefix, NetDeviceContainer d, bool promiscuous = false);

  /**
   * @brief Enable pcap output on each device (which is of the appropriate type)
   * in the nodes provided in the container.
   *
   * \param prefix Filename prefix to use for pcap files.
   * \param n container of nodes.
   * \param promiscuous If true capture all possible packets available at the device.
   */
  void EnablePcap (std::string prefix, NodeContainer n, bool promiscuous = false);

  /**
   * @brief Enable pcap output on the device specified by a global node-id (of
   * a previously created node) and associated device-id.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param nodeid the node id
   * @param deviceid the device id
   * @param promiscuous If true capture all possible packets available at the device.
   */
  void EnablePcap (std::string prefix, uint32_t nodeid, uint32_t deviceid, bool promiscuous = false);

  /**
   * @brief Enable pcap output on each device (which is of the appropriate type)
   * in the set of all nodes created in the simulation.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param promiscuous If true capture all possible packets available at the device.
   */
  void EnablePcapAll (std::string prefix, bool promiscuous = false);
};
```

​	上面每个方法中，都有一个称为promiscuous的默认参数，默认为false。 此参数表示不开启混杂嗅探。 如果我们希望追踪信息包含设备看到的所有流量（并且设备支持混杂嗅探模式），则只需将true参数添加到上述任何调用中即可。 例如：

```C++
Ptr<NetDevice> nd;
...
helper.EnablePcap ("prefix", nd, true);
```

​	将会在nd这个NetDevice上开启混杂嗅探。

​	

​	前两个方法还包括一个称为explicitFilename的默认参数，下一部分将对其进行讨论。

* 可以通过向EnablePcap方法提供`Ptr<NetDevice>`来启用特定“节点/网络设备”对上的PCAP追踪。 由于网络设备必须属于一个节点，因此`Ptr<Node>`是隐式的。 例如：

    ```C++
    Ptr<NetDevice> nd;
    ...
    helper.EnablePcap ("prefix", nd);
    ```

    ​	

* 可以通过向EnablePcap方法提供表示对象名称服务字符串的std::string来在特定的“节点/网络设备”对上启用PCAP追踪。这将会从名称字符串中查找`Ptr<NetDevice>`。 因为声明的网络设备必须恰好属于一个节点，所以同样`<Node>`是隐式的。例如：

    ```C++
    Names::Add ("server" ...);
    Names::Add ("server/eth0" ...);
    ...
    helper.EnablePcap ("prefix", "server/ath0");
    ```

    ​	

* 可以通过向EnablePcap方法提供NetDeviceContainer来在“节点/网络设备”对的集合上启用PCAP追踪。 对于容器中的每个NetDevice都会检查其类型。 对于与设备助手所管理的类型相同的每个设备将会启用追踪。因为找到的网络设备必须恰好属于一个节点，所以同样`<Node>`是隐式的。 例如：

    ```C++
    NetDeviceContainer d = ...;
    ...
    helper.EnablePcap ("prefix", d);
    ```

    ​	

* 可以通过向EnablePcap方法提供NodeContainer来在“节点/网络设备”对的集合上启用PCAP追踪。 对于NodeContainer中的每个节点都会迭代其连接的NetDevices并检查设备的类型。 对于与设备助手所管理的类型相同的每个设备将启用追踪。例如：

    ```C++
    NodeContainer n;
    ...
    helper.EnablePcap ("prefix", n);
    ```

    ​	

* 可以通过向EnablePcap方法提供显式的节点ID与设备ID来启用PCAP追踪。 系统中的每个节点都有一个整型的节点ID，连接到该节点的每个设备都有一个整型的设备ID。例如：

    ```C++
    helper.EnablePcap ("prefix", 21, 1);
    ```

    ​	

* 可以使用EnablePcapAll来为系统中类型与设备助手所管理的类型相同的所有设备启用PCAP追踪。例如：

    ```C++
    helper.EnablePcapAll ("prefix");
    ```

    ​	

###### 文件名

​	上面提到的方法中暗含的是通过实现方法构造完整的文件名。NS3中的PCAP文件的格式为`<前缀>-<节点号>-<设备号>.pcap`

​	如前所述，系统中的每个节点都将具有系统分配的节点号。 每个设备都将具有相对于其节点的接口索引（也称为设备号）。 默认情况下，在使用前缀“prefix”的节点21的设备1上启用追踪而创建的PCAP追踪文件名将为prefix-21-1.pcap。

​	可以使用NS3对象名称服务来使这一点更加明显。 例如，使用对象名称服务将名称“server”分配给节点21，则生成的PCAP文件名将自动变为prefix-server-1.pcap。并且如果还将名称“eth0”分配给设备，对应的PCAP文件名将自动选择该名称，并将其命名为prefix-server-eth0.pcap。

​	最后，以下两种方法：

```C++
void EnablePcap (std::string prefix, Ptr<NetDevice> nd, bool promiscuous = false, bool explicitFilename = false);
void EnablePcap (std::string prefix, std::string ndName, bool promiscuous = false, bool explicitFilename = false);
```

​	有一个名为explicitFilename的默认为false的参数。 设置为true时将禁用自动文件名完成机制并允许我们创建显式文件名。 该选项仅在启用单个设备上的PCAP追踪的方法中可用。

​	例如，为了让设备助手在给定设备上创建一个特定名称my-pcap-file.pcap的单个混杂嗅探的PCAP文件，可以使用：

```C++
Ptr<NetDevice> nd;
...
helper.EnablePcap ("my-pcap-file.pcap", nd, true, true);
```

​	其中第一个true启用混杂嗅探，第二个true告诉助手将前缀参数解释为完整的文件名。

​	

##### ASCII追踪

​	ASCII追踪助手的mixin行为与PCAP版本基本相似。AsciiTraceHelperForDevice类向设备助手类添加了使用ASCII助手的高级功能。 与PCAP的情况一样，每个设备都必须实现从此类mixin继承的单个虚拟方法。

​	

​	以下代码都在src/network/helper/trace-helper.h中：

```C++
class AsciiTraceHelperForDevice
{
public:
  ……
  /* @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * @param prefix Filename prefix to use for ascii trace files.
   * @param nd Net device for which you want to enable tracing
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  virtual void EnableAsciiInternal (Ptr<OutputStreamWrapper> stream, 
                                    std::string prefix, 
                                    Ptr<NetDevice> nd,
                                    bool explicitFilename) = 0;
  ……
};
```

​	此方法的签名反映了该级别设备以状态为中心的情况； 以及助手可能正在写入共享输出流的事实。 从AsciiTraceHelperForDevice类继承的所有与ASCII追踪相关的公共方法都简化为调用此与设备有关的实现方法。 例如，最低级别的ASCII追踪方法：

```C++
/**
   * @brief Enable ascii trace output on the indicated net device.
   *
   * @param prefix Filename prefix to use for ascii files.
   * @param nd Net device for which you want to enable tracing.
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  void EnableAscii (std::string prefix, Ptr<NetDevice> nd, bool explicitFilename = false);

  /**
   * @brief Enable ascii trace output on the indicated net device.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * @param nd Net device for which you want to enable tracing.
   */
  void EnableAscii (Ptr<OutputStreamWrapper> stream, Ptr<NetDevice> nd);
……

//对应文件中的实现：
  void 
AsciiTraceHelperForDevice::EnableAscii (std::string prefix, Ptr<NetDevice> nd, bool explicitFilename)
{
  EnableAsciiInternal (Ptr<OutputStreamWrapper> (), prefix, nd, explicitFilename);
}

  void 
AsciiTraceHelperForDevice::EnableAscii (Ptr<OutputStreamWrapper> stream, Ptr<NetDevice> nd)
{
  EnableAsciiInternal (stream, std::string (), nd, false);
}
 
```

​	这两种方法将直接调用EnableAsciiInternal的设备实现，并提供有效的前缀或流作为形参。 所有其他公共的ASCII追踪方法都将基于这些低级功能提供其他用户级功能。 对用户而言，这意味着系统中的所有设备助手都将具有所有可用的ASCII追踪方法。 如果设备正确实现EnablAsciiInternal，则所有设备上的这些方法都将以相同的方式工作。

​	

###### 方法

```C++
  /**
   * @brief Enable ascii trace output on the indicated net device.
   *
   * @param prefix Filename prefix to use for ascii files.
   * @param nd Net device for which you want to enable tracing.
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  void EnableAscii (std::string prefix, Ptr<NetDevice> nd, bool explicitFilename = false);

  /**
   * @brief Enable ascii trace output on the indicated net device.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * @param nd Net device for which you want to enable tracing.
   */
  void EnableAscii (Ptr<OutputStreamWrapper> stream, Ptr<NetDevice> nd);

  /**
   * @brief Enable ascii trace output the indicated net device using a device 
   * previously named using the ns-3 object name service.
   *
   * @param prefix filename prefix to use for ascii files.
   * @param ndName The name of the net device in which you want to enable tracing.
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  void EnableAscii (std::string prefix, std::string ndName, bool explicitFilename = false);

  /**
   * @brief Enable ascii trace output the indicated net device using a device 
   * previously named using the ns-3 object name service.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * @param ndName The name of the net device in which you want to enable tracing.
   */
  void EnableAscii (Ptr<OutputStreamWrapper> stream, std::string ndName);

  /**
   * @brief Enable ascii trace output on each device in the container which is
   * of the appropriate type.
   *
   * @param prefix Filename prefix to use for ascii files.
   * @param d container of devices
   */
  void EnableAscii (std::string prefix, NetDeviceContainer d);

  /**
   * @brief Enable ascii trace output on each device in the container which is
   * of the appropriate type.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * @param d container of devices
   */
  void EnableAscii (Ptr<OutputStreamWrapper> stream, NetDeviceContainer d);

  /**
   * @brief Enable ascii trace output on each device (which is of the 
   * appropriate type) in the nodes provided in the container.
   *
   * \param prefix Filename prefix to use for ascii files.
   * \param n container of nodes.
   */
  void EnableAscii (std::string prefix, NodeContainer n);

  /**
   * @brief Enable ascii trace output on each device (which is of the 
   * appropriate type) in the nodes provided in the container.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * \param n container of nodes.
   */
  void EnableAscii (Ptr<OutputStreamWrapper> stream, NodeContainer n);

  /**
   * @brief Enable ascii trace output on each device (which is of the
   * appropriate type) in the set of all nodes created in the simulation.
   *
   * @param prefix Filename prefix to use for ascii files.
   */
  void EnableAsciiAll (std::string prefix);

  /**
   * @brief Enable ascii trace output on each device (which is of the
   * appropriate type) in the set of all nodes created in the simulation.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   */
  void EnableAsciiAll (Ptr<OutputStreamWrapper> stream);

  /**
   * @brief Enable ascii trace output on the device specified by a global 
   * node-id (of a previously created node) and associated device-id.
   *
   * @param prefix Filename prefix to use when creating ascii trace files
   * @param nodeid The node identifier/number of the node on which to enable
   *               ascii tracing
   * @param deviceid The device identifier/index of the device on which to enable
   *               ascii tracing
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  void EnableAscii (std::string prefix, uint32_t nodeid, uint32_t deviceid, bool explicitFilename);

  /**
   * @brief Enable ascii trace output on the device specified by a global 
   * node-id (of a previously created node) and associated device-id.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * @param nodeid The node identifier/number of the node on which to enable
   *               ascii tracing
   * @param deviceid The device identifier/index of the device on which to enable
   *               ascii tracing
   */
  void EnableAscii (Ptr<OutputStreamWrapper> stream, uint32_t nodeid, uint32_t deviceid);
```

​	可用于ASCII追踪的方法是用于PCAP追踪的方法的两倍。 这是因为除了将每个唯一节点/设备对的追踪信息写入一个唯一文件的PCAP样式模型之外，还支持将许多节点/设备对的追踪信息都写入一个公共文件的模型。 这意味着可以将`<前缀>-<节点号>-<设备号>`的文件名生成机制替换为输出为文件的机制。 并且为了允许所有组合形式，API方法的数量增加了一倍。
​	

* 就像在PCAP追踪中一样，可以通过为EnableAscii方法提供`Ptr<NetDevice>`来在特定的“节点/网络设备”对上启用ASCII追踪。 由于网络设备必须属于一个节点，因此`Ptr<Node>`是隐式的。 例如：

    ```C++
    Ptr<NetDevice> nd;
    ...
    helper.EnableAscii ("prefix", nd);
    ```

    ​	

​	类似于PCAP追踪，前四个方法还包括一个名为explicitFilename的参数。默认不会将任何追踪上下文写入ASCII追踪文件，因为它们将是多余的。 系统将使用与PCAP部分中描述的规则相同的规则来选择要创建的文件名，不同之处在于文件的后缀为.tr而不是.pcap。

​	

* 如果要在多个网络设备上启用ASCII追踪并将所有追踪信息存储到单个文件，则也可以通过使用对象引用单个文件来实现。 我们已经在前面的例子中看到了这一点：

    ```C++
    Ptr<NetDevice> nd1;
    Ptr<NetDevice> nd2;
    ...
    Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
    ...
    helper.EnableAscii (stream, nd1);
    helper.EnableAscii (stream, nd2);
    ```

​	在这种情况下，由于需要使用追踪上下文来消除来自两个设备的追踪的歧义，因此会将追踪上下文写入ASCII追踪文件。 注意，由于用户完全指定了文件名，因此该字符串应包含.tr后缀以保持一致。

​	

* 可以通过向EnableAscii方法提供表示对象名称服务字符串的std::string来在特定的“节点/网络设备”对上启用ASCII追踪。 系统通过查询名称字符串来寻找`Ptr<NetDevice>`。 同样因为命名的网络设备必须恰好属于一个节点，所以`<Node>`是隐式的。 例如：

    ```C++
    Names::Add ("client" ...);
    Names::Add ("client/eth0" ...);
    Names::Add ("server" ...);
    Names::Add ("server/eth0" ...);
    ...
    helper.EnableAscii ("prefix", "client/eth0");
    helper.EnableAscii ("prefix", "server/eth0");
    ```

    ​	这将生成两个文件：“prefix-client-eth0.tr”和“prefix-server-eth0.tr”，并在各自的追踪文件中包含对其中每个设备的追踪。 由于所有EnableAscii函数都已重写以使用streamwrapper，也可以使用该形式：

    ```C++
    Names::Add ("client" ...);
    Names::Add ("client/eth0" ...);
    Names::Add ("server" ...);
    Names::Add ("server/eth0" ...);
    ...
    Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
    ...
    helper.EnableAscii (stream, "client/eth0");
    helper.EnableAscii (stream, "server/eth0");
    ```

    ​	这将生成一个名为“trace-file-name.tr”的追踪文件，其中包含两个设备的所有追踪事件。 追踪上下文字符串将消除事件之间的歧义。

​	

* 可以通过向EnableAscii方法提供NetDeviceContainer来在“节点/网络设备”对的集合上启用ASCII追踪。 对于容器中的每个NetDevice将会检查其类型。 与设备助手所管理的类型相同的每个设备都将启用追踪。 同样因为网络设备必须恰好属于一个节点，所以`<Node>`是隐式的。例如：

    ```C++
    NetDeviceContainer d = ...;
    ...
    helper.EnableAscii ("prefix", d);
    ```

    ​	这将创建许多ASCII追踪文件，每个文件均遵循`<前缀>-<节点号>-<设备号>.tr`的命名规则。

    ​	

    ​	与上面的示例类似，也可以将所有追踪信息输出到一个文件中：

    ```C++
    NetDeviceContainer d = ...;
    ...
    Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
    ...
    helper.EnableAscii (stream, d);
    ```

    ​	

* 可以通过向EnableAscii方法提供NodeContainer来在“节点/网络设备”对的集合上启用ASCII追踪。 对于NodeContainer中的每个节点，都会迭代其连接的NetDevices并将检查设备的类型。 对与设备助手所管理的类型相同类型的每个设备启用追踪：

    ```C++
    NodeContainer n;
    ...
    helper.EnableAscii ("prefix", n);
    ```

    ​	这将创建许多ASCII追踪文件，每个文件均遵循`<前缀>-<节点号>-<设备号>.tr`的命名规则。

    ​	

    ​	同样也可以将所有追踪输出到一个文件中：

    ```C++
    NodeContainer n = ...;
    ...
    Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
    ...
    helper.EnableAscii (stream, n);
    ```

    ​	

* 可以通过向EnableAscii方法提供显式的节点ID与设备ID来启用ASCII追踪。 系统中的每个节点都有一个整型的节点ID，连接到该节点的每个设备都有一个整型的设备ID。例如：

    ```C++
    helper.EnableAscii ("prefix", 21, 1);
    ```

    ​	

    ​	同样也可以将所有追踪信息输出到一个文件中：

    ```C++
    Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
    helper.EnableAscii (stream, 21, 1);
    ```

    

* 可以为系统中的所有类型与设备助手所管理的类型相同的设备启用ASCII追踪：

    ```C++
    helper.EnableAsciiAll ("prefix");
    ```

    ​	这将为系统中与助手管理的类型相同的每一个设备都创建一个ASCII追踪文件， 所有这些文件都将遵循`<前缀>-<节点号>-<设备号>.tr`的命名规则。

    ​	

    同样也可以将所有追踪信息输出到一个文件中：

    ```C++
    Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
    helper.EnableAsciiAll (stream);
    ```

    ​	

###### 文件名

​	上面的前缀样式方法说明中隐含的是通过实现方法构造完整的文件名。按照惯例，NS3系统中的ASCII追踪文件名格式为`<前缀>-<节点号>-<设备号>.tr`。

​	如前所述，系统中的每个节点都将具有系统分配的节点号。每个设备都将具有相对于其节点的接口索引（也称为设备号）。默认情况下，由于在节点21的设备1上启用了使用前缀“prefix”的追踪而创建的ASCII追踪文件名将会是`前缀-21-1.tr`。

​	始终可以使用NS3对象名称服务来使这一点更加清楚。例如，如果使用对象名称服务将名称“server”分配给节点21，则结果ASCII追踪文件名将自动变为`prefix-server-1.tr`，并且如果还将名称“eth0”也分配给节点21的设备1，ASCII追踪文件名将自动选择该名称，并将其命名为`prefix-server-eth0.tr`。

​	几种方法都有一个默认参数“explicitFilename”。设置为true时，此参数将禁用自动文件名完成机制并允许我们创建显式文件名。此选项仅在带有前缀并在单个设备上启用追踪的方法中可用。

​	

#### 3.13.2 协议助手

##### PCAP追踪

​	这些mixin的目标是使向协议添加一致的PCAP跟踪工具变得容易。我们希望所有各种形式的PCAP追踪在所有协议中都可以相同地工作，因此这些助手的方法由堆栈助手继承。如果要在查看实际代码时关注讨论，请查看src/network/helper/trace-helper.h。

​	在本节中，我们将说明应用于协议IPv4的方法。如果要在类似协议中指定追踪只需替换适当的类型即可。例如，使用`Ptr<Ipv6>`代替`Ptr<Ipv4>`，然后调用`EnablePcapIpv6`而不是`EnablePcapIpv4`。

​	PcapHelperForIpv4类为在IPv4协议中使用PCAP追踪提供了高级功能。每个启用这些方法的协议助手都必须实现从此类继承的单个虚拟方法。例如，IPv6将有一个单独的实现，但是唯一的区别是方法名和签名。要使IPv4类与IPv6类区别开来需要使用不同的方法名称，它们都源于Object类以及共享相同签名的方法。

​	以下代码在src/internet/helper/internet-trace-helper.h，教程里的那个地址找不到对应的函数。

```C++
class PcapHelperForIpv4
{
public:
……
/**
   * @brief Enable pcap output the indicated Ipv4 and interface pair.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param ipv4 Ptr<Ipv4> on which you want to enable tracing.
   * @param interface Interface on ipv4 on which you want to enable tracing.
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  virtual void EnablePcapIpv4Internal (std::string prefix, 
                                       Ptr<Ipv4> ipv4, 
                                       uint32_t interface,
                                       bool explicitFilename) = 0;
  ……
};
```

​	此方法的签名反映了此级别情况的协议和以接口为中心的视图。 从PcapHelperForIpv4类继承的所有公共方法都简化为调用此与设备有关的实现方法。 例如，最低级别的PCAP方法：

```C++
/**
   * @brief Enable pcap output the indicated Ipv4 and interface pair.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param ipv4 Ptr<Ipv4> on which you want to enable tracing.
   * @param interface Interface on ipv4 on which you want to enable tracing.
   * @param explicitFilename Treat the prefix as an explicit filename if true.
   */
  void EnablePcapIpv4 (std::string prefix, Ptr<Ipv4> ipv4, uint32_t interface, bool explicitFilename = false);

//对应的实现
  void 
PcapHelperForIpv4::EnablePcapIpv4 (std::string prefix, Ptr<Ipv4> ipv4, uint32_t interface, bool explicitFilename)
{
  EnablePcapIpv4Internal (prefix, ipv4, interface, explicitFilename);
}
```

​	将直接调用EnablePcapIpv4Internal的设备实现。 所有其他公共的PCAP追踪方法均以该实现为基础，以提供其他用户级别的功能。 对用户而言，这意味着系统中的所有协议助手都将具有所有可用的PCAP追踪方法。 如果正确实现了EnablePcapIpv4Internal，则这些方法在所有协议中的工作方式都相同。

​	

###### 方法

​	这些方法被设计成与设备版本的以节点和网络设备为中心的版本一一对应。我们使用“协议/接口”对约束代替“节点/网络设备”对约束。

​	如同设备助手版本，协议版本有以下方法：

```C++
  /**
   * @brief Enable pcap output the indicated Ipv4 and interface pair.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param ipv4 Ptr<Ipv4> on which you want to enable tracing.
   * @param interface Interface on ipv4 on which you want to enable tracing.
   * @param explicitFilename Treat the prefix as an explicit filename if true.
   */
  void EnablePcapIpv4 (std::string prefix, Ptr<Ipv4> ipv4, uint32_t interface, bool explicitFilename = false);

  /**
   * @brief Enable pcap output the indicated Ipv4 and interface pair using a
   * Ptr<Ipv4> previously named using the ns-3 object name service.
   *
   * @param prefix filename prefix to use for pcap files.
   * @param ipv4Name Name of the Ptr<Ipv4> on which you want to enable tracing.
   * @param interface Interface on ipv4 on which you want to enable tracing.
   * @param explicitFilename Treat the prefix as an explicit filename if true.
   */
  void EnablePcapIpv4 (std::string prefix, std::string ipv4Name, uint32_t interface, bool explicitFilename = false);

  /**
   * @brief Enable pcap output on each Ipv4 and interface pair in the container.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param c Ipv4InterfaceContainer of Ipv4 and interface pairs
   */
  void EnablePcapIpv4 (std::string prefix, Ipv4InterfaceContainer c);

  /**
   * @brief Enable pcap output on all Ipv4 and interface pairs existing in the
   * nodes provided in the container.
   *
   * \param prefix Filename prefix to use for pcap files.
   * \param n container of nodes.
   */
  void EnablePcapIpv4 (std::string prefix, NodeContainer n);

  /**
   * @brief Enable pcap output on the Ipv4 and interface pair specified by a 
   * global node-id (of a previously created node) and interface.  Since there
   * can be only one Ipv4 aggregated to a node, the node-id unambiguously 
   * determines the Ipv4.
   *
   * @param prefix Filename prefix to use for pcap files.
   * @param nodeid The node identifier/number of the node on which to enable tracing.
   * @param interface Interface on ipv4 on which you want to enable tracing.
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  void EnablePcapIpv4 (std::string prefix, uint32_t nodeid, uint32_t interface, bool explicitFilename);

  /**
   * @brief Enable pcap output on all Ipv4 and interface pairs existing in the 
   * set of all nodes created in the simulation.
   *
   * @param prefix Filename prefix to use for pcap files.
   */
  void EnablePcapIpv4All (std::string prefix);
```

​	

* 可以通过向EnablePcap方法提供`Ptr<Ipv4>`和`接口号`来在特定的“协议/接口”对上启用PCAP追踪。 例如：

    ```C++
    Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
    ...
    helper.EnablePcapIpv4 ("prefix", ipv4, 0);
    ```

    ​	

* 可以通过向EnablePcap方法提供表示对象名称服务字符串的std::string来在特定的“协议/接口”对上启用PCAP追踪。 系统将会在名称字符串中查找`Ptr<Ipv4>`。例如：

    ```C++
    Names::Add ("serverIPv4" ...);
    ...
    helper.EnablePcapIpv4 ("prefix", "serverIpv4", 1);
    ```

    ​	

* 可以通过向EnablePcap方法提供Ipv4InterfaceContainer来在“协议/接口”对的集合上启用PCAP追踪。 对于容器中的每个“IPv4/接口”对，都会检查协议类型。 对于与设备助手所管理的类型相同类型的每个协议，将为相应的接口启用追踪。 例如：

    ```C++
    NodeContainer nodes;
    ...
    NetDeviceContainer devices = deviceHelper.Install (nodes);
    ...
    Ipv4AddressHelper ipv4;
    ipv4.SetBase ("10.1.1.0", "255.255.255.0");
    Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);
    ...
    helper.EnablePcapIpv4 ("prefix", interfaces);
    ```

    ​	

* 可以通过向EnablePcap方法提供NodeContainer来在“协议/接口”对的集合上启用PCAP跟踪。 对于NodeContainer中的每个节点将找到适当的协议。 对于每个协议将枚举其接口并在结果对上启用追踪。 例如：

    ```C++
    NodeContainer n;
    ...
    helper.EnablePcapIpv4 ("prefix", n);
    ```

    ​	

* 可以通过向EnablePcap方法提供节点号及接口号来启用PCAP追踪。 在这种情况下，系统将节点号转换为`Ptr<Node>`并在节点中查找适当的协议。 查到的协议和接口用于指定生成的trace source：

    ```C++
    helper.EnablePcapIpv4 ("prefix", 21, 1);
    ```

    ​	

* 可以为系统中的所有协议类型与设备助手所管理的协议相同的接口启用PCAP追踪：

    ```C++
    helper.EnablePcapIpv4All ("prefix");
    ```

    ​	

###### 文件名

​	上面所有方法描述中都隐含了通过实现方法构造完整文件名的过程。按照惯例，在NS3设备上获取的PCAP追踪的格式为`<前缀>-<节点号>-<设备号>.pcap`。在协议追踪的情况下，协议和节点之间存在一一对应的关系。这是因为协议对象已聚合到节点对象。由于系统中没有全局协议号，因此在文件命名中使用了相应的节点号。因此，在自动生成的文件名中可能会发生文件名冲突。因此，协议追踪的文件命名规则不一样。

​	如前所述，系统中的每个节点都有一个系统分配的节点号。由于协议实例和节点实例之间存在一一对应的关系，因此我们使用节点号。每个接口都有一个相对于其协议的接口号。约定`<前缀>-n<节点号>-i<接口号>.pcap`为协议助手中追踪文件的命名规则。因此，默认情况下，由于使用前缀“prefix”在节点21的IPv4协议的接口1上启用追踪而创建的PCAP文件名将为“prefix-n21-i1.pcap”。

​	始终可以使用NS3对象名称服务来使这一点更加清楚。例如，如果使用对象名称服务将名称“serverIpv4”分配给节点21上的`Ptr<Ipv4>`，则生成的PCAP追踪文件名将自动变为“prefix-nserverIpv4-i1.pcap”。

​	这几种方法都有一个默认参数“explicitFilename”。设置为true时，此参数将禁用自动文件名完成机制并允许我们创建显式文件名。此选项仅在带有前缀并在单个设备上启用追踪的方法中可用。

​	

##### ASCII追踪

​	ASCII追踪助手的行为与PCAP基本相似。在本节中，我们将说明应用于协议IPv4的方法。 如果要在类似协议中指定跟踪只需替换适当的类型即可。 例如，使用`Ptr<Ipv6>`代替`Ptr<Ipv4>`，然后调用EnableAsciiIpv6而不是EnableAsciiIpv4。

​	AsciiTraceHelperForIpv4类为协议助手添加了使用ASCII追踪的高级功能。 每个启用这些方法的协议都必须实现从此类继承的单个虚拟方法：

```C++
class AsciiTraceHelperForIpv4
{
public:
……
/* @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * @param prefix Filename prefix to use for ascii trace files.
   * @param ipv4 Ptr<Ipv4> on which you want to enable tracing.
   * @param interface The interface on which you want to enable tracing.
   * @param explicitFilename Treat the prefix as an explicit filename if true.
   */
  virtual void EnableAsciiIpv4Internal (Ptr<OutputStreamWrapper> stream, 
                                        std::string prefix, 
                                        Ptr<Ipv4> ipv4, 
                                        uint32_t interface,
                                        bool explicitFilename) = 0;
……
};
```

​	该方法的签名反映了该级别情况下以协议和接口为中心的视图。 以及帮助程序可能正在写入共享输出流的事实。 从AsciiTraceHelperForIpv4类继承的所有公共方法都简化为调用此与设备有关的实现方法。 例如，最低级别的ASCII追踪方法：

```C++
  /**
   * @brief Enable ascii trace output on the indicated Ipv4 and interface pair.
   *
   * @param prefix Filename prefix to use for ascii files.
   * @param ipv4 Ptr<Ipv4> on which you want to enable tracing.
   * @param interface The interface on which you want to enable tracing.
   * @param explicitFilename Treat the prefix as an explicit filename if true.
   */
  void EnableAsciiIpv4 (std::string prefix, Ptr<Ipv4> ipv4, uint32_t interface, bool explicitFilename = false);

  /**
   * @brief Enable ascii trace output on the indicated Ipv4 and interface pair.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * @param ipv4 Ptr<Ipv4> on which you want to enable tracing.
   * @param interface The interface on which you want to enable tracing.
   */
  void EnableAsciiIpv4 (Ptr<OutputStreamWrapper> stream, Ptr<Ipv4> ipv4, uint32_t interface);

//对应实现
void 
AsciiTraceHelperForIpv4::EnableAsciiIpv4 (std::string prefix, Ptr<Ipv4> ipv4, uint32_t interface, bool explicitFilename)
{
  EnableAsciiIpv4Internal (Ptr<OutputStreamWrapper> (), prefix, ipv4, interface, explicitFilename);
}

void 
AsciiTraceHelperForIpv4::EnableAsciiIpv4 (Ptr<OutputStreamWrapper> stream, Ptr<Ipv4> ipv4, uint32_t interface)
{
  EnableAsciiIpv4Internal (stream, std::string (), ipv4, interface, false);
}
```

​	这两种方法会直接调用EnableAsciiIpv4Internal的设备实现，并提供有效的前缀或流作为形参。 所有其他公共的ASCII追踪方法都将基于这些低级功能提供其他用户级功能。 对用户而言，这意味着系统中的所有设备助手都将具有所有可用的ASCII追踪方法。 如果能正确实现EnablAsciiIpv4Internal，则这些方法在协议之间的工作方式都相同。

​	

###### 方法

```C++
  /**
   * @brief Enable ascii trace output on the indicated Ipv4 and interface pair.
   *
   * @param prefix Filename prefix to use for ascii files.
   * @param ipv4 Ptr<Ipv4> on which you want to enable tracing.
   * @param interface The interface on which you want to enable tracing.
   * @param explicitFilename Treat the prefix as an explicit filename if true.
   */
  void EnableAsciiIpv4 (std::string prefix, Ptr<Ipv4> ipv4, uint32_t interface, bool explicitFilename = false);

  /**
   * @brief Enable ascii trace output on the indicated Ipv4 and interface pair.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * @param ipv4 Ptr<Ipv4> on which you want to enable tracing.
   * @param interface The interface on which you want to enable tracing.
   */
  void EnableAsciiIpv4 (Ptr<OutputStreamWrapper> stream, Ptr<Ipv4> ipv4, uint32_t interface);

  /**
   * @brief Enable ascii trace output the indicated Ipv4 and interface pair
   * using an Ipv4 previously named using the ns-3 object name service.
   *
   * @param prefix filename prefix to use for ascii files.
   * @param ipv4Name The name of the Ipv4 on which you want to enable tracing.
   * @param interface The interface on which you want to enable tracing.
   * @param explicitFilename Treat the prefix as an explicit filename if true.
   */
  void EnableAsciiIpv4 (std::string prefix, std::string ipv4Name, uint32_t interface, bool explicitFilename = false);

  /**
   * @brief Enable ascii trace output the indicated net device using a device 
   * previously named using the ns-3 object name service.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * @param ipv4Name The name of the Ipv4 on which you want to enable tracing.
   * @param interface The interface on which you want to enable tracing.
   */
  void EnableAsciiIpv4 (Ptr<OutputStreamWrapper> stream, std::string ipv4Name, uint32_t interface);

  /**
   * @brief Enable ascii trace output on each Ipv4 and interface pair in the 
   * container
   *
   * @param prefix Filename prefix to use for ascii files.
   * @param c Ipv4InterfaceContainer of Ipv4 and interface pairs on which to 
   *          enable tracing.
   */
  void EnableAsciiIpv4 (std::string prefix, Ipv4InterfaceContainer c);

  /**
   * @brief Enable ascii trace output on each device in the container which is
   * of the appropriate type.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * @param c Ipv4InterfaceContainer of Ipv4 and interface pairs on which to 
   *          enable tracing.
   */
  void EnableAsciiIpv4 (Ptr<OutputStreamWrapper> stream, Ipv4InterfaceContainer c);

  /**
   * @brief Enable ascii trace output on all Ipv4 and interface pairs existing
   * in the nodes provided in the container.
   *
   * \param prefix Filename prefix to use for ascii files.
   * \param n container of nodes.
   */
  void EnableAsciiIpv4 (std::string prefix, NodeContainer n);

  /**
   * @brief Enable ascii trace output on all Ipv4 and interface pairs existing
   * in the nodes provided in the container.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * \param n container of nodes.
   */
  void EnableAsciiIpv4 (Ptr<OutputStreamWrapper> stream, NodeContainer n);

  /**
   * @brief Enable ascii trace output on all Ipv4 and interface pairs existing
   * in the set of all nodes created in the simulation.
   *
   * @param prefix Filename prefix to use for ascii files.
   */
  void EnableAsciiIpv4All (std::string prefix);

  /**
   * @brief Enable ascii trace output on each device (which is of the
   * appropriate type) in the set of all nodes created in the simulation.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   */
  void EnableAsciiIpv4All (Ptr<OutputStreamWrapper> stream);

  /**
   * @brief Enable ascii trace output on the Ipv4 and interface pair specified by a
   * global node-id (of a previously created node) and interface.  Since there
   * can be only one Ipv4 aggregated to a node, the node-id unambiguously 
   * determines the Ipv4.
   *
   * @param prefix Filename prefix to use when creating ascii trace files
   * @param nodeid The node identifier/number of the node on which to enable
   *               ascii tracing
   * @param deviceid The device identifier/index of the device on which to enable
   *                 ascii tracing
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  void EnableAsciiIpv4 (std::string prefix, uint32_t nodeid, uint32_t deviceid, bool explicitFilename);

  /**
   * @brief Enable ascii trace output on the Ipv4 and interface pair specified by a
   * global node-id (of a previously created node) and interface.  Since there
   * can be only one Ipv4 aggregated to a node, the node-id unambiguously 
   * determines the Ipv4.
   *
   * @param stream An OutputStreamWrapper representing an existing file to use
   *               when writing trace data.
   * @param nodeid The node identifier/number of the node on which to enable
   *               ascii tracing
   * @param interface The interface on which you want to enable tracing.
   * @param explicitFilename Treat the prefix as an explicit filename if true
   */
  void EnableAsciiIpv4 (Ptr<OutputStreamWrapper> stream, uint32_t nodeid, uint32_t interface, bool explicitFilename);
```

​	可用于ASCII追踪的方法是用于PCAP跟踪的方法的两倍。 这是因为除了将来自每个唯一“协议/接口”对的追踪信息写入单个PCAP文件之外，还支持其中将多个“协议/接口”对的追踪信息写入一个公共文件。 这意味着需要将`<前缀>-n<节点号>-i<接口号>`的文件名生成机制替换为引用公共文件的机制。 并且为了允许所有组合形式，API方法的数量增加了一倍。

​	

* 就像在PCAP追踪中一样，可以通过向EnableAscii方法提供`Ptr<Ipv4>`与`接口号`来在特定的“协议/接口”对上启用ASCII追踪。例如：

    ```C++
    Ptr<Ipv4> ipv4;
    ...
    helper.EnableAsciiIpv4 ("prefix", ipv4, 1);
    ```

    ​	在这种情况下默认不会将任何追踪上下文写入ASCII追踪文件，因为它们将是多余的。 系统将使用与PCAP部分中描述的规则相同的规则来选择要创建的文件名，不同之处在于文件的后缀为.tr而不是.pcap。

    ​	

* 如果要在多个接口上启用ASCII追踪并将所有追踪信息存储到单个文件，则也可以通过使用对象引用单个文件来实现。 我们已经在前面的例子中看到了这一点：

    ```C++
    Ptr<Ipv4> protocol1 = node1->GetObject<Ipv4> ();
    Ptr<Ipv4> protocol2 = node2->GetObject<Ipv4> ();
    ...
    Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
    ...
    helper.EnableAsciiIpv4 (stream, protocol1, 1);
    helper.EnableAsciiIpv4 (stream, protocol2, 1);
    ```

    ​	在这种情况下，由于需要使用追踪上下文来消除来自两个设备的追踪的歧义，因此会将追踪上下文写入ASCII追踪文件。 注意，由于用户完全指定了文件名，因此该字符串应包含.tr后缀以保持一致。

    ​	

* 可以通过向EnableAscii方法提供表示对象名称服务字符串的std::string来启用特定协议上的ASCII追踪。 系统通过查询名称字符串来寻找`Ptr<Ipv4>`。 因为协议实例和节点之间存在一一对应的关系，所以文件名中的`<Node>`是隐式的。例如：

    ```C++
    Names::Add ("node1Ipv4" ...);
    Names::Add ("node2Ipv4" ...);
    ...
    helper.EnableAsciiIpv4 ("prefix", "node1Ipv4", 1);
    helper.EnableAsciiIpv4 ("prefix", "node2Ipv4", 1);
    ```

    ​	这将生成两个文件：“prefix-nnode1Ipv4-i1.tr”和“prefix-nnode2Ipv4-i1.tr”，并在各自的追踪文件中包含对其中每个接口的追踪。 由于所有EnableAscii函数都已重写以使用streamwrapper，也可以使用以下形式：

    ```C++
    Names::Add ("node1Ipv4" ...);
    Names::Add ("node2Ipv4" ...);
    ...
    Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
    ...
    helper.EnableAsciiIpv4 (stream, "node1Ipv4", 1);
    helper.EnableAsciiIpv4 (stream, "node2Ipv4", 1);
    ```

    ​	这将生成一个名为“trace-file-name.tr”的追踪文件，其中包含两个接口的所有追踪事件。 追踪上下文字符串将消除事件之间的歧义。

    ​	

* 可以通过向EnableAscii方法提供Ipv4InterfaceContainer在“协议/接口”对的集合上启用ASCII跟踪。 对于与设备助手所管理的类型相同的的每个协议，将为相应的接口启用跟踪。 同样因为每个协议与其节点之间存在一一对应的关系，所以`<Node>`是隐式的。例如：

    ```C++
    NodeContainer nodes;
    ...
    NetDeviceContainer devices = deviceHelper.Install (nodes);
    ...
    Ipv4AddressHelper ipv4;
    ipv4.SetBase ("10.1.1.0", "255.255.255.0");
    Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);
    ...
    ...
    helper.EnableAsciiIpv4 ("prefix", interfaces);
    ```

    ​	这将创建许多ASCII跟踪文件，每个文件都遵循`<前缀>-n<节点号>-i<接口号>.tr`的命名规则。

    ​	

    ​	与上面的示例类似，也可以将所有追踪信息输出到一个文件中：

    ```C++
    NodeContainer nodes;
    ...
    NetDeviceContainer devices = deviceHelper.Install (nodes);
    ...
    Ipv4AddressHelper ipv4;
    ipv4.SetBase ("10.1.1.0", "255.255.255.0");
    Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);
    ...
    Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
    ...
    helper.EnableAsciiIpv4 (stream, interfaces);
    ```

    ​	

* 可以通过向EnableAscii方法提供NodeContainer来在“协议/接口”对的集合上启用ASCII追踪。  对于NodeContainer中的每个节点将找到适当的协议。 对于每个协议将枚举其接口并在结果对上启用追踪。 例如：

    ```C++
    NodeContainer n;
    ...
    helper.EnableAsciiIpv4 ("prefix", n);
    ```

    ​	这将创建许多ASCII跟踪文件，每个文件都遵循`<前缀>-<节点号>-<设备号>.tr`的命名规则。

    ​	

    ​	也可以将所有追踪信息输出到一个文件中：

    ```C++
    NodeContainer n;
    Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
    helper.EnableAsciiIpv4 (stream, n);
    ```

    ​	

* 可以通过向EnableAscii方法提供节点号和设备号来启用PCAP追踪。 在这种情况下，系统将节点号转换为`Ptr<Node>`并在节点中查找适当的协议。 查到的协议和接口用于指定生成的trace source：

    ```C++
    helper.EnableAsciiIpv4 ("prefix", 21, 1);
    ```

    ​	

    ​	同样也可以将所有追踪信息输出到一个文件中：

    ```C++
    Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
    helper.EnableAsciiIpv4 (stream, 21, 1);
    ```

    ​	

* 可以为系统中的所有协议类型与设备助手所管理的协议相同的接口启用ASCII追踪：

    ```C++
    helper.EnableAsciiIpv4All ("prefix");
    ```

    ​	这将为系统中与助手管理的类型相同的每一个设备都创建一个ASCII追踪文件， 所有文件都将遵循`<前缀>-n<节点号>-i<接口号>.tr`的命名规则。 

    ​	

    ​	也可以将所有追踪信息输出到一个文件中：

    ```C++
    Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("trace-file-name.tr");
    helper.EnableAsciiIpv4All (stream);
    ```

    ​	

###### 文件名

​	上面的前缀样式方法说明中隐含的是通过实现方法构造完整的文件名。NS3系统中的ASCII追踪包文件名格式为`<前缀>-<节点号>-<设备号>.tr`。

​	如前所述，系统中的每个节点都有一个系统分配的节点号。由于协议和节点之间存在一对一的对应关系，因此我们可以使用节点号来标识协议身份。给定协议上的每个接口都会有一个相对于其协议的接口索引（也简称为接口）。默认情况下，使用前缀“prefix”在节点21的设备1上启用追踪而创建的ASCII追踪文件将会是“prefix-n21-i1.tr”。使用前缀可消除每个节点的多个协议的歧义。

​	始终可以使用NS3对象名称服务来使这一点更加清楚。如果使用对象名称服务为节点21上的协议分配名称“serverIpv4”并指定接口1，则ASCII追踪文件名将自动变为“prefix-nserverIpv4-1.tr”。

​	以上几种方法都有一个默认参数“explicitFilename”。设置为true时，此参数将禁用自动文件名完成机制，并允许我们创建显式文件名。此选项仅在带有前缀并在单个设备上启用追踪的方法中可用。

​	

#### 3.13.3 总结

​	NS3包含一个极其丰富的环境，它允许不同级别的用户可以从仿真中定制提取的信息种类：其中有高级助手功能，使用户可以简单地控制预定义输出的收集，以达到良好的粒度。也有中级助手功能，使更老练的用户可以自定义如何提取和保存信息。并且具有低级核心功能，允许专家用户更改系统以呈现新的和以前未导出的信息，以便更高级别的用户可以立即访问它们。

​	这是一个非常全面的系统，特别是对于新用户或不熟悉C++及其通俗用法的用户，我们要消化很多东西。我们应该把追踪系统视为NS3的重要组成部分，所以建议对其尽可能熟悉。一旦掌握了追踪系统，就可能很容易理解NS3系统的其余部分。

​	

### 3.14 收集数据

​	运行模拟的主要目的之一是生成输出数据以用于研究目的或仅了解系统。在sixth.cc中我们介绍了追踪子系统和示例并从中生成了PCAP或ASCII追踪文件。这些追踪信息对于使用各种外部工具进行数据分析非常有价值，对于许多用户而言，此类输出数据是收集数据（供外部工具进行分析）的首选方式。但除了生成追踪文件之外，还有一些用例，其中包括：

* 生成的数据无法很好地映射到PCAP或ASCII追踪，例如非数据包数据（例如协议状态机转换）。

* 大型模拟，用于生成追踪文件的磁盘I/O要求过高或繁琐。

* 在仿真过程中需要进行在线数据缩减或计算。一个很好的例子是为仿真定义终止条件，告诉它何时收到足够的数据以围绕某个参数的估计值形成足够狭窄的置信区间及何时停止。

    ​	

​	NS3数据收集框架旨在提供除基于追踪输出之外的其他功能。建议对此主题感兴趣的读者查阅NS3 Manual以更详细地了解此框架；在这里，我们以seventh.cc总结了一些开发功能。

​	

### 3.15 seventh.cc

#### 3.15.1 代码学习

​	跟sixth.cc相比做出了一些改动，主要关注不一样的地方。seveth.cc的代码如下：

```C++
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <fstream>
#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"
#include "ns3/stats-module.h"

using namespace ns3;

NS_LOG_COMPONENT_DEFINE ("SeventhScriptExample");

// ===========================================================================
//
//         node 0                 node 1
//   +----------------+    +----------------+
//   |    ns-3 TCP    |    |    ns-3 TCP    |
//   +----------------+    +----------------+
//   |    10.1.1.1    |    |    10.1.1.2    |
//   +----------------+    +----------------+
//   | point-to-point |    | point-to-point |
//   +----------------+    +----------------+
//           |                     |
//           +---------------------+
//                5 Mbps, 2 ms
//
//
// We want to look at changes in the ns-3 TCP congestion window.  We need
// to crank up a flow and hook the CongestionWindow attribute on the socket
// of the sender.  Normally one would use an on-off application to generate a
// flow, but this has a couple of problems.  First, the socket of the on-off
// application is not created until Application Start time, so we wouldn't be
// able to hook the socket (now) at configuration time.  Second, even if we
// could arrange a call after start time, the socket is not public so we
// couldn't get at it.
//
// So, we can cook up a simple version of the on-off application that does what
// we want.  On the plus side we don't need all of the complexity of the on-off
// application.  On the minus side, we don't have a helper, so we have to get
// a little more involved in the details, but this is trivial.
//
// So first, we create a socket and do the trace connect on it; then we pass
// this socket into the constructor of our simple application which we then
// install in the source node.
// ===========================================================================
//
class MyApp : public Application
{
public:
  MyApp ();
  virtual ~MyApp ();

  /**
   * Register this type.
   * \return The TypeId.
   */
  static TypeId GetTypeId (void);
  void Setup (Ptr<Socket> socket, Address address, uint32_t packetSize, uint32_t nPackets, DataRate dataRate);

private:
  virtual void StartApplication (void);
  virtual void StopApplication (void);

  void ScheduleTx (void);
  void SendPacket (void);

  Ptr<Socket>     m_socket;
  Address         m_peer;
  uint32_t        m_packetSize;
  uint32_t        m_nPackets;
  DataRate        m_dataRate;
  EventId         m_sendEvent;
  bool            m_running;
  uint32_t        m_packetsSent;
};

MyApp::MyApp ()
  : m_socket (0),
    m_peer (),
    m_packetSize (0),
    m_nPackets (0),
    m_dataRate (0),
    m_sendEvent (),
    m_running (false),
    m_packetsSent (0)
{
}

MyApp::~MyApp ()
{
  m_socket = 0;
}

/* static */
TypeId MyApp::GetTypeId (void)
{
  static TypeId tid = TypeId ("MyApp")
    .SetParent<Application> ()
    .SetGroupName ("Tutorial")
    .AddConstructor<MyApp> ()
    ;
  return tid;
}

void
MyApp::Setup (Ptr<Socket> socket, Address address, uint32_t packetSize, uint32_t nPackets, DataRate dataRate)
{
  m_socket = socket;
  m_peer = address;
  m_packetSize = packetSize;
  m_nPackets = nPackets;
  m_dataRate = dataRate;
}

void
MyApp::StartApplication (void)
{
  m_running = true;
  m_packetsSent = 0;
  if (InetSocketAddress::IsMatchingType (m_peer))
    {
      m_socket->Bind ();
    }
  else
    {
      m_socket->Bind6 ();
    }
  m_socket->Connect (m_peer);
  SendPacket ();
}

void
MyApp::StopApplication (void)
{
  m_running = false;

  if (m_sendEvent.IsRunning ())
    {
      Simulator::Cancel (m_sendEvent);
    }

  if (m_socket)
    {
      m_socket->Close ();
    }
}

void
MyApp::SendPacket (void)
{
  Ptr<Packet> packet = Create<Packet> (m_packetSize);
  m_socket->Send (packet);

  if (++m_packetsSent < m_nPackets)
    {
      ScheduleTx ();
    }
}

void
MyApp::ScheduleTx (void)
{
  if (m_running)
    {
      Time tNext (Seconds (m_packetSize * 8 / static_cast<double> (m_dataRate.GetBitRate ())));
      m_sendEvent = Simulator::Schedule (tNext, &MyApp::SendPacket, this);
    }
}

static void
CwndChange (Ptr<OutputStreamWrapper> stream, uint32_t oldCwnd, uint32_t newCwnd)
{
  NS_LOG_UNCOND (Simulator::Now ().GetSeconds () << "\t" << newCwnd);
  *stream->GetStream () << Simulator::Now ().GetSeconds () << "\t" << oldCwnd << "\t" << newCwnd << std::endl;
}

static void
RxDrop (Ptr<PcapFileWrapper> file, Ptr<const Packet> p)
{
  NS_LOG_UNCOND ("RxDrop at " << Simulator::Now ().GetSeconds ());
  file->Write (Simulator::Now (), p);
}

int
main (int argc, char *argv[])
{
  bool useV6 = false;

  CommandLine cmd (__FILE__);
  cmd.AddValue ("useIpv6", "Use Ipv6", useV6);
  cmd.Parse (argc, argv);

  NodeContainer nodes;
  nodes.Create (2);

  PointToPointHelper pointToPoint;
  pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
  pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));

  NetDeviceContainer devices;
  devices = pointToPoint.Install (nodes);

  Ptr<RateErrorModel> em = CreateObject<RateErrorModel> ();
  em->SetAttribute ("ErrorRate", DoubleValue (0.00001));
  devices.Get (1)->SetAttribute ("ReceiveErrorModel", PointerValue (em));

  InternetStackHelper stack;
  stack.Install (nodes);

  uint16_t sinkPort = 8080;
  Address sinkAddress;
  Address anyAddress;
  std::string probeType;
  std::string tracePath;
  if (useV6 == false)
    {
      Ipv4AddressHelper address;
      address.SetBase ("10.1.1.0", "255.255.255.0");
      Ipv4InterfaceContainer interfaces = address.Assign (devices);
      sinkAddress = InetSocketAddress (interfaces.GetAddress (1), sinkPort);
      anyAddress = InetSocketAddress (Ipv4Address::GetAny (), sinkPort);
      probeType = "ns3::Ipv4PacketProbe";
      tracePath = "/NodeList/*/$ns3::Ipv4L3Protocol/Tx";
    }
  else
    {
      Ipv6AddressHelper address;
      address.SetBase ("2001:0000:f00d:cafe::", Ipv6Prefix (64));
      Ipv6InterfaceContainer interfaces = address.Assign (devices);
      sinkAddress = Inet6SocketAddress (interfaces.GetAddress (1,1), sinkPort);
      anyAddress = Inet6SocketAddress (Ipv6Address::GetAny (), sinkPort);
      probeType = "ns3::Ipv6PacketProbe";
      tracePath = "/NodeList/*/$ns3::Ipv6L3Protocol/Tx";
    }

  PacketSinkHelper packetSinkHelper ("ns3::TcpSocketFactory", anyAddress);
  ApplicationContainer sinkApps = packetSinkHelper.Install (nodes.Get (1));
  sinkApps.Start (Seconds (0.));
  sinkApps.Stop (Seconds (20.));

  Ptr<Socket> ns3TcpSocket = Socket::CreateSocket (nodes.Get (0), TcpSocketFactory::GetTypeId ());

  Ptr<MyApp> app = CreateObject<MyApp> ();
  app->Setup (ns3TcpSocket, sinkAddress, 1040, 1000, DataRate ("1Mbps"));
  nodes.Get (0)->AddApplication (app);
  app->SetStartTime (Seconds (1.));
  app->SetStopTime (Seconds (20.));

  AsciiTraceHelper asciiTraceHelper;
  Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream ("seventh.cwnd");
  ns3TcpSocket->TraceConnectWithoutContext ("CongestionWindow", MakeBoundCallback (&CwndChange, stream));

  PcapHelper pcapHelper;
  Ptr<PcapFileWrapper> file = pcapHelper.CreateFile ("seventh.pcap", std::ios::out, PcapHelper::DLT_PPP);
  devices.Get (1)->TraceConnectWithoutContext ("PhyRxDrop", MakeBoundCallback (&RxDrop, file));

  // Use GnuplotHelper to plot the packet byte count over time
  GnuplotHelper plotHelper;

  // Configure the plot.  The first argument is the file name prefix
  // for the output files generated.  The second, third, and fourth
  // arguments are, respectively, the plot title, x-axis, and y-axis labels
  plotHelper.ConfigurePlot ("seventh-packet-byte-count",
                            "Packet Byte Count vs. Time",
                            "Time (Seconds)",
                            "Packet Byte Count");

  // Specify the probe type, trace source path (in configuration namespace), and
  // probe output trace source ("OutputBytes") to plot.  The fourth argument
  // specifies the name of the data series label on the plot.  The last
  // argument formats the plot by specifying where the key should be placed.
  plotHelper.PlotProbe (probeType,
                        tracePath,
                        "OutputBytes",
                        "Packet Byte Count",
                        GnuplotAggregator::KEY_BELOW);

  // Use FileHelper to write out the packet byte count over time
  FileHelper fileHelper;

  // Configure the file to be written, and the formatting of output data.
  fileHelper.ConfigureFile ("seventh-packet-byte-count",
                            FileAggregator::FORMATTED);

  // Set the labels for this formatted output file.
  fileHelper.Set2dFormat ("Time (Seconds) = %.3e\tPacket Byte Count = %.0f");

  // Specify the probe type, trace source path (in configuration namespace), and
  // probe output trace source ("OutputBytes") to write.
  fileHelper.WriteProbe (probeType,
                         tracePath,
                         "OutputBytes");

  Simulator::Stop (Seconds (20));
  Simulator::Run ();
  Simulator::Destroy ();

  return 0;
}
```

​	

* 131-146行代码：

```C++
void
MyApp::StartApplication (void)
{
  m_running = true;
  m_packetsSent = 0;
  if (InetSocketAddress::IsMatchingType (m_peer))
    {
      m_socket->Bind ();
    }
  else
    {
      m_socket->Bind6 ();
    }
  m_socket->Connect (m_peer);
  SendPacket ();
}
```

​	加入了对IPv6的支持，先判断地址是IPv4还是IPv6再启用相应的地址绑定。

​	

* 200-207行代码：

```C++
int
main (int argc, char *argv[])
{
  bool useV6 = false;

  CommandLine cmd (__FILE__);
  cmd.AddValue ("useIpv6", "Use Ipv6", useV6);
  cmd.Parse (argc, argv);
```

​	在命令行参数里加入了控制启用IPv6的选项，默认不启用。

​	

* 226-250行代码：

```C++
  uint16_t sinkPort = 8080;
  Address sinkAddress;
  Address anyAddress;
  std::string probeType;
  std::string tracePath;
  if (useV6 == false)
    {
      Ipv4AddressHelper address;
      address.SetBase ("10.1.1.0", "255.255.255.0");
      Ipv4InterfaceContainer interfaces = address.Assign (devices);
      sinkAddress = InetSocketAddress (interfaces.GetAddress (1), sinkPort);
      anyAddress = InetSocketAddress (Ipv4Address::GetAny (), sinkPort);
      probeType = "ns3::Ipv4PacketProbe";
      tracePath = "/NodeList/*/$ns3::Ipv4L3Protocol/Tx";
    }
  else
    {
      Ipv6AddressHelper address;
      address.SetBase ("2001:0000:f00d:cafe::", Ipv6Prefix (64));
      Ipv6InterfaceContainer interfaces = address.Assign (devices);
      sinkAddress = Inet6SocketAddress (interfaces.GetAddress (1,1), sinkPort);
      anyAddress = Inet6SocketAddress (Ipv6Address::GetAny (), sinkPort);
      probeType = "ns3::Ipv6PacketProbe";
      tracePath = "/NodeList/*/$ns3::Ipv6L3Protocol/Tx";
    }

```

​	采用判断条件来决定是走IPv4还是IPv6的代码，probeType跟tracePath留着以后给gnuplot使用。

​	

* 273-282行代码：

```C++
  // Use GnuplotHelper to plot the packet byte count over time
  GnuplotHelper plotHelper;

  // Configure the plot.  The first argument is the file name prefix
  // for the output files generated.  The second, third, and fourth
  // arguments are, respectively, the plot title, x-axis, and y-axis labels
  plotHelper.ConfigurePlot ("seventh-packet-byte-count",
                            "Packet Byte Count vs. Time",
                            "Time (Seconds)",
                            "Packet Byte Count");
```

​	使用gnuplot助手来绘制随时间变化的数据包数量。配置gnuplot，第一个参数是生成文件的前缀名，第二个参数是图表标题，第三四个参数分别为x轴变量名、y轴变量名。

​	

* 284-292行代码：

```C++
  // Specify the probe type, trace source path (in configuration namespace), and
  // probe output trace source ("OutputBytes") to plot.  The fourth argument
  // specifies the name of the data series label on the plot.  The last
  // argument formats the plot by specifying where the key should be placed.
  plotHelper.PlotProbe (probeType,
                        tracePath,
                        "OutputBytes",
                        "Packet Byte Count",
                        GnuplotAggregator::KEY_BELOW);
```

​	指定探测类型，追踪源在配置名称空间中的路径，以及探测要绘制的输出追踪源（“OutputBytes”）。 第四个参数指定绘图上数据标签的名称。 最后一个参数指定线代表的标签在图中的位置。前两个参数是探测类型的名称和追踪源路径，这两个参数可能是最难确定的。 此处的探测追踪是Ipv4L3Protocol类的Tx跟踪源。 当我们追此类实现时（src/internet/model/ipv4-l3-protocol.cc），我们可以看到：

```C++
.AddTraceSource ("Tx",
                     "Send ipv4 packet to outgoing interface.",
                     MakeTraceSourceAccessor (&Ipv4L3Protocol::m_txTrace),
                     "ns3::Ipv4L3Protocol::TxRxTracedCallback")
```

​	这表示Tx是变量m_txTrace的名称，其声明为：

```C++
  // The following two traces pass a packet with an IP header
  /// Trace of transmitted packets
  /// \deprecated The non-const \c Ptr<Ipv4> argument is deprecated
  /// and will be changed to \c Ptr<const Ipv4> in a future release.
  TracedCallback<Ptr<const Packet>, Ptr<Ipv4>,  uint32_t> m_txTrace;
```

​	此特定追踪源签名由Ipv4PacketProbe类支持。 请参阅文件src/internet/model/ipv4-packet-probe.h(.cc)。

​	因此，在上面的PlotProbe语句中，我们看到该语句使用匹配的NS3 Probe类型的Ipv4PacketProbe钩住追踪源（由路径字符串标识）。 如果我们不支持这种探针类型（匹配追踪源签名），则我们可能不会使用此语句（尽管可以如手册中所述使用一些更复杂的低级语句）。

​	Ipv4PacketProbe本身会导出一些追踪源，这些追踪源将从探测到的Packet对象中提取数据：

```C++
//ipv4-packet-probe.cc
TypeId
Ipv4PacketProbe::GetTypeId ()
{
  static TypeId tid = TypeId ("ns3::Ipv4PacketProbe")
    .SetParent<Probe> ()
    .SetGroupName ("Internet")
    .AddConstructor<Ipv4PacketProbe> ()
    .AddTraceSource ( "Output",
                      "The packet plus its IPv4 object and interface "
                      "that serve as the output for this probe",
                      MakeTraceSourceAccessor (&Ipv4PacketProbe::m_output),
                      "ns3::Ipv4L3Protocol::TxRxTracedCallback")
    .AddTraceSource ( "OutputBytes",
                      "The number of bytes in the packet",
                      MakeTraceSourceAccessor (&Ipv4PacketProbe::m_outputBytes),
                      "ns3::Packet::SizeTracedCallback")
  ;
  return tid;
}
```

​	

​	支持探测的其他追踪值：

| **追踪值类型** | **探测类型**    | **文件路径**                    |
| -------------- | --------------- | ------------------------------- |
| double         | DoubleProbe     | stats/model/double-probe.h      |
| uint8_t        | Uinteger8Probe  | stats/model/uinteger-8-probe.h  |
| uint16_t       | Uinteger16Probe | stats/model/uinteger-16-probe.h |
| uint32_t       | Uinteger32Probe | stats/model/uinteger-32-probe.h |
| bool           | BooleanProbe    | stats/model/uinteger-16-probe.h |
| ns3::Time      | TimeProbe       | stats/model/time-probe.h        |

​	

​	支持探测的其他追踪源类型：

| **追踪源类型**                         | **探测类型**           | **探测输出** | **文件**                                      |
| -------------------------------------- | ---------------------- | ------------ | --------------------------------------------- |
| Ptr<const Packet>                      | PacketProbe            | OutputBytes  | network/utils/packet-probe.h                  |
| Ptr<const Packet>, Ptr<Ipv4>, uint32_t | Ipv4PacketProbe        | OutputBytes  | internet/model/ipv4-packet-probe.h            |
| Ptr<const Packet>, Ptr<Ipv6>, uint32_t | Ipv6PacketProbe        | OutputBytes  | internet/model/ipv6-packet-probe.h            |
| Ptr<const Packet>, Ptr<Ipv6>, uint32_t | Ipv6PacketProbe        | OutputBytes  | internet/model/ipv6-packet-probe.h            |
| Ptr<const Packet>, const Address&      | ApplicationPacketProbe | OutputBytes  | applications/model/application-packet-probe.h |

​	可以看出，仅支持少数追踪源，并且它们都输出以字节为单位的数据包大小。 但这些助手可以支持大多数追踪值可用的基本数据类型。

​	

* 294-295行代码：

```C++
  // Use FileHelper to write out the packet byte count over time
  FileHelper fileHelper;
```

​	声明了一个文件助手用于生成包含随时间变化的数据包的文件。

​	

* 297-299行代码：

```C++
  // Configure the file to be written, and the formatting of output data.
  fileHelper.ConfigureFile ("seventh-packet-byte-count",
                            FileAggregator::FORMATTED);
```

​	设置了所生成文件的文件前缀，以及文件的数据格式，还有其他格式例如SPACE_SEPARATED、COMMA_SEPARATED和TAB_SEPARATED，以方便我们后期使用数据。

​	

* 301-302行代码：

```C++
  // Set the labels for this formatted output file.
  fileHelper.Set2dFormat ("Time (Seconds) = %.3e\tPacket Byte Count = %.0f");
```

​	给生成的文件内容设置输出格式，仅在上一步把格式设置为FORMATTED才可以在这里修改输出格式，否则直接采用上面指定的格式。

​	

* 304-308行代码：

```C++
  // Specify the probe type, trace source path (in configuration namespace), and
  // probe output trace source ("OutputBytes") to write.
  fileHelper.WriteProbe (probeType,
                         tracePath,
                         "OutputBytes");
```

​	指定探测类型，追踪源在配置名称空间中的路径，以及探测要绘制的输出追踪源（“OutputBytes”）。

​	

#### 3.15.2 编译运行

​	命令行内输入：

```shell
./waf --run scratch/seventh
```

​	可以看到输出较多，打开ns3.31文件夹，将会看到生成了许多文件：

![image-20200902203040877](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEFZF1eZBfegNEsiG4gaR6L5tZqynOGIzVZrm80ZX6TPSMKbPxIL5Lwkw0WHzKz1efI9fah83HJIThg2iiTJHsY0!/r)

​	

​	下面对这些文件进行解读：

​	GnuplotHelper是一个NS3助手对象，在常见情况下，该对象旨在以尽可能少的语句生成gnuplot图。 它将NS3追踪源与数据收集系统支持的数据类型挂钩。 并非支持所有的NS3追踪源数据类型，但支持许多常见的追踪类型，包括带有纯旧数据（POD）类型的TracedValues。

​	看一下由GnuplotHelper生成的文件`seventh-packet-byte-count.dat`、`seventh-packet-byte-count.plt`以及`seventh-packet-byte-count.sh`。

​	第一个是gnuplot数据文件，带有一系列以空格分隔的时间戳和数据包字节数。 我们将在下面介绍如何配置此特定数据。 seventh-packet-byte-count.plt是一个gnuplot绘图文件，可以在gnuplot中打开。 懂gnuplot语法的读者可以看到，这将生成一个格式化的输出PNG文件，该文件名为seventh-packet-byte-count-png。 最后可以通过在命令行中执行seventh-packet-byte-count.sh，通过gnuplot运行该绘图文件以生成可以在图像编辑器中查看的PNG图片：

```shell
$ sh seventh-packet-byte-count.sh
```

![image-20200902204403752](http://r.photo.store.qq.com/psc?/V53mQfQh1FnNCr2V9md70Xppby3h3SOQ/TmEUgtj9EK6.7V8ajmQrEMe4FPjxUjp9.62R0mACUg98zu9EcBhuVXVxcFPFXIaE4b7RfiJHwBOL7w9oGRoboWPgTJ0c.kMUl3uLALceTY4!/r)

​	为什么不直接生成这个PNG文件而是通过脚本生成？ 答案是：通过plt文件，用户可以在生成PNG之前手动配置结果（如果需要）。

​	PNG图像标题指出，此图是“数据包字节数与时间”的图，并且它正在绘制与追踪路径相对应的探测数据。总之，此图捕获的是在Ipv4L3Protocol对象的传输追踪源处观察到的数据包字节的图。 一个方向上大部分是596字节的TCP段，而另一个方向上是60字节的TCP ack。

​	FileHelper类只是前面的GnuplotHelper的变体，提供了带有时间戳的格式化数据的输出：

```C++
Time (Seconds) = 1.000e+00	Packet Byte Count = 56
Time (Seconds) = 1.004e+00	Packet Byte Count = 52
Time (Seconds) = 1.004e+00	Packet Byte Count = 588
Time (Seconds) = 1.009e+00	Packet Byte Count = 588
Time (Seconds) = 1.009e+00	Packet Byte Count = 588
……
```

​	可以看到有两个文件，一个是节点0的，一个是节点1的。 GnuplotHelper中两个数据都在同一个图上，但FileHelper是有两个单独的文件被写入磁盘。

​	

